/**
 * Flowtype definitions for typescript
 * Generated by Flowgen from a Typescript Definition
 * Edited by hand
 * Flowgen v1.4.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 * @flow
 */

declare module "typescript" {
  /**
 * Type of objects whose values are all of the same type.
 * The `in` and `for-in` operators can *not* be safely used,
since `Object.prototype` may be modified by outside code.
*/
  declare export interface MapLike<T> {
    [index: string]: T;
  }
  declare export type SortedReadonlyArray<T> = {
    __sortedArrayBrand: any
  } & $ReadOnlyArray<T>;

  declare export type SortedArray<T> = {
    __sortedArrayBrand: any
  } & Array<T>;

  /**
   * ES6 Map interface, only read methods included.
   */
  declare export interface ReadonlyMap<T> {
    get(key: string): T | void;
    has(key: string): boolean;
    forEach(action: (value: T, key: string) => void): void;
    size: number;
    keys(): Iterator<string>;
    values(): Iterator<T>;
    entries(): Iterator<[string, T]>;
  }

  /**
   * ES6 Map interface.
   */
  declare export type Map<T> = {
    set(key: string, value: T): Map<T>,
    delete(key: string): boolean,
    clear(): void
  } & ReadonlyMap<T>;

  /**
   * ES6 Iterator type.
   */
  declare export interface Iterator<T> {
    next():
      | {
          value: T,
          done: false
        }
      | {
          value: empty,
          done: true
        };
  }

  /**
   * Array that is only intended to be pushed to, never read.
   */
  declare export interface Push<T> {
    push(...values: T[]): void;
  }
  declare export type Path = string & {
    __pathBrand: any
  };
  declare export interface TextRange {
    pos: number;
    end: number;
  }
  declare export type JsDocSyntaxKind =
    | SyntaxKind.EndOfFileToken
    | SyntaxKind.WhitespaceTrivia
    | SyntaxKind.AtToken
    | SyntaxKind.NewLineTrivia
    | SyntaxKind.AsteriskToken
    | SyntaxKind.OpenBraceToken
    | SyntaxKind.CloseBraceToken
    | SyntaxKind.LessThanToken
    | SyntaxKind.OpenBracketToken
    | SyntaxKind.CloseBracketToken
    | SyntaxKind.EqualsToken
    | SyntaxKind.CommaToken
    | SyntaxKind.DotToken
    | SyntaxKind.Identifier
    | SyntaxKind.NoSubstitutionTemplateLiteral
    | SyntaxKind.Unknown
    | KeywordSyntaxKind;
  declare export type KeywordSyntaxKind =
    | SyntaxKind.AbstractKeyword
    | SyntaxKind.AnyKeyword
    | SyntaxKind.AsKeyword
    | SyntaxKind.BigIntKeyword
    | SyntaxKind.BooleanKeyword
    | SyntaxKind.BreakKeyword
    | SyntaxKind.CaseKeyword
    | SyntaxKind.CatchKeyword
    | SyntaxKind.ClassKeyword
    | SyntaxKind.ContinueKeyword
    | SyntaxKind.ConstKeyword
    | SyntaxKind.ConstructorKeyword
    | SyntaxKind.DebuggerKeyword
    | SyntaxKind.DeclareKeyword
    | SyntaxKind.DefaultKeyword
    | SyntaxKind.DeleteKeyword
    | SyntaxKind.DoKeyword
    | SyntaxKind.ElseKeyword
    | SyntaxKind.EnumKeyword
    | SyntaxKind.ExportKeyword
    | SyntaxKind.ExtendsKeyword
    | SyntaxKind.FalseKeyword
    | SyntaxKind.FinallyKeyword
    | SyntaxKind.ForKeyword
    | SyntaxKind.FromKeyword
    | SyntaxKind.FunctionKeyword
    | SyntaxKind.GetKeyword
    | SyntaxKind.IfKeyword
    | SyntaxKind.ImplementsKeyword
    | SyntaxKind.ImportKeyword
    | SyntaxKind.InKeyword
    | SyntaxKind.InferKeyword
    | SyntaxKind.InstanceOfKeyword
    | SyntaxKind.InterfaceKeyword
    | SyntaxKind.IsKeyword
    | SyntaxKind.KeyOfKeyword
    | SyntaxKind.LetKeyword
    | SyntaxKind.ModuleKeyword
    | SyntaxKind.NamespaceKeyword
    | SyntaxKind.NeverKeyword
    | SyntaxKind.NewKeyword
    | SyntaxKind.NullKeyword
    | SyntaxKind.NumberKeyword
    | SyntaxKind.ObjectKeyword
    | SyntaxKind.PackageKeyword
    | SyntaxKind.PrivateKeyword
    | SyntaxKind.ProtectedKeyword
    | SyntaxKind.PublicKeyword
    | SyntaxKind.ReadonlyKeyword
    | SyntaxKind.RequireKeyword
    | SyntaxKind.GlobalKeyword
    | SyntaxKind.ReturnKeyword
    | SyntaxKind.SetKeyword
    | SyntaxKind.StaticKeyword
    | SyntaxKind.StringKeyword
    | SyntaxKind.SuperKeyword
    | SyntaxKind.SwitchKeyword
    | SyntaxKind.SymbolKeyword
    | SyntaxKind.ThisKeyword
    | SyntaxKind.ThrowKeyword
    | SyntaxKind.TrueKeyword
    | SyntaxKind.TryKeyword
    | SyntaxKind.TypeKeyword
    | SyntaxKind.TypeOfKeyword
    | SyntaxKind.UndefinedKeyword
    | SyntaxKind.UniqueKeyword
    | SyntaxKind.UnknownKeyword
    | SyntaxKind.VarKeyword
    | SyntaxKind.VoidKeyword
    | SyntaxKind.WhileKeyword
    | SyntaxKind.WithKeyword
    | SyntaxKind.YieldKeyword
    | SyntaxKind.AsyncKeyword
    | SyntaxKind.AwaitKeyword
    | SyntaxKind.OfKeyword;
  declare export type JsxTokenSyntaxKind =
    | SyntaxKind.LessThanSlashToken
    | SyntaxKind.EndOfFileToken
    | SyntaxKind.ConflictMarkerTrivia
    | SyntaxKind.JsxText
    | SyntaxKind.JsxTextAllWhiteSpaces
    | SyntaxKind.OpenBraceToken
    | SyntaxKind.LessThanToken;
  declare class SyntaxKind__Unknown mixins SyntaxKind {}
  declare class SyntaxKind__EndOfFileToken mixins SyntaxKind {}
  declare class SyntaxKind__SingleLineCommentTrivia mixins SyntaxKind {}
  declare class SyntaxKind__MultiLineCommentTrivia mixins SyntaxKind {}
  declare class SyntaxKind__NewLineTrivia mixins SyntaxKind {}
  declare class SyntaxKind__WhitespaceTrivia mixins SyntaxKind {}
  declare class SyntaxKind__ShebangTrivia mixins SyntaxKind {}
  declare class SyntaxKind__ConflictMarkerTrivia mixins SyntaxKind {}
  declare class SyntaxKind__NumericLiteral mixins SyntaxKind {}
  declare class SyntaxKind__BigIntLiteral mixins SyntaxKind {}
  declare class SyntaxKind__StringLiteral mixins SyntaxKind {}
  declare class SyntaxKind__JsxText mixins SyntaxKind {}
  declare class SyntaxKind__JsxTextAllWhiteSpaces mixins SyntaxKind {}
  declare class SyntaxKind__RegularExpressionLiteral mixins SyntaxKind {}
  declare class SyntaxKind__NoSubstitutionTemplateLiteral mixins SyntaxKind {}
  declare class SyntaxKind__TemplateHead mixins SyntaxKind {}
  declare class SyntaxKind__TemplateMiddle mixins SyntaxKind {}
  declare class SyntaxKind__TemplateTail mixins SyntaxKind {}
  declare class SyntaxKind__OpenBraceToken mixins SyntaxKind {}
  declare class SyntaxKind__CloseBraceToken mixins SyntaxKind {}
  declare class SyntaxKind__OpenParenToken mixins SyntaxKind {}
  declare class SyntaxKind__CloseParenToken mixins SyntaxKind {}
  declare class SyntaxKind__OpenBracketToken mixins SyntaxKind {}
  declare class SyntaxKind__CloseBracketToken mixins SyntaxKind {}
  declare class SyntaxKind__DotToken mixins SyntaxKind {}
  declare class SyntaxKind__DotDotDotToken mixins SyntaxKind {}
  declare class SyntaxKind__SemicolonToken mixins SyntaxKind {}
  declare class SyntaxKind__CommaToken mixins SyntaxKind {}
  declare class SyntaxKind__LessThanToken mixins SyntaxKind {}
  declare class SyntaxKind__LessThanSlashToken mixins SyntaxKind {}
  declare class SyntaxKind__GreaterThanToken mixins SyntaxKind {}
  declare class SyntaxKind__LessThanEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__GreaterThanEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__EqualsEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__ExclamationEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__EqualsEqualsEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__ExclamationEqualsEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__EqualsGreaterThanToken mixins SyntaxKind {}
  declare class SyntaxKind__PlusToken mixins SyntaxKind {}
  declare class SyntaxKind__MinusToken mixins SyntaxKind {}
  declare class SyntaxKind__AsteriskToken mixins SyntaxKind {}
  declare class SyntaxKind__AsteriskAsteriskToken mixins SyntaxKind {}
  declare class SyntaxKind__SlashToken mixins SyntaxKind {}
  declare class SyntaxKind__PercentToken mixins SyntaxKind {}
  declare class SyntaxKind__PlusPlusToken mixins SyntaxKind {}
  declare class SyntaxKind__MinusMinusToken mixins SyntaxKind {}
  declare class SyntaxKind__LessThanLessThanToken mixins SyntaxKind {}
  declare class SyntaxKind__GreaterThanGreaterThanToken mixins SyntaxKind {}
  declare class SyntaxKind__GreaterThanGreaterThanGreaterThanToken
    mixins SyntaxKind {}
  declare class SyntaxKind__AmpersandToken mixins SyntaxKind {}
  declare class SyntaxKind__BarToken mixins SyntaxKind {}
  declare class SyntaxKind__CaretToken mixins SyntaxKind {}
  declare class SyntaxKind__ExclamationToken mixins SyntaxKind {}
  declare class SyntaxKind__TildeToken mixins SyntaxKind {}
  declare class SyntaxKind__AmpersandAmpersandToken mixins SyntaxKind {}
  declare class SyntaxKind__BarBarToken mixins SyntaxKind {}
  declare class SyntaxKind__QuestionToken mixins SyntaxKind {}
  declare class SyntaxKind__ColonToken mixins SyntaxKind {}
  declare class SyntaxKind__AtToken mixins SyntaxKind {}
  declare class SyntaxKind__EqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__PlusEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__MinusEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__AsteriskEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__AsteriskAsteriskEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__SlashEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__PercentEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__LessThanLessThanEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__GreaterThanGreaterThanEqualsToken
    mixins SyntaxKind {}
  declare class SyntaxKind__GreaterThanGreaterThanGreaterThanEqualsToken
    mixins SyntaxKind {}
  declare class SyntaxKind__AmpersandEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__BarEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__CaretEqualsToken mixins SyntaxKind {}
  declare class SyntaxKind__Identifier mixins SyntaxKind {}
  declare class SyntaxKind__BreakKeyword mixins SyntaxKind {}
  declare class SyntaxKind__CaseKeyword mixins SyntaxKind {}
  declare class SyntaxKind__CatchKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ClassKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ConstKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ContinueKeyword mixins SyntaxKind {}
  declare class SyntaxKind__DebuggerKeyword mixins SyntaxKind {}
  declare class SyntaxKind__DefaultKeyword mixins SyntaxKind {}
  declare class SyntaxKind__DeleteKeyword mixins SyntaxKind {}
  declare class SyntaxKind__DoKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ElseKeyword mixins SyntaxKind {}
  declare class SyntaxKind__EnumKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ExportKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ExtendsKeyword mixins SyntaxKind {}
  declare class SyntaxKind__FalseKeyword mixins SyntaxKind {}
  declare class SyntaxKind__FinallyKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ForKeyword mixins SyntaxKind {}
  declare class SyntaxKind__FunctionKeyword mixins SyntaxKind {}
  declare class SyntaxKind__IfKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ImportKeyword mixins SyntaxKind {}
  declare class SyntaxKind__InKeyword mixins SyntaxKind {}
  declare class SyntaxKind__InstanceOfKeyword mixins SyntaxKind {}
  declare class SyntaxKind__NewKeyword mixins SyntaxKind {}
  declare class SyntaxKind__NullKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ReturnKeyword mixins SyntaxKind {}
  declare class SyntaxKind__SuperKeyword mixins SyntaxKind {}
  declare class SyntaxKind__SwitchKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ThisKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ThrowKeyword mixins SyntaxKind {}
  declare class SyntaxKind__TrueKeyword mixins SyntaxKind {}
  declare class SyntaxKind__TryKeyword mixins SyntaxKind {}
  declare class SyntaxKind__TypeOfKeyword mixins SyntaxKind {}
  declare class SyntaxKind__VarKeyword mixins SyntaxKind {}
  declare class SyntaxKind__VoidKeyword mixins SyntaxKind {}
  declare class SyntaxKind__WhileKeyword mixins SyntaxKind {}
  declare class SyntaxKind__WithKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ImplementsKeyword mixins SyntaxKind {}
  declare class SyntaxKind__InterfaceKeyword mixins SyntaxKind {}
  declare class SyntaxKind__LetKeyword mixins SyntaxKind {}
  declare class SyntaxKind__PackageKeyword mixins SyntaxKind {}
  declare class SyntaxKind__PrivateKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ProtectedKeyword mixins SyntaxKind {}
  declare class SyntaxKind__PublicKeyword mixins SyntaxKind {}
  declare class SyntaxKind__StaticKeyword mixins SyntaxKind {}
  declare class SyntaxKind__YieldKeyword mixins SyntaxKind {}
  declare class SyntaxKind__AbstractKeyword mixins SyntaxKind {}
  declare class SyntaxKind__AsKeyword mixins SyntaxKind {}
  declare class SyntaxKind__AnyKeyword mixins SyntaxKind {}
  declare class SyntaxKind__AsyncKeyword mixins SyntaxKind {}
  declare class SyntaxKind__AwaitKeyword mixins SyntaxKind {}
  declare class SyntaxKind__BooleanKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ConstructorKeyword mixins SyntaxKind {}
  declare class SyntaxKind__DeclareKeyword mixins SyntaxKind {}
  declare class SyntaxKind__GetKeyword mixins SyntaxKind {}
  declare class SyntaxKind__InferKeyword mixins SyntaxKind {}
  declare class SyntaxKind__IsKeyword mixins SyntaxKind {}
  declare class SyntaxKind__KeyOfKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ModuleKeyword mixins SyntaxKind {}
  declare class SyntaxKind__NamespaceKeyword mixins SyntaxKind {}
  declare class SyntaxKind__NeverKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ReadonlyKeyword mixins SyntaxKind {}
  declare class SyntaxKind__RequireKeyword mixins SyntaxKind {}
  declare class SyntaxKind__NumberKeyword mixins SyntaxKind {}
  declare class SyntaxKind__ObjectKeyword mixins SyntaxKind {}
  declare class SyntaxKind__SetKeyword mixins SyntaxKind {}
  declare class SyntaxKind__StringKeyword mixins SyntaxKind {}
  declare class SyntaxKind__SymbolKeyword mixins SyntaxKind {}
  declare class SyntaxKind__TypeKeyword mixins SyntaxKind {}
  declare class SyntaxKind__UndefinedKeyword mixins SyntaxKind {}
  declare class SyntaxKind__UniqueKeyword mixins SyntaxKind {}
  declare class SyntaxKind__UnknownKeyword mixins SyntaxKind {}
  declare class SyntaxKind__FromKeyword mixins SyntaxKind {}
  declare class SyntaxKind__GlobalKeyword mixins SyntaxKind {}
  declare class SyntaxKind__BigIntKeyword mixins SyntaxKind {}
  declare class SyntaxKind__OfKeyword mixins SyntaxKind {}
  declare class SyntaxKind__QualifiedName mixins SyntaxKind {}
  declare class SyntaxKind__ComputedPropertyName mixins SyntaxKind {}
  declare class SyntaxKind__TypeParameter mixins SyntaxKind {}
  declare class SyntaxKind__Parameter mixins SyntaxKind {}
  declare class SyntaxKind__Decorator mixins SyntaxKind {}
  declare class SyntaxKind__PropertySignature mixins SyntaxKind {}
  declare class SyntaxKind__PropertyDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__MethodSignature mixins SyntaxKind {}
  declare class SyntaxKind__MethodDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__Constructor mixins SyntaxKind {}
  declare class SyntaxKind__GetAccessor mixins SyntaxKind {}
  declare class SyntaxKind__SetAccessor mixins SyntaxKind {}
  declare class SyntaxKind__CallSignature mixins SyntaxKind {}
  declare class SyntaxKind__ConstructSignature mixins SyntaxKind {}
  declare class SyntaxKind__IndexSignature mixins SyntaxKind {}
  declare class SyntaxKind__TypePredicate mixins SyntaxKind {}
  declare class SyntaxKind__TypeReference mixins SyntaxKind {}
  declare class SyntaxKind__FunctionType mixins SyntaxKind {}
  declare class SyntaxKind__ConstructorType mixins SyntaxKind {}
  declare class SyntaxKind__TypeQuery mixins SyntaxKind {}
  declare class SyntaxKind__TypeLiteral mixins SyntaxKind {}
  declare class SyntaxKind__ArrayType mixins SyntaxKind {}
  declare class SyntaxKind__TupleType mixins SyntaxKind {}
  declare class SyntaxKind__OptionalType mixins SyntaxKind {}
  declare class SyntaxKind__RestType mixins SyntaxKind {}
  declare class SyntaxKind__UnionType mixins SyntaxKind {}
  declare class SyntaxKind__IntersectionType mixins SyntaxKind {}
  declare class SyntaxKind__ConditionalType mixins SyntaxKind {}
  declare class SyntaxKind__InferType mixins SyntaxKind {}
  declare class SyntaxKind__ParenthesizedType mixins SyntaxKind {}
  declare class SyntaxKind__ThisType mixins SyntaxKind {}
  declare class SyntaxKind__TypeOperator mixins SyntaxKind {}
  declare class SyntaxKind__IndexedAccessType mixins SyntaxKind {}
  declare class SyntaxKind__MappedType mixins SyntaxKind {}
  declare class SyntaxKind__LiteralType mixins SyntaxKind {}
  declare class SyntaxKind__ImportType mixins SyntaxKind {}
  declare class SyntaxKind__ObjectBindingPattern mixins SyntaxKind {}
  declare class SyntaxKind__ArrayBindingPattern mixins SyntaxKind {}
  declare class SyntaxKind__BindingElement mixins SyntaxKind {}
  declare class SyntaxKind__ArrayLiteralExpression mixins SyntaxKind {}
  declare class SyntaxKind__ObjectLiteralExpression mixins SyntaxKind {}
  declare class SyntaxKind__PropertyAccessExpression mixins SyntaxKind {}
  declare class SyntaxKind__ElementAccessExpression mixins SyntaxKind {}
  declare class SyntaxKind__CallExpression mixins SyntaxKind {}
  declare class SyntaxKind__NewExpression mixins SyntaxKind {}
  declare class SyntaxKind__TaggedTemplateExpression mixins SyntaxKind {}
  declare class SyntaxKind__TypeAssertionExpression mixins SyntaxKind {}
  declare class SyntaxKind__ParenthesizedExpression mixins SyntaxKind {}
  declare class SyntaxKind__FunctionExpression mixins SyntaxKind {}
  declare class SyntaxKind__ArrowFunction mixins SyntaxKind {}
  declare class SyntaxKind__DeleteExpression mixins SyntaxKind {}
  declare class SyntaxKind__TypeOfExpression mixins SyntaxKind {}
  declare class SyntaxKind__VoidExpression mixins SyntaxKind {}
  declare class SyntaxKind__AwaitExpression mixins SyntaxKind {}
  declare class SyntaxKind__PrefixUnaryExpression mixins SyntaxKind {}
  declare class SyntaxKind__PostfixUnaryExpression mixins SyntaxKind {}
  declare class SyntaxKind__BinaryExpression mixins SyntaxKind {}
  declare class SyntaxKind__ConditionalExpression mixins SyntaxKind {}
  declare class SyntaxKind__TemplateExpression mixins SyntaxKind {}
  declare class SyntaxKind__YieldExpression mixins SyntaxKind {}
  declare class SyntaxKind__SpreadElement mixins SyntaxKind {}
  declare class SyntaxKind__ClassExpression mixins SyntaxKind {}
  declare class SyntaxKind__OmittedExpression mixins SyntaxKind {}
  declare class SyntaxKind__ExpressionWithTypeArguments mixins SyntaxKind {}
  declare class SyntaxKind__AsExpression mixins SyntaxKind {}
  declare class SyntaxKind__NonNullExpression mixins SyntaxKind {}
  declare class SyntaxKind__MetaProperty mixins SyntaxKind {}
  declare class SyntaxKind__SyntheticExpression mixins SyntaxKind {}
  declare class SyntaxKind__TemplateSpan mixins SyntaxKind {}
  declare class SyntaxKind__SemicolonClassElement mixins SyntaxKind {}
  declare class SyntaxKind__Block mixins SyntaxKind {}
  declare class SyntaxKind__VariableStatement mixins SyntaxKind {}
  declare class SyntaxKind__EmptyStatement mixins SyntaxKind {}
  declare class SyntaxKind__ExpressionStatement mixins SyntaxKind {}
  declare class SyntaxKind__IfStatement mixins SyntaxKind {}
  declare class SyntaxKind__DoStatement mixins SyntaxKind {}
  declare class SyntaxKind__WhileStatement mixins SyntaxKind {}
  declare class SyntaxKind__ForStatement mixins SyntaxKind {}
  declare class SyntaxKind__ForInStatement mixins SyntaxKind {}
  declare class SyntaxKind__ForOfStatement mixins SyntaxKind {}
  declare class SyntaxKind__ContinueStatement mixins SyntaxKind {}
  declare class SyntaxKind__BreakStatement mixins SyntaxKind {}
  declare class SyntaxKind__ReturnStatement mixins SyntaxKind {}
  declare class SyntaxKind__WithStatement mixins SyntaxKind {}
  declare class SyntaxKind__SwitchStatement mixins SyntaxKind {}
  declare class SyntaxKind__LabeledStatement mixins SyntaxKind {}
  declare class SyntaxKind__ThrowStatement mixins SyntaxKind {}
  declare class SyntaxKind__TryStatement mixins SyntaxKind {}
  declare class SyntaxKind__DebuggerStatement mixins SyntaxKind {}
  declare class SyntaxKind__VariableDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__VariableDeclarationList mixins SyntaxKind {}
  declare class SyntaxKind__FunctionDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__ClassDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__InterfaceDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__TypeAliasDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__EnumDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__ModuleDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__ModuleBlock mixins SyntaxKind {}
  declare class SyntaxKind__CaseBlock mixins SyntaxKind {}
  declare class SyntaxKind__NamespaceExportDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__ImportEqualsDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__ImportDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__ImportClause mixins SyntaxKind {}
  declare class SyntaxKind__NamespaceImport mixins SyntaxKind {}
  declare class SyntaxKind__NamedImports mixins SyntaxKind {}
  declare class SyntaxKind__ImportSpecifier mixins SyntaxKind {}
  declare class SyntaxKind__ExportAssignment mixins SyntaxKind {}
  declare class SyntaxKind__ExportDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__NamedExports mixins SyntaxKind {}
  declare class SyntaxKind__ExportSpecifier mixins SyntaxKind {}
  declare class SyntaxKind__MissingDeclaration mixins SyntaxKind {}
  declare class SyntaxKind__ExternalModuleReference mixins SyntaxKind {}
  declare class SyntaxKind__JsxElement mixins SyntaxKind {}
  declare class SyntaxKind__JsxSelfClosingElement mixins SyntaxKind {}
  declare class SyntaxKind__JsxOpeningElement mixins SyntaxKind {}
  declare class SyntaxKind__JsxClosingElement mixins SyntaxKind {}
  declare class SyntaxKind__JsxFragment mixins SyntaxKind {}
  declare class SyntaxKind__JsxOpeningFragment mixins SyntaxKind {}
  declare class SyntaxKind__JsxClosingFragment mixins SyntaxKind {}
  declare class SyntaxKind__JsxAttribute mixins SyntaxKind {}
  declare class SyntaxKind__JsxAttributes mixins SyntaxKind {}
  declare class SyntaxKind__JsxSpreadAttribute mixins SyntaxKind {}
  declare class SyntaxKind__JsxExpression mixins SyntaxKind {}
  declare class SyntaxKind__CaseClause mixins SyntaxKind {}
  declare class SyntaxKind__DefaultClause mixins SyntaxKind {}
  declare class SyntaxKind__HeritageClause mixins SyntaxKind {}
  declare class SyntaxKind__CatchClause mixins SyntaxKind {}
  declare class SyntaxKind__PropertyAssignment mixins SyntaxKind {}
  declare class SyntaxKind__ShorthandPropertyAssignment mixins SyntaxKind {}
  declare class SyntaxKind__SpreadAssignment mixins SyntaxKind {}
  declare class SyntaxKind__EnumMember mixins SyntaxKind {}
  declare class SyntaxKind__SourceFile mixins SyntaxKind {}
  declare class SyntaxKind__Bundle mixins SyntaxKind {}
  declare class SyntaxKind__UnparsedSource mixins SyntaxKind {}
  declare class SyntaxKind__InputFiles mixins SyntaxKind {}
  declare class SyntaxKind__JSDocTypeExpression mixins SyntaxKind {}
  declare class SyntaxKind__JSDocAllType mixins SyntaxKind {}
  declare class SyntaxKind__JSDocUnknownType mixins SyntaxKind {}
  declare class SyntaxKind__JSDocNullableType mixins SyntaxKind {}
  declare class SyntaxKind__JSDocNonNullableType mixins SyntaxKind {}
  declare class SyntaxKind__JSDocOptionalType mixins SyntaxKind {}
  declare class SyntaxKind__JSDocFunctionType mixins SyntaxKind {}
  declare class SyntaxKind__JSDocVariadicType mixins SyntaxKind {}
  declare class SyntaxKind__JSDocComment mixins SyntaxKind {}
  declare class SyntaxKind__JSDocTypeLiteral mixins SyntaxKind {}
  declare class SyntaxKind__JSDocSignature mixins SyntaxKind {}
  declare class SyntaxKind__JSDocTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocAugmentsTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocClassTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocCallbackTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocEnumTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocParameterTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocReturnTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocThisTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocTypeTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocTemplateTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocTypedefTag mixins SyntaxKind {}
  declare class SyntaxKind__JSDocPropertyTag mixins SyntaxKind {}
  declare class SyntaxKind__SyntaxList mixins SyntaxKind {}
  declare class SyntaxKind__NotEmittedStatement mixins SyntaxKind {}
  declare class SyntaxKind__PartiallyEmittedExpression mixins SyntaxKind {}
  declare class SyntaxKind__CommaListExpression mixins SyntaxKind {}
  declare class SyntaxKind__MergeDeclarationMarker mixins SyntaxKind {}
  declare class SyntaxKind__EndOfDeclarationMarker mixins SyntaxKind {}
  declare class SyntaxKind__Count mixins SyntaxKind {}
  declare class SyntaxKind__FirstAssignment mixins SyntaxKind {}
  declare class SyntaxKind__LastAssignment mixins SyntaxKind {}
  declare class SyntaxKind__FirstCompoundAssignment mixins SyntaxKind {}
  declare class SyntaxKind__LastCompoundAssignment mixins SyntaxKind {}
  declare class SyntaxKind__FirstReservedWord mixins SyntaxKind {}
  declare class SyntaxKind__LastReservedWord mixins SyntaxKind {}
  declare class SyntaxKind__FirstKeyword mixins SyntaxKind {}
  declare class SyntaxKind__LastKeyword mixins SyntaxKind {}
  declare class SyntaxKind__FirstFutureReservedWord mixins SyntaxKind {}
  declare class SyntaxKind__LastFutureReservedWord mixins SyntaxKind {}
  declare class SyntaxKind__FirstTypeNode mixins SyntaxKind {}
  declare class SyntaxKind__LastTypeNode mixins SyntaxKind {}
  declare class SyntaxKind__FirstPunctuation mixins SyntaxKind {}
  declare class SyntaxKind__LastPunctuation mixins SyntaxKind {}
  declare class SyntaxKind__FirstToken mixins SyntaxKind {}
  declare class SyntaxKind__LastToken mixins SyntaxKind {}
  declare class SyntaxKind__FirstTriviaToken mixins SyntaxKind {}
  declare class SyntaxKind__LastTriviaToken mixins SyntaxKind {}
  declare class SyntaxKind__FirstLiteralToken mixins SyntaxKind {}
  declare class SyntaxKind__LastLiteralToken mixins SyntaxKind {}
  declare class SyntaxKind__FirstTemplateToken mixins SyntaxKind {}
  declare class SyntaxKind__LastTemplateToken mixins SyntaxKind {}
  declare class SyntaxKind__FirstBinaryOperator mixins SyntaxKind {}
  declare class SyntaxKind__LastBinaryOperator mixins SyntaxKind {}
  declare class SyntaxKind__FirstNode mixins SyntaxKind {}
  declare class SyntaxKind__FirstJSDocNode mixins SyntaxKind {}
  declare class SyntaxKind__LastJSDocNode mixins SyntaxKind {}
  declare class SyntaxKind__FirstJSDocTagNode mixins SyntaxKind {}
  declare class SyntaxKind__LastJSDocTagNode mixins SyntaxKind {}

  declare export class SyntaxKind {
    constructor(...args: empty): mixed;
    static Unknown: Class<SyntaxKind__Unknown> & SyntaxKind__Unknown & 0; // 0
    static EndOfFileToken: Class<SyntaxKind__EndOfFileToken> &
      SyntaxKind__EndOfFileToken &
      1; // 1
    static SingleLineCommentTrivia: Class<SyntaxKind__SingleLineCommentTrivia> &
      SyntaxKind__SingleLineCommentTrivia &
      2; // 2
    static MultiLineCommentTrivia: Class<SyntaxKind__MultiLineCommentTrivia> &
      SyntaxKind__MultiLineCommentTrivia &
      3; // 3
    static NewLineTrivia: Class<SyntaxKind__NewLineTrivia> &
      SyntaxKind__NewLineTrivia &
      4; // 4
    static WhitespaceTrivia: Class<SyntaxKind__WhitespaceTrivia> &
      SyntaxKind__WhitespaceTrivia &
      5; // 5
    static ShebangTrivia: Class<SyntaxKind__ShebangTrivia> &
      SyntaxKind__ShebangTrivia &
      6; // 6
    static ConflictMarkerTrivia: Class<SyntaxKind__ConflictMarkerTrivia> &
      SyntaxKind__ConflictMarkerTrivia &
      7; // 7
    static NumericLiteral: Class<SyntaxKind__NumericLiteral> &
      SyntaxKind__NumericLiteral &
      8; // 8
    static BigIntLiteral: Class<SyntaxKind__BigIntLiteral> &
      SyntaxKind__BigIntLiteral &
      9; // 9
    static StringLiteral: Class<SyntaxKind__StringLiteral> &
      SyntaxKind__StringLiteral &
      10; // 10
    static JsxText: Class<SyntaxKind__JsxText> & SyntaxKind__JsxText & 11; // 11
    static JsxTextAllWhiteSpaces: Class<SyntaxKind__JsxTextAllWhiteSpaces> &
      SyntaxKind__JsxTextAllWhiteSpaces &
      12; // 12
    static RegularExpressionLiteral: Class<SyntaxKind__RegularExpressionLiteral> &
      SyntaxKind__RegularExpressionLiteral &
      13; // 13
    static NoSubstitutionTemplateLiteral: Class<SyntaxKind__NoSubstitutionTemplateLiteral> &
      SyntaxKind__NoSubstitutionTemplateLiteral &
      14; // 14
    static TemplateHead: Class<SyntaxKind__TemplateHead> &
      SyntaxKind__TemplateHead &
      15; // 15
    static TemplateMiddle: Class<SyntaxKind__TemplateMiddle> &
      SyntaxKind__TemplateMiddle &
      16; // 16
    static TemplateTail: Class<SyntaxKind__TemplateTail> &
      SyntaxKind__TemplateTail &
      17; // 17
    static OpenBraceToken: Class<SyntaxKind__OpenBraceToken> &
      SyntaxKind__OpenBraceToken &
      18; // 18
    static CloseBraceToken: Class<SyntaxKind__CloseBraceToken> &
      SyntaxKind__CloseBraceToken &
      19; // 19
    static OpenParenToken: Class<SyntaxKind__OpenParenToken> &
      SyntaxKind__OpenParenToken &
      20; // 20
    static CloseParenToken: Class<SyntaxKind__CloseParenToken> &
      SyntaxKind__CloseParenToken &
      21; // 21
    static OpenBracketToken: Class<SyntaxKind__OpenBracketToken> &
      SyntaxKind__OpenBracketToken &
      22; // 22
    static CloseBracketToken: Class<SyntaxKind__CloseBracketToken> &
      SyntaxKind__CloseBracketToken &
      23; // 23
    static DotToken: Class<SyntaxKind__DotToken> & SyntaxKind__DotToken & 24; // 24
    static DotDotDotToken: Class<SyntaxKind__DotDotDotToken> &
      SyntaxKind__DotDotDotToken &
      25; // 25
    static SemicolonToken: Class<SyntaxKind__SemicolonToken> &
      SyntaxKind__SemicolonToken &
      26; // 26
    static CommaToken: Class<SyntaxKind__CommaToken> &
      SyntaxKind__CommaToken &
      27; // 27
    static LessThanToken: Class<SyntaxKind__LessThanToken> &
      SyntaxKind__LessThanToken &
      28; // 28
    static LessThanSlashToken: Class<SyntaxKind__LessThanSlashToken> &
      SyntaxKind__LessThanSlashToken &
      29; // 29
    static GreaterThanToken: Class<SyntaxKind__GreaterThanToken> &
      SyntaxKind__GreaterThanToken &
      30; // 30
    static LessThanEqualsToken: Class<SyntaxKind__LessThanEqualsToken> &
      SyntaxKind__LessThanEqualsToken &
      31; // 31
    static GreaterThanEqualsToken: Class<SyntaxKind__GreaterThanEqualsToken> &
      SyntaxKind__GreaterThanEqualsToken &
      32; // 32
    static EqualsEqualsToken: Class<SyntaxKind__EqualsEqualsToken> &
      SyntaxKind__EqualsEqualsToken &
      33; // 33
    static ExclamationEqualsToken: Class<SyntaxKind__ExclamationEqualsToken> &
      SyntaxKind__ExclamationEqualsToken &
      34; // 34
    static EqualsEqualsEqualsToken: Class<SyntaxKind__EqualsEqualsEqualsToken> &
      SyntaxKind__EqualsEqualsEqualsToken &
      35; // 35
    static ExclamationEqualsEqualsToken: Class<SyntaxKind__ExclamationEqualsEqualsToken> &
      SyntaxKind__ExclamationEqualsEqualsToken &
      36; // 36
    static EqualsGreaterThanToken: Class<SyntaxKind__EqualsGreaterThanToken> &
      SyntaxKind__EqualsGreaterThanToken &
      37; // 37
    static PlusToken: Class<SyntaxKind__PlusToken> & SyntaxKind__PlusToken & 38; // 38
    static MinusToken: Class<SyntaxKind__MinusToken> &
      SyntaxKind__MinusToken &
      39; // 39
    static AsteriskToken: Class<SyntaxKind__AsteriskToken> &
      SyntaxKind__AsteriskToken &
      40; // 40
    static AsteriskAsteriskToken: Class<SyntaxKind__AsteriskAsteriskToken> &
      SyntaxKind__AsteriskAsteriskToken &
      41; // 41
    static SlashToken: Class<SyntaxKind__SlashToken> &
      SyntaxKind__SlashToken &
      42; // 42
    static PercentToken: Class<SyntaxKind__PercentToken> &
      SyntaxKind__PercentToken &
      43; // 43
    static PlusPlusToken: Class<SyntaxKind__PlusPlusToken> &
      SyntaxKind__PlusPlusToken &
      44; // 44
    static MinusMinusToken: Class<SyntaxKind__MinusMinusToken> &
      SyntaxKind__MinusMinusToken &
      45; // 45
    static LessThanLessThanToken: Class<SyntaxKind__LessThanLessThanToken> &
      SyntaxKind__LessThanLessThanToken &
      46; // 46
    static GreaterThanGreaterThanToken: Class<SyntaxKind__GreaterThanGreaterThanToken> &
      SyntaxKind__GreaterThanGreaterThanToken &
      47; // 47
    static GreaterThanGreaterThanGreaterThanToken: Class<SyntaxKind__GreaterThanGreaterThanGreaterThanToken> &
      SyntaxKind__GreaterThanGreaterThanGreaterThanToken &
      48; // 48
    static AmpersandToken: Class<SyntaxKind__AmpersandToken> &
      SyntaxKind__AmpersandToken &
      49; // 49
    static BarToken: Class<SyntaxKind__BarToken> & SyntaxKind__BarToken & 50; // 50
    static CaretToken: Class<SyntaxKind__CaretToken> &
      SyntaxKind__CaretToken &
      51; // 51
    static ExclamationToken: Class<SyntaxKind__ExclamationToken> &
      SyntaxKind__ExclamationToken &
      52; // 52
    static TildeToken: Class<SyntaxKind__TildeToken> &
      SyntaxKind__TildeToken &
      53; // 53
    static AmpersandAmpersandToken: Class<SyntaxKind__AmpersandAmpersandToken> &
      SyntaxKind__AmpersandAmpersandToken &
      54; // 54
    static BarBarToken: Class<SyntaxKind__BarBarToken> &
      SyntaxKind__BarBarToken &
      55; // 55
    static QuestionToken: Class<SyntaxKind__QuestionToken> &
      SyntaxKind__QuestionToken &
      56; // 56
    static ColonToken: Class<SyntaxKind__ColonToken> &
      SyntaxKind__ColonToken &
      57; // 57
    static AtToken: Class<SyntaxKind__AtToken> & SyntaxKind__AtToken & 58; // 58
    static EqualsToken: Class<SyntaxKind__EqualsToken> &
      SyntaxKind__EqualsToken &
      59; // 59
    static PlusEqualsToken: Class<SyntaxKind__PlusEqualsToken> &
      SyntaxKind__PlusEqualsToken &
      60; // 60
    static MinusEqualsToken: Class<SyntaxKind__MinusEqualsToken> &
      SyntaxKind__MinusEqualsToken &
      61; // 61
    static AsteriskEqualsToken: Class<SyntaxKind__AsteriskEqualsToken> &
      SyntaxKind__AsteriskEqualsToken &
      62; // 62
    static AsteriskAsteriskEqualsToken: Class<SyntaxKind__AsteriskAsteriskEqualsToken> &
      SyntaxKind__AsteriskAsteriskEqualsToken &
      63; // 63
    static SlashEqualsToken: Class<SyntaxKind__SlashEqualsToken> &
      SyntaxKind__SlashEqualsToken &
      64; // 64
    static PercentEqualsToken: Class<SyntaxKind__PercentEqualsToken> &
      SyntaxKind__PercentEqualsToken &
      65; // 65
    static LessThanLessThanEqualsToken: Class<SyntaxKind__LessThanLessThanEqualsToken> &
      SyntaxKind__LessThanLessThanEqualsToken &
      66; // 66
    static GreaterThanGreaterThanEqualsToken: Class<SyntaxKind__GreaterThanGreaterThanEqualsToken> &
      SyntaxKind__GreaterThanGreaterThanEqualsToken &
      67; // 67
    static GreaterThanGreaterThanGreaterThanEqualsToken: Class<SyntaxKind__GreaterThanGreaterThanGreaterThanEqualsToken> &
      SyntaxKind__GreaterThanGreaterThanGreaterThanEqualsToken &
      68; // 68
    static AmpersandEqualsToken: Class<SyntaxKind__AmpersandEqualsToken> &
      SyntaxKind__AmpersandEqualsToken &
      69; // 69
    static BarEqualsToken: Class<SyntaxKind__BarEqualsToken> &
      SyntaxKind__BarEqualsToken &
      70; // 70
    static CaretEqualsToken: Class<SyntaxKind__CaretEqualsToken> &
      SyntaxKind__CaretEqualsToken &
      71; // 71
    static Identifier: Class<SyntaxKind__Identifier> &
      SyntaxKind__Identifier &
      72; // 72
    static BreakKeyword: Class<SyntaxKind__BreakKeyword> &
      SyntaxKind__BreakKeyword &
      73; // 73
    static CaseKeyword: Class<SyntaxKind__CaseKeyword> &
      SyntaxKind__CaseKeyword &
      74; // 74
    static CatchKeyword: Class<SyntaxKind__CatchKeyword> &
      SyntaxKind__CatchKeyword &
      75; // 75
    static ClassKeyword: Class<SyntaxKind__ClassKeyword> &
      SyntaxKind__ClassKeyword &
      76; // 76
    static ConstKeyword: Class<SyntaxKind__ConstKeyword> &
      SyntaxKind__ConstKeyword &
      77; // 77
    static ContinueKeyword: Class<SyntaxKind__ContinueKeyword> &
      SyntaxKind__ContinueKeyword &
      78; // 78
    static DebuggerKeyword: Class<SyntaxKind__DebuggerKeyword> &
      SyntaxKind__DebuggerKeyword &
      79; // 79
    static DefaultKeyword: Class<SyntaxKind__DefaultKeyword> &
      SyntaxKind__DefaultKeyword &
      80; // 80
    static DeleteKeyword: Class<SyntaxKind__DeleteKeyword> &
      SyntaxKind__DeleteKeyword &
      81; // 81
    static DoKeyword: Class<SyntaxKind__DoKeyword> & SyntaxKind__DoKeyword & 82; // 82
    static ElseKeyword: Class<SyntaxKind__ElseKeyword> &
      SyntaxKind__ElseKeyword &
      83; // 83
    static EnumKeyword: Class<SyntaxKind__EnumKeyword> &
      SyntaxKind__EnumKeyword &
      84; // 84
    static ExportKeyword: Class<SyntaxKind__ExportKeyword> &
      SyntaxKind__ExportKeyword &
      85; // 85
    static ExtendsKeyword: Class<SyntaxKind__ExtendsKeyword> &
      SyntaxKind__ExtendsKeyword &
      86; // 86
    static FalseKeyword: Class<SyntaxKind__FalseKeyword> &
      SyntaxKind__FalseKeyword &
      87; // 87
    static FinallyKeyword: Class<SyntaxKind__FinallyKeyword> &
      SyntaxKind__FinallyKeyword &
      88; // 88
    static ForKeyword: Class<SyntaxKind__ForKeyword> &
      SyntaxKind__ForKeyword &
      89; // 89
    static FunctionKeyword: Class<SyntaxKind__FunctionKeyword> &
      SyntaxKind__FunctionKeyword &
      90; // 90
    static IfKeyword: Class<SyntaxKind__IfKeyword> & SyntaxKind__IfKeyword & 91; // 91
    static ImportKeyword: Class<SyntaxKind__ImportKeyword> &
      SyntaxKind__ImportKeyword &
      92; // 92
    static InKeyword: Class<SyntaxKind__InKeyword> & SyntaxKind__InKeyword & 93; // 93
    static InstanceOfKeyword: Class<SyntaxKind__InstanceOfKeyword> &
      SyntaxKind__InstanceOfKeyword &
      94; // 94
    static NewKeyword: Class<SyntaxKind__NewKeyword> &
      SyntaxKind__NewKeyword &
      95; // 95
    static NullKeyword: Class<SyntaxKind__NullKeyword> &
      SyntaxKind__NullKeyword &
      96; // 96
    static ReturnKeyword: Class<SyntaxKind__ReturnKeyword> &
      SyntaxKind__ReturnKeyword &
      97; // 97
    static SuperKeyword: Class<SyntaxKind__SuperKeyword> &
      SyntaxKind__SuperKeyword &
      98; // 98
    static SwitchKeyword: Class<SyntaxKind__SwitchKeyword> &
      SyntaxKind__SwitchKeyword &
      99; // 99
    static ThisKeyword: Class<SyntaxKind__ThisKeyword> &
      SyntaxKind__ThisKeyword &
      100; // 100
    static ThrowKeyword: Class<SyntaxKind__ThrowKeyword> &
      SyntaxKind__ThrowKeyword &
      101; // 101
    static TrueKeyword: Class<SyntaxKind__TrueKeyword> &
      SyntaxKind__TrueKeyword &
      102; // 102
    static TryKeyword: Class<SyntaxKind__TryKeyword> &
      SyntaxKind__TryKeyword &
      103; // 103
    static TypeOfKeyword: Class<SyntaxKind__TypeOfKeyword> &
      SyntaxKind__TypeOfKeyword &
      104; // 104
    static VarKeyword: Class<SyntaxKind__VarKeyword> &
      SyntaxKind__VarKeyword &
      105; // 105
    static VoidKeyword: Class<SyntaxKind__VoidKeyword> &
      SyntaxKind__VoidKeyword &
      106; // 106
    static WhileKeyword: Class<SyntaxKind__WhileKeyword> &
      SyntaxKind__WhileKeyword &
      107; // 107
    static WithKeyword: Class<SyntaxKind__WithKeyword> &
      SyntaxKind__WithKeyword &
      108; // 108
    static ImplementsKeyword: Class<SyntaxKind__ImplementsKeyword> &
      SyntaxKind__ImplementsKeyword &
      109; // 109
    static InterfaceKeyword: Class<SyntaxKind__InterfaceKeyword> &
      SyntaxKind__InterfaceKeyword &
      110; // 110
    static LetKeyword: Class<SyntaxKind__LetKeyword> &
      SyntaxKind__LetKeyword &
      111; // 111
    static PackageKeyword: Class<SyntaxKind__PackageKeyword> &
      SyntaxKind__PackageKeyword &
      112; // 112
    static PrivateKeyword: Class<SyntaxKind__PrivateKeyword> &
      SyntaxKind__PrivateKeyword &
      113; // 113
    static ProtectedKeyword: Class<SyntaxKind__ProtectedKeyword> &
      SyntaxKind__ProtectedKeyword &
      114; // 114
    static PublicKeyword: Class<SyntaxKind__PublicKeyword> &
      SyntaxKind__PublicKeyword &
      115; // 115
    static StaticKeyword: Class<SyntaxKind__StaticKeyword> &
      SyntaxKind__StaticKeyword &
      116; // 116
    static YieldKeyword: Class<SyntaxKind__YieldKeyword> &
      SyntaxKind__YieldKeyword &
      117; // 117
    static AbstractKeyword: Class<SyntaxKind__AbstractKeyword> &
      SyntaxKind__AbstractKeyword &
      118; // 118
    static AsKeyword: Class<SyntaxKind__AsKeyword> &
      SyntaxKind__AsKeyword &
      119; // 119
    static AnyKeyword: Class<SyntaxKind__AnyKeyword> &
      SyntaxKind__AnyKeyword &
      120; // 120
    static AsyncKeyword: Class<SyntaxKind__AsyncKeyword> &
      SyntaxKind__AsyncKeyword &
      121; // 121
    static AwaitKeyword: Class<SyntaxKind__AwaitKeyword> &
      SyntaxKind__AwaitKeyword &
      122; // 122
    static BooleanKeyword: Class<SyntaxKind__BooleanKeyword> &
      SyntaxKind__BooleanKeyword &
      123; // 123
    static ConstructorKeyword: Class<SyntaxKind__ConstructorKeyword> &
      SyntaxKind__ConstructorKeyword &
      124; // 124
    static DeclareKeyword: Class<SyntaxKind__DeclareKeyword> &
      SyntaxKind__DeclareKeyword &
      125; // 125
    static GetKeyword: Class<SyntaxKind__GetKeyword> &
      SyntaxKind__GetKeyword &
      126; // 126
    static InferKeyword: Class<SyntaxKind__InferKeyword> &
      SyntaxKind__InferKeyword &
      127; // 127
    static IsKeyword: Class<SyntaxKind__IsKeyword> &
      SyntaxKind__IsKeyword &
      128; // 128
    static KeyOfKeyword: Class<SyntaxKind__KeyOfKeyword> &
      SyntaxKind__KeyOfKeyword &
      129; // 129
    static ModuleKeyword: Class<SyntaxKind__ModuleKeyword> &
      SyntaxKind__ModuleKeyword &
      130; // 130
    static NamespaceKeyword: Class<SyntaxKind__NamespaceKeyword> &
      SyntaxKind__NamespaceKeyword &
      131; // 131
    static NeverKeyword: Class<SyntaxKind__NeverKeyword> &
      SyntaxKind__NeverKeyword &
      132; // 132
    static ReadonlyKeyword: Class<SyntaxKind__ReadonlyKeyword> &
      SyntaxKind__ReadonlyKeyword &
      133; // 133
    static RequireKeyword: Class<SyntaxKind__RequireKeyword> &
      SyntaxKind__RequireKeyword &
      134; // 134
    static NumberKeyword: Class<SyntaxKind__NumberKeyword> &
      SyntaxKind__NumberKeyword &
      135; // 135
    static ObjectKeyword: Class<SyntaxKind__ObjectKeyword> &
      SyntaxKind__ObjectKeyword &
      136; // 136
    static SetKeyword: Class<SyntaxKind__SetKeyword> &
      SyntaxKind__SetKeyword &
      137; // 137
    static StringKeyword: Class<SyntaxKind__StringKeyword> &
      SyntaxKind__StringKeyword &
      138; // 138
    static SymbolKeyword: Class<SyntaxKind__SymbolKeyword> &
      SyntaxKind__SymbolKeyword &
      139; // 139
    static TypeKeyword: Class<SyntaxKind__TypeKeyword> &
      SyntaxKind__TypeKeyword &
      140; // 140
    static UndefinedKeyword: Class<SyntaxKind__UndefinedKeyword> &
      SyntaxKind__UndefinedKeyword &
      141; // 141
    static UniqueKeyword: Class<SyntaxKind__UniqueKeyword> &
      SyntaxKind__UniqueKeyword &
      142; // 142
    static UnknownKeyword: Class<SyntaxKind__UnknownKeyword> &
      SyntaxKind__UnknownKeyword &
      143; // 143
    static FromKeyword: Class<SyntaxKind__FromKeyword> &
      SyntaxKind__FromKeyword &
      144; // 144
    static GlobalKeyword: Class<SyntaxKind__GlobalKeyword> &
      SyntaxKind__GlobalKeyword &
      145; // 145
    static BigIntKeyword: Class<SyntaxKind__BigIntKeyword> &
      SyntaxKind__BigIntKeyword &
      146; // 146
    static OfKeyword: Class<SyntaxKind__OfKeyword> &
      SyntaxKind__OfKeyword &
      147; // 147
    static QualifiedName: Class<SyntaxKind__QualifiedName> &
      SyntaxKind__QualifiedName &
      148; // 148
    static ComputedPropertyName: Class<SyntaxKind__ComputedPropertyName> &
      SyntaxKind__ComputedPropertyName &
      149; // 149
    static TypeParameter: Class<SyntaxKind__TypeParameter> &
      SyntaxKind__TypeParameter &
      150; // 150
    static Parameter: Class<SyntaxKind__Parameter> &
      SyntaxKind__Parameter &
      151; // 151
    static Decorator: Class<SyntaxKind__Decorator> &
      SyntaxKind__Decorator &
      152; // 152
    static PropertySignature: Class<SyntaxKind__PropertySignature> &
      SyntaxKind__PropertySignature &
      153; // 153
    static PropertyDeclaration: Class<SyntaxKind__PropertyDeclaration> &
      SyntaxKind__PropertyDeclaration &
      154; // 154
    static MethodSignature: Class<SyntaxKind__MethodSignature> &
      SyntaxKind__MethodSignature &
      155; // 155
    static MethodDeclaration: Class<SyntaxKind__MethodDeclaration> &
      SyntaxKind__MethodDeclaration &
      156; // 156
    static Constructor: Class<SyntaxKind__Constructor> &
      SyntaxKind__Constructor &
      157; // 157
    static GetAccessor: Class<SyntaxKind__GetAccessor> &
      SyntaxKind__GetAccessor &
      158; // 158
    static SetAccessor: Class<SyntaxKind__SetAccessor> &
      SyntaxKind__SetAccessor &
      159; // 159
    static CallSignature: Class<SyntaxKind__CallSignature> &
      SyntaxKind__CallSignature &
      160; // 160
    static ConstructSignature: Class<SyntaxKind__ConstructSignature> &
      SyntaxKind__ConstructSignature &
      161; // 161
    static IndexSignature: Class<SyntaxKind__IndexSignature> &
      SyntaxKind__IndexSignature &
      162; // 162
    static TypePredicate: Class<SyntaxKind__TypePredicate> &
      SyntaxKind__TypePredicate &
      163; // 163
    static TypeReference: Class<SyntaxKind__TypeReference> &
      SyntaxKind__TypeReference &
      164; // 164
    static FunctionType: Class<SyntaxKind__FunctionType> &
      SyntaxKind__FunctionType &
      165; // 165
    static ConstructorType: Class<SyntaxKind__ConstructorType> &
      SyntaxKind__ConstructorType &
      166; // 166
    static TypeQuery: Class<SyntaxKind__TypeQuery> &
      SyntaxKind__TypeQuery &
      167; // 167
    static TypeLiteral: Class<SyntaxKind__TypeLiteral> &
      SyntaxKind__TypeLiteral &
      168; // 168
    static ArrayType: Class<SyntaxKind__ArrayType> &
      SyntaxKind__ArrayType &
      169; // 169
    static TupleType: Class<SyntaxKind__TupleType> &
      SyntaxKind__TupleType &
      170; // 170
    static OptionalType: Class<SyntaxKind__OptionalType> &
      SyntaxKind__OptionalType &
      171; // 171
    static RestType: Class<SyntaxKind__RestType> & SyntaxKind__RestType & 172; // 172
    static UnionType: Class<SyntaxKind__UnionType> &
      SyntaxKind__UnionType &
      173; // 173
    static IntersectionType: Class<SyntaxKind__IntersectionType> &
      SyntaxKind__IntersectionType &
      174; // 174
    static ConditionalType: Class<SyntaxKind__ConditionalType> &
      SyntaxKind__ConditionalType &
      175; // 175
    static InferType: Class<SyntaxKind__InferType> &
      SyntaxKind__InferType &
      176; // 176
    static ParenthesizedType: Class<SyntaxKind__ParenthesizedType> &
      SyntaxKind__ParenthesizedType &
      177; // 177
    static ThisType: Class<SyntaxKind__ThisType> & SyntaxKind__ThisType & 178; // 178
    static TypeOperator: Class<SyntaxKind__TypeOperator> &
      SyntaxKind__TypeOperator &
      179; // 179
    static IndexedAccessType: Class<SyntaxKind__IndexedAccessType> &
      SyntaxKind__IndexedAccessType &
      180; // 180
    static MappedType: Class<SyntaxKind__MappedType> &
      SyntaxKind__MappedType &
      181; // 181
    static LiteralType: Class<SyntaxKind__LiteralType> &
      SyntaxKind__LiteralType &
      182; // 182
    static ImportType: Class<SyntaxKind__ImportType> &
      SyntaxKind__ImportType &
      183; // 183
    static ObjectBindingPattern: Class<SyntaxKind__ObjectBindingPattern> &
      SyntaxKind__ObjectBindingPattern &
      184; // 184
    static ArrayBindingPattern: Class<SyntaxKind__ArrayBindingPattern> &
      SyntaxKind__ArrayBindingPattern &
      185; // 185
    static BindingElement: Class<SyntaxKind__BindingElement> &
      SyntaxKind__BindingElement &
      186; // 186
    static ArrayLiteralExpression: Class<SyntaxKind__ArrayLiteralExpression> &
      SyntaxKind__ArrayLiteralExpression &
      187; // 187
    static ObjectLiteralExpression: Class<SyntaxKind__ObjectLiteralExpression> &
      SyntaxKind__ObjectLiteralExpression &
      188; // 188
    static PropertyAccessExpression: Class<SyntaxKind__PropertyAccessExpression> &
      SyntaxKind__PropertyAccessExpression &
      189; // 189
    static ElementAccessExpression: Class<SyntaxKind__ElementAccessExpression> &
      SyntaxKind__ElementAccessExpression &
      190; // 190
    static CallExpression: Class<SyntaxKind__CallExpression> &
      SyntaxKind__CallExpression &
      191; // 191
    static NewExpression: Class<SyntaxKind__NewExpression> &
      SyntaxKind__NewExpression &
      192; // 192
    static TaggedTemplateExpression: Class<SyntaxKind__TaggedTemplateExpression> &
      SyntaxKind__TaggedTemplateExpression &
      193; // 193
    static TypeAssertionExpression: Class<SyntaxKind__TypeAssertionExpression> &
      SyntaxKind__TypeAssertionExpression &
      194; // 194
    static ParenthesizedExpression: Class<SyntaxKind__ParenthesizedExpression> &
      SyntaxKind__ParenthesizedExpression &
      195; // 195
    static FunctionExpression: Class<SyntaxKind__FunctionExpression> &
      SyntaxKind__FunctionExpression &
      196; // 196
    static ArrowFunction: Class<SyntaxKind__ArrowFunction> &
      SyntaxKind__ArrowFunction &
      197; // 197
    static DeleteExpression: Class<SyntaxKind__DeleteExpression> &
      SyntaxKind__DeleteExpression &
      198; // 198
    static TypeOfExpression: Class<SyntaxKind__TypeOfExpression> &
      SyntaxKind__TypeOfExpression &
      199; // 199
    static VoidExpression: Class<SyntaxKind__VoidExpression> &
      SyntaxKind__VoidExpression &
      200; // 200
    static AwaitExpression: Class<SyntaxKind__AwaitExpression> &
      SyntaxKind__AwaitExpression &
      201; // 201
    static PrefixUnaryExpression: Class<SyntaxKind__PrefixUnaryExpression> &
      SyntaxKind__PrefixUnaryExpression &
      202; // 202
    static PostfixUnaryExpression: Class<SyntaxKind__PostfixUnaryExpression> &
      SyntaxKind__PostfixUnaryExpression &
      203; // 203
    static BinaryExpression: Class<SyntaxKind__BinaryExpression> &
      SyntaxKind__BinaryExpression &
      204; // 204
    static ConditionalExpression: Class<SyntaxKind__ConditionalExpression> &
      SyntaxKind__ConditionalExpression &
      205; // 205
    static TemplateExpression: Class<SyntaxKind__TemplateExpression> &
      SyntaxKind__TemplateExpression &
      206; // 206
    static YieldExpression: Class<SyntaxKind__YieldExpression> &
      SyntaxKind__YieldExpression &
      207; // 207
    static SpreadElement: Class<SyntaxKind__SpreadElement> &
      SyntaxKind__SpreadElement &
      208; // 208
    static ClassExpression: Class<SyntaxKind__ClassExpression> &
      SyntaxKind__ClassExpression &
      209; // 209
    static OmittedExpression: Class<SyntaxKind__OmittedExpression> &
      SyntaxKind__OmittedExpression &
      210; // 210
    static ExpressionWithTypeArguments: Class<SyntaxKind__ExpressionWithTypeArguments> &
      SyntaxKind__ExpressionWithTypeArguments &
      211; // 211
    static AsExpression: Class<SyntaxKind__AsExpression> &
      SyntaxKind__AsExpression &
      212; // 212
    static NonNullExpression: Class<SyntaxKind__NonNullExpression> &
      SyntaxKind__NonNullExpression &
      213; // 213
    static MetaProperty: Class<SyntaxKind__MetaProperty> &
      SyntaxKind__MetaProperty &
      214; // 214
    static SyntheticExpression: Class<SyntaxKind__SyntheticExpression> &
      SyntaxKind__SyntheticExpression &
      215; // 215
    static TemplateSpan: Class<SyntaxKind__TemplateSpan> &
      SyntaxKind__TemplateSpan &
      216; // 216
    static SemicolonClassElement: Class<SyntaxKind__SemicolonClassElement> &
      SyntaxKind__SemicolonClassElement &
      217; // 217
    static Block: Class<SyntaxKind__Block> & SyntaxKind__Block & 218; // 218
    static VariableStatement: Class<SyntaxKind__VariableStatement> &
      SyntaxKind__VariableStatement &
      219; // 219
    static EmptyStatement: Class<SyntaxKind__EmptyStatement> &
      SyntaxKind__EmptyStatement &
      220; // 220
    static ExpressionStatement: Class<SyntaxKind__ExpressionStatement> &
      SyntaxKind__ExpressionStatement &
      221; // 221
    static IfStatement: Class<SyntaxKind__IfStatement> &
      SyntaxKind__IfStatement &
      222; // 222
    static DoStatement: Class<SyntaxKind__DoStatement> &
      SyntaxKind__DoStatement &
      223; // 223
    static WhileStatement: Class<SyntaxKind__WhileStatement> &
      SyntaxKind__WhileStatement &
      224; // 224
    static ForStatement: Class<SyntaxKind__ForStatement> &
      SyntaxKind__ForStatement &
      225; // 225
    static ForInStatement: Class<SyntaxKind__ForInStatement> &
      SyntaxKind__ForInStatement &
      226; // 226
    static ForOfStatement: Class<SyntaxKind__ForOfStatement> &
      SyntaxKind__ForOfStatement &
      227; // 227
    static ContinueStatement: Class<SyntaxKind__ContinueStatement> &
      SyntaxKind__ContinueStatement &
      228; // 228
    static BreakStatement: Class<SyntaxKind__BreakStatement> &
      SyntaxKind__BreakStatement &
      229; // 229
    static ReturnStatement: Class<SyntaxKind__ReturnStatement> &
      SyntaxKind__ReturnStatement &
      230; // 230
    static WithStatement: Class<SyntaxKind__WithStatement> &
      SyntaxKind__WithStatement &
      231; // 231
    static SwitchStatement: Class<SyntaxKind__SwitchStatement> &
      SyntaxKind__SwitchStatement &
      232; // 232
    static LabeledStatement: Class<SyntaxKind__LabeledStatement> &
      SyntaxKind__LabeledStatement &
      233; // 233
    static ThrowStatement: Class<SyntaxKind__ThrowStatement> &
      SyntaxKind__ThrowStatement &
      234; // 234
    static TryStatement: Class<SyntaxKind__TryStatement> &
      SyntaxKind__TryStatement &
      235; // 235
    static DebuggerStatement: Class<SyntaxKind__DebuggerStatement> &
      SyntaxKind__DebuggerStatement &
      236; // 236
    static VariableDeclaration: Class<SyntaxKind__VariableDeclaration> &
      SyntaxKind__VariableDeclaration &
      237; // 237
    static VariableDeclarationList: Class<SyntaxKind__VariableDeclarationList> &
      SyntaxKind__VariableDeclarationList &
      238; // 238
    static FunctionDeclaration: Class<SyntaxKind__FunctionDeclaration> &
      SyntaxKind__FunctionDeclaration &
      239; // 239
    static ClassDeclaration: Class<SyntaxKind__ClassDeclaration> &
      SyntaxKind__ClassDeclaration &
      240; // 240
    static InterfaceDeclaration: Class<SyntaxKind__InterfaceDeclaration> &
      SyntaxKind__InterfaceDeclaration &
      241; // 241
    static TypeAliasDeclaration: Class<SyntaxKind__TypeAliasDeclaration> &
      SyntaxKind__TypeAliasDeclaration &
      242; // 242
    static EnumDeclaration: Class<SyntaxKind__EnumDeclaration> &
      SyntaxKind__EnumDeclaration &
      243; // 243
    static ModuleDeclaration: Class<SyntaxKind__ModuleDeclaration> &
      SyntaxKind__ModuleDeclaration &
      244; // 244
    static ModuleBlock: Class<SyntaxKind__ModuleBlock> &
      SyntaxKind__ModuleBlock &
      245; // 245
    static CaseBlock: Class<SyntaxKind__CaseBlock> &
      SyntaxKind__CaseBlock &
      246; // 246
    static NamespaceExportDeclaration: Class<SyntaxKind__NamespaceExportDeclaration> &
      SyntaxKind__NamespaceExportDeclaration &
      247; // 247
    static ImportEqualsDeclaration: Class<SyntaxKind__ImportEqualsDeclaration> &
      SyntaxKind__ImportEqualsDeclaration &
      248; // 248
    static ImportDeclaration: Class<SyntaxKind__ImportDeclaration> &
      SyntaxKind__ImportDeclaration &
      249; // 249
    static ImportClause: Class<SyntaxKind__ImportClause> &
      SyntaxKind__ImportClause &
      250; // 250
    static NamespaceImport: Class<SyntaxKind__NamespaceImport> &
      SyntaxKind__NamespaceImport &
      251; // 251
    static NamedImports: Class<SyntaxKind__NamedImports> &
      SyntaxKind__NamedImports &
      252; // 252
    static ImportSpecifier: Class<SyntaxKind__ImportSpecifier> &
      SyntaxKind__ImportSpecifier &
      253; // 253
    static ExportAssignment: Class<SyntaxKind__ExportAssignment> &
      SyntaxKind__ExportAssignment &
      254; // 254
    static ExportDeclaration: Class<SyntaxKind__ExportDeclaration> &
      SyntaxKind__ExportDeclaration &
      255; // 255
    static NamedExports: Class<SyntaxKind__NamedExports> &
      SyntaxKind__NamedExports &
      256; // 256
    static ExportSpecifier: Class<SyntaxKind__ExportSpecifier> &
      SyntaxKind__ExportSpecifier &
      257; // 257
    static MissingDeclaration: Class<SyntaxKind__MissingDeclaration> &
      SyntaxKind__MissingDeclaration &
      258; // 258
    static ExternalModuleReference: Class<SyntaxKind__ExternalModuleReference> &
      SyntaxKind__ExternalModuleReference &
      259; // 259
    static JsxElement: Class<SyntaxKind__JsxElement> &
      SyntaxKind__JsxElement &
      260; // 260
    static JsxSelfClosingElement: Class<SyntaxKind__JsxSelfClosingElement> &
      SyntaxKind__JsxSelfClosingElement &
      261; // 261
    static JsxOpeningElement: Class<SyntaxKind__JsxOpeningElement> &
      SyntaxKind__JsxOpeningElement &
      262; // 262
    static JsxClosingElement: Class<SyntaxKind__JsxClosingElement> &
      SyntaxKind__JsxClosingElement &
      263; // 263
    static JsxFragment: Class<SyntaxKind__JsxFragment> &
      SyntaxKind__JsxFragment &
      264; // 264
    static JsxOpeningFragment: Class<SyntaxKind__JsxOpeningFragment> &
      SyntaxKind__JsxOpeningFragment &
      265; // 265
    static JsxClosingFragment: Class<SyntaxKind__JsxClosingFragment> &
      SyntaxKind__JsxClosingFragment &
      266; // 266
    static JsxAttribute: Class<SyntaxKind__JsxAttribute> &
      SyntaxKind__JsxAttribute &
      267; // 267
    static JsxAttributes: Class<SyntaxKind__JsxAttributes> &
      SyntaxKind__JsxAttributes &
      268; // 268
    static JsxSpreadAttribute: Class<SyntaxKind__JsxSpreadAttribute> &
      SyntaxKind__JsxSpreadAttribute &
      269; // 269
    static JsxExpression: Class<SyntaxKind__JsxExpression> &
      SyntaxKind__JsxExpression &
      270; // 270
    static CaseClause: Class<SyntaxKind__CaseClause> &
      SyntaxKind__CaseClause &
      271; // 271
    static DefaultClause: Class<SyntaxKind__DefaultClause> &
      SyntaxKind__DefaultClause &
      272; // 272
    static HeritageClause: Class<SyntaxKind__HeritageClause> &
      SyntaxKind__HeritageClause &
      273; // 273
    static CatchClause: Class<SyntaxKind__CatchClause> &
      SyntaxKind__CatchClause &
      274; // 274
    static PropertyAssignment: Class<SyntaxKind__PropertyAssignment> &
      SyntaxKind__PropertyAssignment &
      275; // 275
    static ShorthandPropertyAssignment: Class<SyntaxKind__ShorthandPropertyAssignment> &
      SyntaxKind__ShorthandPropertyAssignment &
      276; // 276
    static SpreadAssignment: Class<SyntaxKind__SpreadAssignment> &
      SyntaxKind__SpreadAssignment &
      277; // 277
    static EnumMember: Class<SyntaxKind__EnumMember> &
      SyntaxKind__EnumMember &
      278; // 278
    static SourceFile: Class<SyntaxKind__SourceFile> &
      SyntaxKind__SourceFile &
      279; // 279
    static Bundle: Class<SyntaxKind__Bundle> & SyntaxKind__Bundle & 280; // 280
    static UnparsedSource: Class<SyntaxKind__UnparsedSource> &
      SyntaxKind__UnparsedSource &
      281; // 281
    static InputFiles: Class<SyntaxKind__InputFiles> &
      SyntaxKind__InputFiles &
      282; // 282
    static JSDocTypeExpression: Class<SyntaxKind__JSDocTypeExpression> &
      SyntaxKind__JSDocTypeExpression &
      283; // 283
    static JSDocAllType: Class<SyntaxKind__JSDocAllType> &
      SyntaxKind__JSDocAllType &
      284; // 284
    static JSDocUnknownType: Class<SyntaxKind__JSDocUnknownType> &
      SyntaxKind__JSDocUnknownType &
      285; // 285
    static JSDocNullableType: Class<SyntaxKind__JSDocNullableType> &
      SyntaxKind__JSDocNullableType &
      286; // 286
    static JSDocNonNullableType: Class<SyntaxKind__JSDocNonNullableType> &
      SyntaxKind__JSDocNonNullableType &
      287; // 287
    static JSDocOptionalType: Class<SyntaxKind__JSDocOptionalType> &
      SyntaxKind__JSDocOptionalType &
      288; // 288
    static JSDocFunctionType: Class<SyntaxKind__JSDocFunctionType> &
      SyntaxKind__JSDocFunctionType &
      289; // 289
    static JSDocVariadicType: Class<SyntaxKind__JSDocVariadicType> &
      SyntaxKind__JSDocVariadicType &
      290; // 290
    static JSDocComment: Class<SyntaxKind__JSDocComment> &
      SyntaxKind__JSDocComment &
      291; // 291
    static JSDocTypeLiteral: Class<SyntaxKind__JSDocTypeLiteral> &
      SyntaxKind__JSDocTypeLiteral &
      292; // 292
    static JSDocSignature: Class<SyntaxKind__JSDocSignature> &
      SyntaxKind__JSDocSignature &
      293; // 293
    static JSDocTag: Class<SyntaxKind__JSDocTag> & SyntaxKind__JSDocTag & 294; // 294
    static JSDocAugmentsTag: Class<SyntaxKind__JSDocAugmentsTag> &
      SyntaxKind__JSDocAugmentsTag &
      295; // 295
    static JSDocClassTag: Class<SyntaxKind__JSDocClassTag> &
      SyntaxKind__JSDocClassTag &
      296; // 296
    static JSDocCallbackTag: Class<SyntaxKind__JSDocCallbackTag> &
      SyntaxKind__JSDocCallbackTag &
      297; // 297
    static JSDocEnumTag: Class<SyntaxKind__JSDocEnumTag> &
      SyntaxKind__JSDocEnumTag &
      298; // 298
    static JSDocParameterTag: Class<SyntaxKind__JSDocParameterTag> &
      SyntaxKind__JSDocParameterTag &
      299; // 299
    static JSDocReturnTag: Class<SyntaxKind__JSDocReturnTag> &
      SyntaxKind__JSDocReturnTag &
      300; // 300
    static JSDocThisTag: Class<SyntaxKind__JSDocThisTag> &
      SyntaxKind__JSDocThisTag &
      301; // 301
    static JSDocTypeTag: Class<SyntaxKind__JSDocTypeTag> &
      SyntaxKind__JSDocTypeTag &
      302; // 302
    static JSDocTemplateTag: Class<SyntaxKind__JSDocTemplateTag> &
      SyntaxKind__JSDocTemplateTag &
      303; // 303
    static JSDocTypedefTag: Class<SyntaxKind__JSDocTypedefTag> &
      SyntaxKind__JSDocTypedefTag &
      304; // 304
    static JSDocPropertyTag: Class<SyntaxKind__JSDocPropertyTag> &
      SyntaxKind__JSDocPropertyTag &
      305; // 305
    static SyntaxList: Class<SyntaxKind__SyntaxList> &
      SyntaxKind__SyntaxList &
      306; // 306
    static NotEmittedStatement: Class<SyntaxKind__NotEmittedStatement> &
      SyntaxKind__NotEmittedStatement &
      307; // 307
    static PartiallyEmittedExpression: Class<SyntaxKind__PartiallyEmittedExpression> &
      SyntaxKind__PartiallyEmittedExpression &
      308; // 308
    static CommaListExpression: Class<SyntaxKind__CommaListExpression> &
      SyntaxKind__CommaListExpression &
      309; // 309
    static MergeDeclarationMarker: Class<SyntaxKind__MergeDeclarationMarker> &
      SyntaxKind__MergeDeclarationMarker &
      310; // 310
    static EndOfDeclarationMarker: Class<SyntaxKind__EndOfDeclarationMarker> &
      SyntaxKind__EndOfDeclarationMarker &
      311; // 311
    static Count: Class<SyntaxKind__Count> & SyntaxKind__Count & 312; // 312
    static FirstAssignment: Class<SyntaxKind__FirstAssignment> &
      SyntaxKind__FirstAssignment &
      59; // 59
    static LastAssignment: Class<SyntaxKind__LastAssignment> &
      SyntaxKind__LastAssignment &
      71; // 71
    static FirstCompoundAssignment: Class<SyntaxKind__FirstCompoundAssignment> &
      SyntaxKind__FirstCompoundAssignment &
      60; // 60
    static LastCompoundAssignment: Class<SyntaxKind__LastCompoundAssignment> &
      SyntaxKind__LastCompoundAssignment &
      71; // 71
    static FirstReservedWord: Class<SyntaxKind__FirstReservedWord> &
      SyntaxKind__FirstReservedWord &
      73; // 73
    static LastReservedWord: Class<SyntaxKind__LastReservedWord> &
      SyntaxKind__LastReservedWord &
      108; // 108
    static FirstKeyword: Class<SyntaxKind__FirstKeyword> &
      SyntaxKind__FirstKeyword &
      73; // 73
    static LastKeyword: Class<SyntaxKind__LastKeyword> &
      SyntaxKind__LastKeyword &
      147; // 147
    static FirstFutureReservedWord: Class<SyntaxKind__FirstFutureReservedWord> &
      SyntaxKind__FirstFutureReservedWord &
      109; // 109
    static LastFutureReservedWord: Class<SyntaxKind__LastFutureReservedWord> &
      SyntaxKind__LastFutureReservedWord &
      117; // 117
    static FirstTypeNode: Class<SyntaxKind__FirstTypeNode> &
      SyntaxKind__FirstTypeNode &
      163; // 163
    static LastTypeNode: Class<SyntaxKind__LastTypeNode> &
      SyntaxKind__LastTypeNode &
      183; // 183
    static FirstPunctuation: Class<SyntaxKind__FirstPunctuation> &
      SyntaxKind__FirstPunctuation &
      18; // 18
    static LastPunctuation: Class<SyntaxKind__LastPunctuation> &
      SyntaxKind__LastPunctuation &
      71; // 71
    static FirstToken: Class<SyntaxKind__FirstToken> &
      SyntaxKind__FirstToken &
      0; // 0
    static LastToken: Class<SyntaxKind__LastToken> &
      SyntaxKind__LastToken &
      147; // 147
    static FirstTriviaToken: Class<SyntaxKind__FirstTriviaToken> &
      SyntaxKind__FirstTriviaToken &
      2; // 2
    static LastTriviaToken: Class<SyntaxKind__LastTriviaToken> &
      SyntaxKind__LastTriviaToken &
      7; // 7
    static FirstLiteralToken: Class<SyntaxKind__FirstLiteralToken> &
      SyntaxKind__FirstLiteralToken &
      8; // 8
    static LastLiteralToken: Class<SyntaxKind__LastLiteralToken> &
      SyntaxKind__LastLiteralToken &
      14; // 14
    static FirstTemplateToken: Class<SyntaxKind__FirstTemplateToken> &
      SyntaxKind__FirstTemplateToken &
      14; // 14
    static LastTemplateToken: Class<SyntaxKind__LastTemplateToken> &
      SyntaxKind__LastTemplateToken &
      17; // 17
    static FirstBinaryOperator: Class<SyntaxKind__FirstBinaryOperator> &
      SyntaxKind__FirstBinaryOperator &
      28; // 28
    static LastBinaryOperator: Class<SyntaxKind__LastBinaryOperator> &
      SyntaxKind__LastBinaryOperator &
      71; // 71
    static FirstNode: Class<SyntaxKind__FirstNode> &
      SyntaxKind__FirstNode &
      148; // 148
    static FirstJSDocNode: Class<SyntaxKind__FirstJSDocNode> &
      SyntaxKind__FirstJSDocNode &
      283; // 283
    static LastJSDocNode: Class<SyntaxKind__LastJSDocNode> &
      SyntaxKind__LastJSDocNode &
      305; // 305
    static FirstJSDocTagNode: Class<SyntaxKind__FirstJSDocTagNode> &
      SyntaxKind__FirstJSDocTagNode &
      294; // 294
    static LastJSDocTagNode: Class<SyntaxKind__LastJSDocTagNode> &
      SyntaxKind__LastJSDocTagNode &
      305; // 305
  }

  declare class NodeFlags__None mixins NodeFlags {}
  declare class NodeFlags__Let mixins NodeFlags {}
  declare class NodeFlags__Const mixins NodeFlags {}
  declare class NodeFlags__NestedNamespace mixins NodeFlags {}
  declare class NodeFlags__Synthesized mixins NodeFlags {}
  declare class NodeFlags__Namespace mixins NodeFlags {}
  declare class NodeFlags__ExportContext mixins NodeFlags {}
  declare class NodeFlags__ContainsThis mixins NodeFlags {}
  declare class NodeFlags__HasImplicitReturn mixins NodeFlags {}
  declare class NodeFlags__HasExplicitReturn mixins NodeFlags {}
  declare class NodeFlags__GlobalAugmentation mixins NodeFlags {}
  declare class NodeFlags__HasAsyncFunctions mixins NodeFlags {}
  declare class NodeFlags__DisallowInContext mixins NodeFlags {}
  declare class NodeFlags__YieldContext mixins NodeFlags {}
  declare class NodeFlags__DecoratorContext mixins NodeFlags {}
  declare class NodeFlags__AwaitContext mixins NodeFlags {}
  declare class NodeFlags__ThisNodeHasError mixins NodeFlags {}
  declare class NodeFlags__JavaScriptFile mixins NodeFlags {}
  declare class NodeFlags__ThisNodeOrAnySubNodesHasError mixins NodeFlags {}
  declare class NodeFlags__HasAggregatedChildData mixins NodeFlags {}
  declare class NodeFlags__JSDoc mixins NodeFlags {}
  declare class NodeFlags__JsonFile mixins NodeFlags {}
  declare class NodeFlags__BlockScoped mixins NodeFlags {}
  declare class NodeFlags__ReachabilityCheckFlags mixins NodeFlags {}
  declare class NodeFlags__ReachabilityAndEmitFlags mixins NodeFlags {}
  declare class NodeFlags__ContextFlags mixins NodeFlags {}
  declare class NodeFlags__TypeExcludesFlags mixins NodeFlags {}

  declare export class NodeFlags {
    constructor(...args: empty): mixed;
    static None: Class<NodeFlags__None> & NodeFlags__None & 0; // 0
    static Let: Class<NodeFlags__Let> & NodeFlags__Let & 1; // 1
    static Const: Class<NodeFlags__Const> & NodeFlags__Const & 2; // 2
    static NestedNamespace: Class<NodeFlags__NestedNamespace> &
      NodeFlags__NestedNamespace &
      4; // 4
    static Synthesized: Class<NodeFlags__Synthesized> &
      NodeFlags__Synthesized &
      8; // 8
    static Namespace: Class<NodeFlags__Namespace> & NodeFlags__Namespace & 16; // 16
    static ExportContext: Class<NodeFlags__ExportContext> &
      NodeFlags__ExportContext &
      32; // 32
    static ContainsThis: Class<NodeFlags__ContainsThis> &
      NodeFlags__ContainsThis &
      64; // 64
    static HasImplicitReturn: Class<NodeFlags__HasImplicitReturn> &
      NodeFlags__HasImplicitReturn &
      128; // 128
    static HasExplicitReturn: Class<NodeFlags__HasExplicitReturn> &
      NodeFlags__HasExplicitReturn &
      256; // 256
    static GlobalAugmentation: Class<NodeFlags__GlobalAugmentation> &
      NodeFlags__GlobalAugmentation &
      512; // 512
    static HasAsyncFunctions: Class<NodeFlags__HasAsyncFunctions> &
      NodeFlags__HasAsyncFunctions &
      1024; // 1024
    static DisallowInContext: Class<NodeFlags__DisallowInContext> &
      NodeFlags__DisallowInContext &
      2048; // 2048
    static YieldContext: Class<NodeFlags__YieldContext> &
      NodeFlags__YieldContext &
      4096; // 4096
    static DecoratorContext: Class<NodeFlags__DecoratorContext> &
      NodeFlags__DecoratorContext &
      8192; // 8192
    static AwaitContext: Class<NodeFlags__AwaitContext> &
      NodeFlags__AwaitContext &
      16384; // 16384
    static ThisNodeHasError: Class<NodeFlags__ThisNodeHasError> &
      NodeFlags__ThisNodeHasError &
      32768; // 32768
    static JavaScriptFile: Class<NodeFlags__JavaScriptFile> &
      NodeFlags__JavaScriptFile &
      65536; // 65536
    static ThisNodeOrAnySubNodesHasError: Class<NodeFlags__ThisNodeOrAnySubNodesHasError> &
      NodeFlags__ThisNodeOrAnySubNodesHasError &
      131072; // 131072
    static HasAggregatedChildData: Class<NodeFlags__HasAggregatedChildData> &
      NodeFlags__HasAggregatedChildData &
      262144; // 262144
    static JSDoc: Class<NodeFlags__JSDoc> & NodeFlags__JSDoc & 2097152; // 2097152
    static JsonFile: Class<NodeFlags__JsonFile> &
      NodeFlags__JsonFile &
      16777216; // 16777216
    static BlockScoped: Class<NodeFlags__BlockScoped> &
      NodeFlags__BlockScoped &
      3; // 3
    static ReachabilityCheckFlags: Class<NodeFlags__ReachabilityCheckFlags> &
      NodeFlags__ReachabilityCheckFlags &
      384; // 384
    static ReachabilityAndEmitFlags: Class<NodeFlags__ReachabilityAndEmitFlags> &
      NodeFlags__ReachabilityAndEmitFlags &
      1408; // 1408
    static ContextFlags: Class<NodeFlags__ContextFlags> &
      NodeFlags__ContextFlags &
      12679168; // 12679168
    static TypeExcludesFlags: Class<NodeFlags__TypeExcludesFlags> &
      NodeFlags__TypeExcludesFlags &
      20480; // 20480
  }

  declare class ModifierFlags__None mixins ModifierFlags {}
  declare class ModifierFlags__Export mixins ModifierFlags {}
  declare class ModifierFlags__Ambient mixins ModifierFlags {}
  declare class ModifierFlags__Public mixins ModifierFlags {}
  declare class ModifierFlags__Private mixins ModifierFlags {}
  declare class ModifierFlags__Protected mixins ModifierFlags {}
  declare class ModifierFlags__Static mixins ModifierFlags {}
  declare class ModifierFlags__Readonly mixins ModifierFlags {}
  declare class ModifierFlags__Abstract mixins ModifierFlags {}
  declare class ModifierFlags__Async mixins ModifierFlags {}
  declare class ModifierFlags__Default mixins ModifierFlags {}
  declare class ModifierFlags__Const mixins ModifierFlags {}
  declare class ModifierFlags__HasComputedFlags mixins ModifierFlags {}
  declare class ModifierFlags__AccessibilityModifier mixins ModifierFlags {}
  declare class ModifierFlags__ParameterPropertyModifier mixins ModifierFlags {}
  declare class ModifierFlags__NonPublicAccessibilityModifier
    mixins ModifierFlags {}
  declare class ModifierFlags__TypeScriptModifier mixins ModifierFlags {}
  declare class ModifierFlags__ExportDefault mixins ModifierFlags {}
  declare class ModifierFlags__All mixins ModifierFlags {}

  declare export class ModifierFlags {
    constructor(...args: empty): mixed;
    static None: Class<ModifierFlags__None> & ModifierFlags__None & 0; // 0
    static Export: Class<ModifierFlags__Export> & ModifierFlags__Export & 1; // 1
    static Ambient: Class<ModifierFlags__Ambient> & ModifierFlags__Ambient & 2; // 2
    static Public: Class<ModifierFlags__Public> & ModifierFlags__Public & 4; // 4
    static Private: Class<ModifierFlags__Private> & ModifierFlags__Private & 8; // 8
    static Protected: Class<ModifierFlags__Protected> &
      ModifierFlags__Protected &
      16; // 16
    static Static: Class<ModifierFlags__Static> & ModifierFlags__Static & 32; // 32
    static Readonly: Class<ModifierFlags__Readonly> &
      ModifierFlags__Readonly &
      64; // 64
    static Abstract: Class<ModifierFlags__Abstract> &
      ModifierFlags__Abstract &
      128; // 128
    static Async: Class<ModifierFlags__Async> & ModifierFlags__Async & 256; // 256
    static Default: Class<ModifierFlags__Default> &
      ModifierFlags__Default &
      512; // 512
    static Const: Class<ModifierFlags__Const> & ModifierFlags__Const & 2048; // 2048
    static HasComputedFlags: Class<ModifierFlags__HasComputedFlags> &
      ModifierFlags__HasComputedFlags &
      536870912; // 536870912
    static AccessibilityModifier: Class<ModifierFlags__AccessibilityModifier> &
      ModifierFlags__AccessibilityModifier &
      28; // 28
    static ParameterPropertyModifier: Class<ModifierFlags__ParameterPropertyModifier> &
      ModifierFlags__ParameterPropertyModifier &
      92; // 92
    static NonPublicAccessibilityModifier: Class<ModifierFlags__NonPublicAccessibilityModifier> &
      ModifierFlags__NonPublicAccessibilityModifier &
      24; // 24
    static TypeScriptModifier: Class<ModifierFlags__TypeScriptModifier> &
      ModifierFlags__TypeScriptModifier &
      2270; // 2270
    static ExportDefault: Class<ModifierFlags__ExportDefault> &
      ModifierFlags__ExportDefault &
      513; // 513
    static All: Class<ModifierFlags__All> & ModifierFlags__All & 3071; // 3071
  }

  declare class JsxFlags__None mixins JsxFlags {}
  declare class JsxFlags__IntrinsicNamedElement mixins JsxFlags {}
  declare class JsxFlags__IntrinsicIndexedElement mixins JsxFlags {}
  declare class JsxFlags__IntrinsicElement mixins JsxFlags {}

  declare export class JsxFlags {
    constructor(...args: empty): mixed;
    static None: Class<JsxFlags__None> & JsxFlags__None & 0; // 0
    static IntrinsicNamedElement: Class<JsxFlags__IntrinsicNamedElement> &
      JsxFlags__IntrinsicNamedElement &
      1; // 1
    static IntrinsicIndexedElement: Class<JsxFlags__IntrinsicIndexedElement> &
      JsxFlags__IntrinsicIndexedElement &
      2; // 2
    static IntrinsicElement: Class<JsxFlags__IntrinsicElement> &
      JsxFlags__IntrinsicElement &
      3; // 3
  }

  declare export type Node = {
    kind: SyntaxKind,
    flags: NodeFlags,
    decorators?: NodeArray<Decorator>,
    modifiers?: ModifiersArray,
    parent: Node,
    getSourceFile(): SourceFile,
    getChildCount(sourceFile?: SourceFile): number,
    getChildAt(index: number, sourceFile?: SourceFile): Node,
    getChildren(sourceFile?: SourceFile): Node[],
    getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number,
    getFullStart(): number,
    getEnd(): number,
    getWidth(sourceFile?: SourceFileLike): number,
    getFullWidth(): number,
    getLeadingTriviaWidth(sourceFile?: SourceFile): number,
    getFullText(sourceFile?: SourceFile): string,
    getText(sourceFile?: SourceFile): string,
    getFirstToken(sourceFile?: SourceFile): Node | void,
    getLastToken(sourceFile?: SourceFile): Node | void,
    forEachChild<T>(
      cbNode: (node: Node) => T | void,
      cbNodeArray?: (nodes: NodeArray<Node>) => T | void
    ): T | void
  } & TextRange;

  declare export interface JSDocContainer {}
  declare export type HasJSDoc =
    | ParameterDeclaration
    | CallSignatureDeclaration
    | ConstructSignatureDeclaration
    | MethodSignature
    | PropertySignature
    | ArrowFunction
    | ParenthesizedExpression
    | SpreadAssignment
    | ShorthandPropertyAssignment
    | PropertyAssignment
    | FunctionExpression
    | LabeledStatement
    | ExpressionStatement
    | VariableStatement
    | FunctionDeclaration
    | ConstructorDeclaration
    | MethodDeclaration
    | PropertyDeclaration
    | AccessorDeclaration
    | ClassLikeDeclaration
    | InterfaceDeclaration
    | TypeAliasDeclaration
    | EnumMember
    | EnumDeclaration
    | ModuleDeclaration
    | ImportEqualsDeclaration
    | IndexSignatureDeclaration
    | FunctionTypeNode
    | ConstructorTypeNode
    | JSDocFunctionType
    | ExportDeclaration
    | EndOfFileToken;
  declare export type HasType =
    | SignatureDeclaration
    | VariableDeclaration
    | ParameterDeclaration
    | PropertySignature
    | PropertyDeclaration
    | TypePredicateNode
    | ParenthesizedTypeNode
    | TypeOperatorNode
    | MappedTypeNode
    | AssertionExpression
    | TypeAliasDeclaration
    | JSDocTypeExpression
    | JSDocNonNullableType
    | JSDocNullableType
    | JSDocOptionalType
    | JSDocVariadicType;
  declare export type HasInitializer =
    | HasExpressionInitializer
    | ForStatement
    | ForInStatement
    | ForOfStatement
    | JsxAttribute;
  declare export type HasExpressionInitializer =
    | VariableDeclaration
    | ParameterDeclaration
    | BindingElement
    | PropertySignature
    | PropertyDeclaration
    | PropertyAssignment
    | EnumMember;
  declare export type NodeArray<T: Node> = {
    hasTrailingComma?: boolean
  } & $ReadOnlyArray<T> &
    TextRange;

  declare export type Token<TKind: SyntaxKind> = {
    kind: TKind
  } & Node;

  declare export type DotDotDotToken = Token<SyntaxKind.DotDotDotToken>;
  declare export type QuestionToken = Token<SyntaxKind.QuestionToken>;
  declare export type ExclamationToken = Token<SyntaxKind.ExclamationToken>;
  declare export type ColonToken = Token<SyntaxKind.ColonToken>;
  declare export type EqualsToken = Token<SyntaxKind.EqualsToken>;
  declare export type AsteriskToken = Token<SyntaxKind.AsteriskToken>;
  declare export type EqualsGreaterThanToken = Token<SyntaxKind.EqualsGreaterThanToken>;
  declare export type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> &
    JSDocContainer;
  declare export type ReadonlyToken = Token<SyntaxKind.ReadonlyKeyword>;
  declare export type AwaitKeywordToken = Token<SyntaxKind.AwaitKeyword>;
  declare export type PlusToken = Token<SyntaxKind.PlusToken>;
  declare export type MinusToken = Token<SyntaxKind.MinusToken>;
  declare export type Modifier =
    | Token<SyntaxKind.AbstractKeyword>
    | Token<SyntaxKind.AsyncKeyword>
    | Token<SyntaxKind.ConstKeyword>
    | Token<SyntaxKind.DeclareKeyword>
    | Token<SyntaxKind.DefaultKeyword>
    | Token<SyntaxKind.ExportKeyword>
    | Token<SyntaxKind.PublicKeyword>
    | Token<SyntaxKind.PrivateKeyword>
    | Token<SyntaxKind.ProtectedKeyword>
    | Token<SyntaxKind.ReadonlyKeyword>
    | Token<SyntaxKind.StaticKeyword>;
  declare export type ModifiersArray = NodeArray<Modifier>;
  declare export type Identifier = {
    kind: SyntaxKind.Identifier,

    /**
     * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)
     * Text of identifier, but if the identifier begins with two underscores, this will begin with three.
     */
    escapedText: __String,
    originalKeywordKind?: SyntaxKind,
    isInJSDocNamespace?: boolean,
    text: string
  } & PrimaryExpression &
    Declaration;

  declare export type TransientIdentifier = {
    resolvedSymbol: Symbol
  } & Identifier;

  declare export type QualifiedName = {
    kind: SyntaxKind.QualifiedName,
    left: EntityName,
    right: Identifier
  } & Node;

  declare export type EntityName = Identifier | QualifiedName;
  declare export type PropertyName =
    | Identifier
    | StringLiteral
    | NumericLiteral
    | ComputedPropertyName;
  declare export type DeclarationName =
    | Identifier
    | StringLiteralLike
    | NumericLiteral
    | ComputedPropertyName
    | BindingPattern;
  declare export type Declaration = {
    _declarationBrand: any
  } & Node;

  declare export type NamedDeclaration = {
    name?: DeclarationName
  } & Declaration;

  declare export type DeclarationStatement = {
    name?: Identifier | StringLiteral | NumericLiteral
  } & NamedDeclaration &
    Statement;

  declare export type ComputedPropertyName = {
    parent: Declaration,
    kind: SyntaxKind.ComputedPropertyName,
    expression: Expression
  } & Node;

  declare export type Decorator = {
    kind: SyntaxKind.Decorator,
    parent: NamedDeclaration,
    expression: LeftHandSideExpression
  } & Node;

  declare export type TypeParameterDeclaration = {
    kind: SyntaxKind.TypeParameter,
    parent: DeclarationWithTypeParameterChildren | InferTypeNode,
    name: Identifier,

    /**
     * Note: Consider calling `getEffectiveConstraintOfTypeParameter`
     */
    constraint?: TypeNode,
    default?: TypeNode,
    expression?: Expression
  } & NamedDeclaration;

  declare export type SignatureDeclarationBase = {
    kind: $ElementType<SignatureDeclaration, "kind">,
    name?: PropertyName,
    typeParameters?: NodeArray<TypeParameterDeclaration>,
    parameters: NodeArray<ParameterDeclaration>,
    type?: TypeNode
  } & NamedDeclaration &
    JSDocContainer;

  declare export type SignatureDeclaration =
    | CallSignatureDeclaration
    | ConstructSignatureDeclaration
    | MethodSignature
    | IndexSignatureDeclaration
    | FunctionTypeNode
    | ConstructorTypeNode
    | JSDocFunctionType
    | FunctionDeclaration
    | MethodDeclaration
    | ConstructorDeclaration
    | AccessorDeclaration
    | FunctionExpression
    | ArrowFunction;
  declare export type CallSignatureDeclaration = {
    kind: SyntaxKind.CallSignature
  } & SignatureDeclarationBase &
    TypeElement;

  declare export type ConstructSignatureDeclaration = {
    kind: SyntaxKind.ConstructSignature
  } & SignatureDeclarationBase &
    TypeElement;

  declare export type BindingName = Identifier | BindingPattern;
  declare export type VariableDeclaration = {
    kind: SyntaxKind.VariableDeclaration,
    parent: VariableDeclarationList | CatchClause,
    name: BindingName,
    exclamationToken?: ExclamationToken,
    type?: TypeNode,
    initializer?: Expression
  } & NamedDeclaration;

  declare export type VariableDeclarationList = {
    kind: SyntaxKind.VariableDeclarationList,
    parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement,
    declarations: NodeArray<VariableDeclaration>
  } & Node;

  declare export type ParameterDeclaration = {
    kind: SyntaxKind.Parameter,
    parent: SignatureDeclaration,
    dotDotDotToken?: DotDotDotToken,
    name: BindingName,
    questionToken?: QuestionToken,
    type?: TypeNode,
    initializer?: Expression
  } & NamedDeclaration &
    JSDocContainer;

  declare export type BindingElement = {
    kind: SyntaxKind.BindingElement,
    parent: BindingPattern,
    propertyName?: PropertyName,
    dotDotDotToken?: DotDotDotToken,
    name: BindingName,
    initializer?: Expression
  } & NamedDeclaration;

  declare export type PropertySignature = {
    kind: SyntaxKind.PropertySignature,
    name: PropertyName,
    questionToken?: QuestionToken,
    type?: TypeNode,
    initializer?: Expression
  } & TypeElement &
    JSDocContainer;

  declare export type PropertyDeclaration = {
    kind: SyntaxKind.PropertyDeclaration,
    parent: ClassLikeDeclaration,
    name: PropertyName,
    questionToken?: QuestionToken,
    exclamationToken?: ExclamationToken,
    type?: TypeNode,
    initializer?: Expression
  } & ClassElement &
    JSDocContainer;

  declare export type ObjectLiteralElement = {
    _objectLiteralBrandBrand: any,
    name?: PropertyName
  } & NamedDeclaration;

  /**
   * Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute.
   */
  declare export type ObjectLiteralElementLike =
    | PropertyAssignment
    | ShorthandPropertyAssignment
    | SpreadAssignment
    | MethodDeclaration
    | AccessorDeclaration;
  declare export type PropertyAssignment = {
    parent: ObjectLiteralExpression,
    kind: SyntaxKind.PropertyAssignment,
    name: PropertyName,
    questionToken?: QuestionToken,
    initializer: Expression
  } & ObjectLiteralElement &
    JSDocContainer;

  declare export type ShorthandPropertyAssignment = {
    parent: ObjectLiteralExpression,
    kind: SyntaxKind.ShorthandPropertyAssignment,
    name: Identifier,
    questionToken?: QuestionToken,
    exclamationToken?: ExclamationToken,
    equalsToken?: Token<SyntaxKind.EqualsToken>,
    objectAssignmentInitializer?: Expression
  } & ObjectLiteralElement &
    JSDocContainer;

  declare export type SpreadAssignment = {
    parent: ObjectLiteralExpression,
    kind: SyntaxKind.SpreadAssignment,
    expression: Expression
  } & ObjectLiteralElement &
    JSDocContainer;

  declare export type VariableLikeDeclaration =
    | VariableDeclaration
    | ParameterDeclaration
    | BindingElement
    | PropertyDeclaration
    | PropertyAssignment
    | PropertySignature
    | JsxAttribute
    | ShorthandPropertyAssignment
    | EnumMember
    | JSDocPropertyTag
    | JSDocParameterTag;
  declare export type PropertyLikeDeclaration = {
    name: PropertyName
  } & NamedDeclaration;

  declare export type ObjectBindingPattern = {
    kind: SyntaxKind.ObjectBindingPattern,
    parent: VariableDeclaration | ParameterDeclaration | BindingElement,
    elements: NodeArray<BindingElement>
  } & Node;

  declare export type ArrayBindingPattern = {
    kind: SyntaxKind.ArrayBindingPattern,
    parent: VariableDeclaration | ParameterDeclaration | BindingElement,
    elements: NodeArray<ArrayBindingElement>
  } & Node;

  declare export type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;
  declare export type ArrayBindingElement = BindingElement | OmittedExpression;

  /**
 * Several node kinds share function-like features such as a signature,
 * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.
Examples:
- FunctionDeclaration
- MethodDeclaration
- AccessorDeclaration
*/
  declare export type FunctionLikeDeclarationBase = {
    _functionLikeDeclarationBrand: any,
    asteriskToken?: AsteriskToken,
    questionToken?: QuestionToken,
    exclamationToken?: ExclamationToken,
    body?: Block | Expression
  } & SignatureDeclarationBase;

  declare export type FunctionLikeDeclaration =
    | FunctionDeclaration
    | MethodDeclaration
    | GetAccessorDeclaration
    | SetAccessorDeclaration
    | ConstructorDeclaration
    | FunctionExpression
    | ArrowFunction;

  /**
   *
   * @deprecated Use SignatureDeclaration
   */
  declare export type FunctionLike = SignatureDeclaration;
  declare export type FunctionDeclaration = {
    kind: SyntaxKind.FunctionDeclaration,
    name?: Identifier,
    body?: FunctionBody
  } & FunctionLikeDeclarationBase &
    DeclarationStatement;

  declare export type MethodSignature = {
    kind: SyntaxKind.MethodSignature,
    parent: ObjectTypeDeclaration,
    name: PropertyName
  } & SignatureDeclarationBase &
    TypeElement;

  declare export type MethodDeclaration = {
    kind: SyntaxKind.MethodDeclaration,
    parent: ClassLikeDeclaration | ObjectLiteralExpression,
    name: PropertyName,
    body?: FunctionBody
  } & FunctionLikeDeclarationBase &
    ClassElement &
    ObjectLiteralElement &
    JSDocContainer;

  declare export type ConstructorDeclaration = {
    kind: SyntaxKind.Constructor,
    parent: ClassLikeDeclaration,
    body?: FunctionBody
  } & FunctionLikeDeclarationBase &
    ClassElement &
    JSDocContainer;

  /**
   * For when we encounter a semicolon in a class declaration. ES6 allows these as class elements.
   */
  declare export type SemicolonClassElement = {
    kind: SyntaxKind.SemicolonClassElement,
    parent: ClassLikeDeclaration
  } & ClassElement;

  declare export type GetAccessorDeclaration = {
    kind: SyntaxKind.GetAccessor,
    parent: ClassLikeDeclaration | ObjectLiteralExpression,
    name: PropertyName,
    body?: FunctionBody
  } & FunctionLikeDeclarationBase &
    ClassElement &
    ObjectLiteralElement &
    JSDocContainer;

  declare export type SetAccessorDeclaration = {
    kind: SyntaxKind.SetAccessor,
    parent: ClassLikeDeclaration | ObjectLiteralExpression,
    name: PropertyName,
    body?: FunctionBody
  } & FunctionLikeDeclarationBase &
    ClassElement &
    ObjectLiteralElement &
    JSDocContainer;

  declare export type AccessorDeclaration =
    | GetAccessorDeclaration
    | SetAccessorDeclaration;
  declare export type IndexSignatureDeclaration = {
    kind: SyntaxKind.IndexSignature,
    parent: ObjectTypeDeclaration
  } & SignatureDeclarationBase &
    ClassElement &
    TypeElement;

  declare export type TypeNode = {
    _typeNodeBrand: any
  } & Node;

  declare export type KeywordTypeNode = {
    kind:
      | SyntaxKind.AnyKeyword
      | SyntaxKind.UnknownKeyword
      | SyntaxKind.NumberKeyword
      | SyntaxKind.BigIntKeyword
      | SyntaxKind.ObjectKeyword
      | SyntaxKind.BooleanKeyword
      | SyntaxKind.StringKeyword
      | SyntaxKind.SymbolKeyword
      | SyntaxKind.ThisKeyword
      | SyntaxKind.VoidKeyword
      | SyntaxKind.UndefinedKeyword
      | SyntaxKind.NullKeyword
      | SyntaxKind.NeverKeyword
  } & TypeNode;

  declare export type ImportTypeNode = {
    kind: SyntaxKind.ImportType,
    isTypeOf?: boolean,
    argument: TypeNode,
    qualifier?: EntityName
  } & NodeWithTypeArguments;

  declare export type ThisTypeNode = {
    kind: SyntaxKind.ThisType
  } & TypeNode;

  declare export type FunctionOrConstructorTypeNode =
    | FunctionTypeNode
    | ConstructorTypeNode;
  declare export type FunctionOrConstructorTypeNodeBase = {
    kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType,
    type: TypeNode
  } & TypeNode &
    SignatureDeclarationBase;

  declare export type FunctionTypeNode = {
    kind: SyntaxKind.FunctionType
  } & FunctionOrConstructorTypeNodeBase;

  declare export type ConstructorTypeNode = {
    kind: SyntaxKind.ConstructorType
  } & FunctionOrConstructorTypeNodeBase;

  declare export type NodeWithTypeArguments = {
    typeArguments?: NodeArray<TypeNode>
  } & TypeNode;

  declare export type TypeReferenceType =
    | TypeReferenceNode
    | ExpressionWithTypeArguments;
  declare export type TypeReferenceNode = {
    kind: SyntaxKind.TypeReference,
    typeName: EntityName
  } & NodeWithTypeArguments;

  declare export type TypePredicateNode = {
    kind: SyntaxKind.TypePredicate,
    parent: SignatureDeclaration | JSDocTypeExpression,
    parameterName: Identifier | ThisTypeNode,
    type: TypeNode
  } & TypeNode;

  declare export type TypeQueryNode = {
    kind: SyntaxKind.TypeQuery,
    exprName: EntityName
  } & TypeNode;

  declare export type TypeLiteralNode = {
    kind: SyntaxKind.TypeLiteral,
    members: NodeArray<TypeElement>
  } & TypeNode &
    Declaration;

  declare export type ArrayTypeNode = {
    kind: SyntaxKind.ArrayType,
    elementType: TypeNode
  } & TypeNode;

  declare export type TupleTypeNode = {
    kind: SyntaxKind.TupleType,
    elementTypes: NodeArray<TypeNode>
  } & TypeNode;

  declare export type OptionalTypeNode = {
    kind: SyntaxKind.OptionalType,
    type: TypeNode
  } & TypeNode;

  declare export type RestTypeNode = {
    kind: SyntaxKind.RestType,
    type: TypeNode
  } & TypeNode;

  declare export type UnionOrIntersectionTypeNode =
    | UnionTypeNode
    | IntersectionTypeNode;
  declare export type UnionTypeNode = {
    kind: SyntaxKind.UnionType,
    types: NodeArray<TypeNode>
  } & TypeNode;

  declare export type IntersectionTypeNode = {
    kind: SyntaxKind.IntersectionType,
    types: NodeArray<TypeNode>
  } & TypeNode;

  declare export type ConditionalTypeNode = {
    kind: SyntaxKind.ConditionalType,
    checkType: TypeNode,
    extendsType: TypeNode,
    trueType: TypeNode,
    falseType: TypeNode
  } & TypeNode;

  declare export type InferTypeNode = {
    kind: SyntaxKind.InferType,
    typeParameter: TypeParameterDeclaration
  } & TypeNode;

  declare export type ParenthesizedTypeNode = {
    kind: SyntaxKind.ParenthesizedType,
    type: TypeNode
  } & TypeNode;

  declare export type TypeOperatorNode = {
    kind: SyntaxKind.TypeOperator,
    operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword,
    type: TypeNode
  } & TypeNode;

  declare export type IndexedAccessTypeNode = {
    kind: SyntaxKind.IndexedAccessType,
    objectType: TypeNode,
    indexType: TypeNode
  } & TypeNode;

  declare export type MappedTypeNode = {
    kind: SyntaxKind.MappedType,
    readonlyToken?: ReadonlyToken | PlusToken | MinusToken,
    typeParameter: TypeParameterDeclaration,
    questionToken?: QuestionToken | PlusToken | MinusToken,
    type?: TypeNode
  } & TypeNode &
    Declaration;

  declare export type LiteralTypeNode = {
    kind: SyntaxKind.LiteralType,
    literal: BooleanLiteral | LiteralExpression | PrefixUnaryExpression
  } & TypeNode;

  declare export type StringLiteral = {
    kind: SyntaxKind.StringLiteral
  } & LiteralExpression;

  declare export type StringLiteralLike =
    | StringLiteral
    | NoSubstitutionTemplateLiteral;
  declare export type Expression = {
    _expressionBrand: any
  } & Node;

  declare export type OmittedExpression = {
    kind: SyntaxKind.OmittedExpression
  } & Expression;

  declare export type PartiallyEmittedExpression = {
    kind: SyntaxKind.PartiallyEmittedExpression,
    expression: Expression
  } & LeftHandSideExpression;

  declare export type UnaryExpression = {
    _unaryExpressionBrand: any
  } & Expression;

  /**
   * Deprecated, please use UpdateExpression
   */
  declare export type IncrementExpression = UpdateExpression;
  declare export type UpdateExpression = {
    _updateExpressionBrand: any
  } & UnaryExpression;

  declare export type PrefixUnaryOperator =
    | SyntaxKind.PlusPlusToken
    | SyntaxKind.MinusMinusToken
    | SyntaxKind.PlusToken
    | SyntaxKind.MinusToken
    | SyntaxKind.TildeToken
    | SyntaxKind.ExclamationToken;
  declare export type PrefixUnaryExpression = {
    kind: SyntaxKind.PrefixUnaryExpression,
    operator: PrefixUnaryOperator,
    operand: UnaryExpression
  } & UpdateExpression;

  declare export type PostfixUnaryOperator =
    | SyntaxKind.PlusPlusToken
    | SyntaxKind.MinusMinusToken;
  declare export type PostfixUnaryExpression = {
    kind: SyntaxKind.PostfixUnaryExpression,
    operand: LeftHandSideExpression,
    operator: PostfixUnaryOperator
  } & UpdateExpression;

  declare export type LeftHandSideExpression = {
    _leftHandSideExpressionBrand: any
  } & UpdateExpression;

  declare export type MemberExpression = {
    _memberExpressionBrand: any
  } & LeftHandSideExpression;

  declare export type PrimaryExpression = {
    _primaryExpressionBrand: any
  } & MemberExpression;

  declare export type NullLiteral = {
    kind: SyntaxKind.NullKeyword
  } & PrimaryExpression &
    TypeNode;

  declare export type BooleanLiteral = {
    kind: SyntaxKind.TrueKeyword | SyntaxKind.FalseKeyword
  } & PrimaryExpression &
    TypeNode;

  declare export type ThisExpression = {
    kind: SyntaxKind.ThisKeyword
  } & PrimaryExpression &
    KeywordTypeNode;

  declare export type SuperExpression = {
    kind: SyntaxKind.SuperKeyword
  } & PrimaryExpression;

  declare export type ImportExpression = {
    kind: SyntaxKind.ImportKeyword
  } & PrimaryExpression;

  declare export type DeleteExpression = {
    kind: SyntaxKind.DeleteExpression,
    expression: UnaryExpression
  } & UnaryExpression;

  declare export type TypeOfExpression = {
    kind: SyntaxKind.TypeOfExpression,
    expression: UnaryExpression
  } & UnaryExpression;

  declare export type VoidExpression = {
    kind: SyntaxKind.VoidExpression,
    expression: UnaryExpression
  } & UnaryExpression;

  declare export type AwaitExpression = {
    kind: SyntaxKind.AwaitExpression,
    expression: UnaryExpression
  } & UnaryExpression;

  declare export type YieldExpression = {
    kind: SyntaxKind.YieldExpression,
    asteriskToken?: AsteriskToken,
    expression?: Expression
  } & Expression;

  declare export type SyntheticExpression = {
    kind: SyntaxKind.SyntheticExpression,
    isSpread: boolean,
    type: Type
  } & Expression;

  declare export type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;
  declare export type MultiplicativeOperator =
    | SyntaxKind.AsteriskToken
    | SyntaxKind.SlashToken
    | SyntaxKind.PercentToken;
  declare export type MultiplicativeOperatorOrHigher =
    | ExponentiationOperator
    | MultiplicativeOperator;
  declare export type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;
  declare export type AdditiveOperatorOrHigher =
    | MultiplicativeOperatorOrHigher
    | AdditiveOperator;
  declare export type ShiftOperator =
    | SyntaxKind.LessThanLessThanToken
    | SyntaxKind.GreaterThanGreaterThanToken
    | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;
  declare export type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;
  declare export type RelationalOperator =
    | SyntaxKind.LessThanToken
    | SyntaxKind.LessThanEqualsToken
    | SyntaxKind.GreaterThanToken
    | SyntaxKind.GreaterThanEqualsToken
    | SyntaxKind.InstanceOfKeyword
    | SyntaxKind.InKeyword;
  declare export type RelationalOperatorOrHigher =
    | ShiftOperatorOrHigher
    | RelationalOperator;
  declare export type EqualityOperator =
    | SyntaxKind.EqualsEqualsToken
    | SyntaxKind.EqualsEqualsEqualsToken
    | SyntaxKind.ExclamationEqualsEqualsToken
    | SyntaxKind.ExclamationEqualsToken;
  declare export type EqualityOperatorOrHigher =
    | RelationalOperatorOrHigher
    | EqualityOperator;
  declare export type BitwiseOperator =
    | SyntaxKind.AmpersandToken
    | SyntaxKind.BarToken
    | SyntaxKind.CaretToken;
  declare export type BitwiseOperatorOrHigher =
    | EqualityOperatorOrHigher
    | BitwiseOperator;
  declare export type LogicalOperator =
    | SyntaxKind.AmpersandAmpersandToken
    | SyntaxKind.BarBarToken;
  declare export type LogicalOperatorOrHigher =
    | BitwiseOperatorOrHigher
    | LogicalOperator;
  declare export type CompoundAssignmentOperator =
    | SyntaxKind.PlusEqualsToken
    | SyntaxKind.MinusEqualsToken
    | SyntaxKind.AsteriskAsteriskEqualsToken
    | SyntaxKind.AsteriskEqualsToken
    | SyntaxKind.SlashEqualsToken
    | SyntaxKind.PercentEqualsToken
    | SyntaxKind.AmpersandEqualsToken
    | SyntaxKind.BarEqualsToken
    | SyntaxKind.CaretEqualsToken
    | SyntaxKind.LessThanLessThanEqualsToken
    | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken
    | SyntaxKind.GreaterThanGreaterThanEqualsToken;
  declare export type AssignmentOperator =
    | SyntaxKind.EqualsToken
    | CompoundAssignmentOperator;
  declare export type AssignmentOperatorOrHigher =
    | LogicalOperatorOrHigher
    | AssignmentOperator;
  declare export type BinaryOperator =
    | AssignmentOperatorOrHigher
    | SyntaxKind.CommaToken;
  declare export type BinaryOperatorToken = Token<BinaryOperator>;
  declare export type BinaryExpression = {
    kind: SyntaxKind.BinaryExpression,
    left: Expression,
    operatorToken: BinaryOperatorToken,
    right: Expression
  } & Expression &
    Declaration;

  declare export type AssignmentOperatorToken = Token<AssignmentOperator>;
  declare export type AssignmentExpression<TOperator: AssignmentOperatorToken> = {
    left: LeftHandSideExpression,
    operatorToken: TOperator
  } & BinaryExpression;

  declare export type ObjectDestructuringAssignment = {
    left: ObjectLiteralExpression
  } & AssignmentExpression<EqualsToken>;

  declare export type ArrayDestructuringAssignment = {
    left: ArrayLiteralExpression
  } & AssignmentExpression<EqualsToken>;

  declare export type DestructuringAssignment =
    | ObjectDestructuringAssignment
    | ArrayDestructuringAssignment;
  declare export type BindingOrAssignmentElement =
    | VariableDeclaration
    | ParameterDeclaration
    | BindingElement
    | PropertyAssignment
    | ShorthandPropertyAssignment
    | SpreadAssignment
    | OmittedExpression
    | SpreadElement
    | ArrayLiteralExpression
    | ObjectLiteralExpression
    | AssignmentExpression<EqualsToken>
    | Identifier
    | PropertyAccessExpression
    | ElementAccessExpression;
  declare export type BindingOrAssignmentElementRestIndicator =
    | DotDotDotToken
    | SpreadElement
    | SpreadAssignment;
  declare export type BindingOrAssignmentElementTarget =
    | BindingOrAssignmentPattern
    | Identifier
    | PropertyAccessExpression
    | ElementAccessExpression
    | OmittedExpression;
  declare export type ObjectBindingOrAssignmentPattern =
    | ObjectBindingPattern
    | ObjectLiteralExpression;
  declare export type ArrayBindingOrAssignmentPattern =
    | ArrayBindingPattern
    | ArrayLiteralExpression;
  declare export type AssignmentPattern =
    | ObjectLiteralExpression
    | ArrayLiteralExpression;
  declare export type BindingOrAssignmentPattern =
    | ObjectBindingOrAssignmentPattern
    | ArrayBindingOrAssignmentPattern;
  declare export type ConditionalExpression = {
    kind: SyntaxKind.ConditionalExpression,
    condition: Expression,
    questionToken: QuestionToken,
    whenTrue: Expression,
    colonToken: ColonToken,
    whenFalse: Expression
  } & Expression;

  declare export type FunctionBody = Block;
  declare export type ConciseBody = FunctionBody | Expression;
  declare export type FunctionExpression = {
    kind: SyntaxKind.FunctionExpression,
    name?: Identifier,
    body: FunctionBody
  } & PrimaryExpression &
    FunctionLikeDeclarationBase &
    JSDocContainer;

  declare export type ArrowFunction = {
    kind: SyntaxKind.ArrowFunction,
    equalsGreaterThanToken: EqualsGreaterThanToken,
    body: ConciseBody,
    name: empty
  } & Expression &
    FunctionLikeDeclarationBase &
    JSDocContainer;

  declare export type LiteralLikeNode = {
    text: string,
    isUnterminated?: boolean,
    hasExtendedUnicodeEscape?: boolean
  } & Node;

  declare export type LiteralExpression = {
    _literalExpressionBrand: any
  } & LiteralLikeNode &
    PrimaryExpression;

  declare export type RegularExpressionLiteral = {
    kind: SyntaxKind.RegularExpressionLiteral
  } & LiteralExpression;

  declare export type NoSubstitutionTemplateLiteral = {
    kind: SyntaxKind.NoSubstitutionTemplateLiteral
  } & LiteralExpression;

  declare export type NumericLiteral = {
    kind: SyntaxKind.NumericLiteral
  } & LiteralExpression;

  declare export type BigIntLiteral = {
    kind: SyntaxKind.BigIntLiteral
  } & LiteralExpression;

  declare export type TemplateHead = {
    kind: SyntaxKind.TemplateHead,
    parent: TemplateExpression
  } & LiteralLikeNode;

  declare export type TemplateMiddle = {
    kind: SyntaxKind.TemplateMiddle,
    parent: TemplateSpan
  } & LiteralLikeNode;

  declare export type TemplateTail = {
    kind: SyntaxKind.TemplateTail,
    parent: TemplateSpan
  } & LiteralLikeNode;

  declare export type TemplateLiteral =
    | TemplateExpression
    | NoSubstitutionTemplateLiteral;
  declare export type TemplateExpression = {
    kind: SyntaxKind.TemplateExpression,
    head: TemplateHead,
    templateSpans: NodeArray<TemplateSpan>
  } & PrimaryExpression;

  declare export type TemplateSpan = {
    kind: SyntaxKind.TemplateSpan,
    parent: TemplateExpression,
    expression: Expression,
    literal: TemplateMiddle | TemplateTail
  } & Node;

  declare export type ParenthesizedExpression = {
    kind: SyntaxKind.ParenthesizedExpression,
    expression: Expression
  } & PrimaryExpression &
    JSDocContainer;

  declare export type ArrayLiteralExpression = {
    kind: SyntaxKind.ArrayLiteralExpression,
    elements: NodeArray<Expression>
  } & PrimaryExpression;

  declare export type SpreadElement = {
    kind: SyntaxKind.SpreadElement,
    parent: ArrayLiteralExpression | CallExpression | NewExpression,
    expression: Expression
  } & Expression;

  /**
 * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to
 * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be
JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type
ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)
*/
  declare export type ObjectLiteralExpressionBase<T: ObjectLiteralElement> = {
    properties: NodeArray<T>
  } & PrimaryExpression &
    Declaration;

  declare export type ObjectLiteralExpression = {
    kind: SyntaxKind.ObjectLiteralExpression
  } & ObjectLiteralExpressionBase<ObjectLiteralElementLike>;

  declare export type EntityNameExpression =
    | Identifier
    | PropertyAccessEntityNameExpression;
  declare export type EntityNameOrEntityNameExpression =
    | EntityName
    | EntityNameExpression;
  declare export type PropertyAccessExpression = {
    kind: SyntaxKind.PropertyAccessExpression,
    expression: LeftHandSideExpression,
    name: Identifier
  } & MemberExpression &
    NamedDeclaration;

  declare export type SuperPropertyAccessExpression = {
    expression: SuperExpression
  } & PropertyAccessExpression;

  /**
   * Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots.
   */
  declare export type PropertyAccessEntityNameExpression = {
    _propertyAccessExpressionLikeQualifiedNameBrand?: any,
    expression: EntityNameExpression
  } & PropertyAccessExpression;

  declare export type ElementAccessExpression = {
    kind: SyntaxKind.ElementAccessExpression,
    expression: LeftHandSideExpression,
    argumentExpression: Expression
  } & MemberExpression;

  declare export type SuperElementAccessExpression = {
    expression: SuperExpression
  } & ElementAccessExpression;

  declare export type SuperProperty =
    | SuperPropertyAccessExpression
    | SuperElementAccessExpression;
  declare export type CallExpression = {
    kind: SyntaxKind.CallExpression,
    expression: LeftHandSideExpression,
    typeArguments?: NodeArray<TypeNode>,
    arguments: NodeArray<Expression>
  } & LeftHandSideExpression &
    Declaration;

  declare export type SuperCall = {
    expression: SuperExpression
  } & CallExpression;

  declare export type ImportCall = {
    expression: ImportExpression
  } & CallExpression;

  declare export type ExpressionWithTypeArguments = {
    kind: SyntaxKind.ExpressionWithTypeArguments,
    parent: HeritageClause | JSDocAugmentsTag,
    expression: LeftHandSideExpression
  } & NodeWithTypeArguments;

  declare export type NewExpression = {
    kind: SyntaxKind.NewExpression,
    expression: LeftHandSideExpression,
    typeArguments?: NodeArray<TypeNode>,
    arguments?: NodeArray<Expression>
  } & PrimaryExpression &
    Declaration;

  declare export type TaggedTemplateExpression = {
    kind: SyntaxKind.TaggedTemplateExpression,
    tag: LeftHandSideExpression,
    typeArguments?: NodeArray<TypeNode>,
    template: TemplateLiteral
  } & MemberExpression;

  declare export type CallLikeExpression =
    | CallExpression
    | NewExpression
    | TaggedTemplateExpression
    | Decorator
    | JsxOpeningLikeElement;
  declare export type AsExpression = {
    kind: SyntaxKind.AsExpression,
    expression: Expression,
    type: TypeNode
  } & Expression;

  declare export type TypeAssertion = {
    kind: SyntaxKind.TypeAssertionExpression,
    type: TypeNode,
    expression: UnaryExpression
  } & UnaryExpression;

  declare export type AssertionExpression = TypeAssertion | AsExpression;
  declare export type NonNullExpression = {
    kind: SyntaxKind.NonNullExpression,
    expression: Expression
  } & LeftHandSideExpression;

  declare export type MetaProperty = {
    kind: SyntaxKind.MetaProperty,
    keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword,
    name: Identifier
  } & PrimaryExpression;

  declare export type JsxElement = {
    kind: SyntaxKind.JsxElement,
    openingElement: JsxOpeningElement,
    children: NodeArray<JsxChild>,
    closingElement: JsxClosingElement
  } & PrimaryExpression;

  declare export type JsxOpeningLikeElement =
    | JsxSelfClosingElement
    | JsxOpeningElement;
  declare export type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;
  declare export type JsxTagNameExpression =
    | Identifier
    | ThisExpression
    | JsxTagNamePropertyAccess;
  declare export type JsxTagNamePropertyAccess = {
    expression: JsxTagNameExpression
  } & PropertyAccessExpression;

  declare export type JsxAttributes = {
    parent: JsxOpeningLikeElement
  } & ObjectLiteralExpressionBase<JsxAttributeLike>;

  declare export type JsxOpeningElement = {
    kind: SyntaxKind.JsxOpeningElement,
    parent: JsxElement,
    tagName: JsxTagNameExpression,
    typeArguments?: NodeArray<TypeNode>,
    attributes: JsxAttributes
  } & Expression;

  declare export type JsxSelfClosingElement = {
    kind: SyntaxKind.JsxSelfClosingElement,
    tagName: JsxTagNameExpression,
    typeArguments?: NodeArray<TypeNode>,
    attributes: JsxAttributes
  } & PrimaryExpression;

  declare export type JsxFragment = {
    kind: SyntaxKind.JsxFragment,
    openingFragment: JsxOpeningFragment,
    children: NodeArray<JsxChild>,
    closingFragment: JsxClosingFragment
  } & PrimaryExpression;

  declare export type JsxOpeningFragment = {
    kind: SyntaxKind.JsxOpeningFragment,
    parent: JsxFragment
  } & Expression;

  declare export type JsxClosingFragment = {
    kind: SyntaxKind.JsxClosingFragment,
    parent: JsxFragment
  } & Expression;

  declare export type JsxAttribute = {
    kind: SyntaxKind.JsxAttribute,
    parent: JsxAttributes,
    name: Identifier,
    initializer?: StringLiteral | JsxExpression
  } & ObjectLiteralElement;

  declare export type JsxSpreadAttribute = {
    kind: SyntaxKind.JsxSpreadAttribute,
    parent: JsxAttributes,
    expression: Expression
  } & ObjectLiteralElement;

  declare export type JsxClosingElement = {
    kind: SyntaxKind.JsxClosingElement,
    parent: JsxElement,
    tagName: JsxTagNameExpression
  } & Node;

  declare export type JsxExpression = {
    kind: SyntaxKind.JsxExpression,
    parent: JsxElement | JsxAttributeLike,
    dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>,
    expression?: Expression
  } & Expression;

  declare export type JsxText = {
    kind: SyntaxKind.JsxText,
    containsOnlyWhiteSpaces: boolean,
    parent: JsxElement
  } & Node;

  declare export type JsxChild =
    | JsxText
    | JsxExpression
    | JsxElement
    | JsxSelfClosingElement
    | JsxFragment;
  declare export type Statement = {
    _statementBrand: any
  } & Node;

  declare export type NotEmittedStatement = {
    kind: SyntaxKind.NotEmittedStatement
  } & Statement;

  /**
   * A list of comma-separated expressions. This node is only created by transformations.
   */
  declare export type CommaListExpression = {
    kind: SyntaxKind.CommaListExpression,
    elements: NodeArray<Expression>
  } & Expression;

  declare export type EmptyStatement = {
    kind: SyntaxKind.EmptyStatement
  } & Statement;

  declare export type DebuggerStatement = {
    kind: SyntaxKind.DebuggerStatement
  } & Statement;

  declare export type MissingDeclaration = {
    kind: SyntaxKind.MissingDeclaration,
    name?: Identifier
  } & DeclarationStatement;

  declare export type BlockLike =
    | SourceFile
    | Block
    | ModuleBlock
    | CaseOrDefaultClause;
  declare export type Block = {
    kind: SyntaxKind.Block,
    statements: NodeArray<Statement>
  } & Statement;

  declare export type VariableStatement = {
    kind: SyntaxKind.VariableStatement,
    declarationList: VariableDeclarationList
  } & Statement &
    JSDocContainer;

  declare export type ExpressionStatement = {
    kind: SyntaxKind.ExpressionStatement,
    expression: Expression
  } & Statement &
    JSDocContainer;

  declare export type IfStatement = {
    kind: SyntaxKind.IfStatement,
    expression: Expression,
    thenStatement: Statement,
    elseStatement?: Statement
  } & Statement;

  declare export type IterationStatement = {
    statement: Statement
  } & Statement;

  declare export type DoStatement = {
    kind: SyntaxKind.DoStatement,
    expression: Expression
  } & IterationStatement;

  declare export type WhileStatement = {
    kind: SyntaxKind.WhileStatement,
    expression: Expression
  } & IterationStatement;

  declare export type ForInitializer = VariableDeclarationList | Expression;
  declare export type ForStatement = {
    kind: SyntaxKind.ForStatement,
    initializer?: ForInitializer,
    condition?: Expression,
    incrementor?: Expression
  } & IterationStatement;

  declare export type ForInOrOfStatement = ForInStatement | ForOfStatement;
  declare export type ForInStatement = {
    kind: SyntaxKind.ForInStatement,
    initializer: ForInitializer,
    expression: Expression
  } & IterationStatement;

  declare export type ForOfStatement = {
    kind: SyntaxKind.ForOfStatement,
    awaitModifier?: AwaitKeywordToken,
    initializer: ForInitializer,
    expression: Expression
  } & IterationStatement;

  declare export type BreakStatement = {
    kind: SyntaxKind.BreakStatement,
    label?: Identifier
  } & Statement;

  declare export type ContinueStatement = {
    kind: SyntaxKind.ContinueStatement,
    label?: Identifier
  } & Statement;

  declare export type BreakOrContinueStatement = BreakStatement | ContinueStatement;
  declare export type ReturnStatement = {
    kind: SyntaxKind.ReturnStatement,
    expression?: Expression
  } & Statement;

  declare export type WithStatement = {
    kind: SyntaxKind.WithStatement,
    expression: Expression,
    statement: Statement
  } & Statement;

  declare export type SwitchStatement = {
    kind: SyntaxKind.SwitchStatement,
    expression: Expression,
    caseBlock: CaseBlock,
    possiblyExhaustive?: boolean
  } & Statement;

  declare export type CaseBlock = {
    kind: SyntaxKind.CaseBlock,
    parent: SwitchStatement,
    clauses: NodeArray<CaseOrDefaultClause>
  } & Node;

  declare export type CaseClause = {
    kind: SyntaxKind.CaseClause,
    parent: CaseBlock,
    expression: Expression,
    statements: NodeArray<Statement>
  } & Node;

  declare export type DefaultClause = {
    kind: SyntaxKind.DefaultClause,
    parent: CaseBlock,
    statements: NodeArray<Statement>
  } & Node;

  declare export type CaseOrDefaultClause = CaseClause | DefaultClause;
  declare export type LabeledStatement = {
    kind: SyntaxKind.LabeledStatement,
    label: Identifier,
    statement: Statement
  } & Statement &
    JSDocContainer;

  declare export type ThrowStatement = {
    kind: SyntaxKind.ThrowStatement,
    expression?: Expression
  } & Statement;

  declare export type TryStatement = {
    kind: SyntaxKind.TryStatement,
    tryBlock: Block,
    catchClause?: CatchClause,
    finallyBlock?: Block
  } & Statement;

  declare export type CatchClause = {
    kind: SyntaxKind.CatchClause,
    parent: TryStatement,
    variableDeclaration?: VariableDeclaration,
    block: Block
  } & Node;

  declare export type ObjectTypeDeclaration =
    | ClassLikeDeclaration
    | InterfaceDeclaration
    | TypeLiteralNode;
  declare export type DeclarationWithTypeParameters =
    | DeclarationWithTypeParameterChildren
    | JSDocTypedefTag
    | JSDocCallbackTag
    | JSDocSignature;
  declare export type DeclarationWithTypeParameterChildren =
    | SignatureDeclaration
    | ClassLikeDeclaration
    | InterfaceDeclaration
    | TypeAliasDeclaration
    | JSDocTemplateTag;
  declare export type ClassLikeDeclarationBase = {
    kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression,
    name?: Identifier,
    typeParameters?: NodeArray<TypeParameterDeclaration>,
    heritageClauses?: NodeArray<HeritageClause>,
    members: NodeArray<ClassElement>
  } & NamedDeclaration &
    JSDocContainer;

  declare export type ClassDeclaration = {
    kind: SyntaxKind.ClassDeclaration,

    /**
     * May be undefined in `export default class { ... }`.
     */
    name?: Identifier
  } & ClassLikeDeclarationBase &
    DeclarationStatement;

  declare export type ClassExpression = {
    kind: SyntaxKind.ClassExpression
  } & ClassLikeDeclarationBase &
    PrimaryExpression;

  declare export type ClassLikeDeclaration = ClassDeclaration | ClassExpression;
  declare export type ClassElement = {
    _classElementBrand: any,
    name?: PropertyName
  } & NamedDeclaration;

  declare export type TypeElement = {
    _typeElementBrand: any,
    name?: PropertyName,
    questionToken?: QuestionToken
  } & NamedDeclaration;

  declare export type InterfaceDeclaration = {
    kind: SyntaxKind.InterfaceDeclaration,
    name: Identifier,
    typeParameters?: NodeArray<TypeParameterDeclaration>,
    heritageClauses?: NodeArray<HeritageClause>,
    members: NodeArray<TypeElement>
  } & DeclarationStatement &
    JSDocContainer;

  declare export type HeritageClause = {
    kind: SyntaxKind.HeritageClause,
    parent: InterfaceDeclaration | ClassLikeDeclaration,
    token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword,
    types: NodeArray<ExpressionWithTypeArguments>
  } & Node;

  declare export type TypeAliasDeclaration = {
    kind: SyntaxKind.TypeAliasDeclaration,
    name: Identifier,
    typeParameters?: NodeArray<TypeParameterDeclaration>,
    type: TypeNode
  } & DeclarationStatement &
    JSDocContainer;

  declare export type EnumMember = {
    kind: SyntaxKind.EnumMember,
    parent: EnumDeclaration,
    name: PropertyName,
    initializer?: Expression
  } & NamedDeclaration &
    JSDocContainer;

  declare export type EnumDeclaration = {
    kind: SyntaxKind.EnumDeclaration,
    name: Identifier,
    members: NodeArray<EnumMember>
  } & DeclarationStatement &
    JSDocContainer;

  declare export type ModuleName = Identifier | StringLiteral;
  declare export type ModuleBody = NamespaceBody | JSDocNamespaceBody;
  declare export type ModuleDeclaration = {
    kind: SyntaxKind.ModuleDeclaration,
    parent: ModuleBody | SourceFile,
    name: ModuleName,
    body?: ModuleBody | JSDocNamespaceDeclaration
  } & DeclarationStatement &
    JSDocContainer;

  declare export type NamespaceBody = ModuleBlock | NamespaceDeclaration;
  declare export type NamespaceDeclaration = {
    name: Identifier,
    body: NamespaceBody
  } & ModuleDeclaration;

  declare export type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;
  declare export type JSDocNamespaceDeclaration = {
    name: Identifier,
    body?: JSDocNamespaceBody
  } & ModuleDeclaration;

  declare export type ModuleBlock = {
    kind: SyntaxKind.ModuleBlock,
    parent: ModuleDeclaration,
    statements: NodeArray<Statement>
  } & Node &
    Statement;

  declare export type ModuleReference = EntityName | ExternalModuleReference;

  /**
 * One of:
 * - import x = require("mod");
- import x = M.x;
*/
  declare export type ImportEqualsDeclaration = {
    kind: SyntaxKind.ImportEqualsDeclaration,
    parent: SourceFile | ModuleBlock,
    name: Identifier,
    moduleReference: ModuleReference
  } & DeclarationStatement &
    JSDocContainer;

  declare export type ExternalModuleReference = {
    kind: SyntaxKind.ExternalModuleReference,
    parent: ImportEqualsDeclaration,
    expression: Expression
  } & Node;

  declare export type ImportDeclaration = {
    kind: SyntaxKind.ImportDeclaration,
    parent: SourceFile | ModuleBlock,
    importClause?: ImportClause,

    /**
     * If this is not a StringLiteral it will be a grammar error.
     */
    moduleSpecifier: Expression
  } & Statement;

  declare export type NamedImportBindings = NamespaceImport | NamedImports;
  declare export type ImportClause = {
    kind: SyntaxKind.ImportClause,
    parent: ImportDeclaration,
    name?: Identifier,
    namedBindings?: NamedImportBindings
  } & NamedDeclaration;

  declare export type NamespaceImport = {
    kind: SyntaxKind.NamespaceImport,
    parent: ImportClause,
    name: Identifier
  } & NamedDeclaration;

  declare export type NamespaceExportDeclaration = {
    kind: SyntaxKind.NamespaceExportDeclaration,
    name: Identifier
  } & DeclarationStatement;

  declare export type ExportDeclaration = {
    kind: SyntaxKind.ExportDeclaration,
    parent: SourceFile | ModuleBlock,

    /**
     * Will not be assigned in the case of `export * from "foo";`
     */
    exportClause?: NamedExports,

    /**
     * If this is not a StringLiteral it will be a grammar error.
     */
    moduleSpecifier?: Expression
  } & DeclarationStatement &
    JSDocContainer;

  declare export type NamedImports = {
    kind: SyntaxKind.NamedImports,
    parent: ImportClause,
    elements: NodeArray<ImportSpecifier>
  } & Node;

  declare export type NamedExports = {
    kind: SyntaxKind.NamedExports,
    parent: ExportDeclaration,
    elements: NodeArray<ExportSpecifier>
  } & Node;

  declare export type NamedImportsOrExports = NamedImports | NamedExports;
  declare export type ImportSpecifier = {
    kind: SyntaxKind.ImportSpecifier,
    parent: NamedImports,
    propertyName?: Identifier,
    name: Identifier
  } & NamedDeclaration;

  declare export type ExportSpecifier = {
    kind: SyntaxKind.ExportSpecifier,
    parent: NamedExports,
    propertyName?: Identifier,
    name: Identifier
  } & NamedDeclaration;

  declare export type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;

  /**
   * This is either an `export =` or an `export default` declaration.
   * Unless `isExportEquals` is set, this node was parsed as an `export default`.
   */
  declare export type ExportAssignment = {
    kind: SyntaxKind.ExportAssignment,
    parent: SourceFile,
    isExportEquals?: boolean,
    expression: Expression
  } & DeclarationStatement;

  declare export type FileReference = {
    fileName: string
  } & TextRange;

  declare export type CheckJsDirective = {
    enabled: boolean
  } & TextRange;

  declare export type CommentKind =
    | SyntaxKind.SingleLineCommentTrivia
    | SyntaxKind.MultiLineCommentTrivia;
  declare export type CommentRange = {
    hasTrailingNewLine?: boolean,
    kind: CommentKind
  } & TextRange;

  declare export type SynthesizedComment = {
    text: string,
    pos: -1,
    end: -1
  } & CommentRange;

  declare export type JSDocTypeExpression = {
    kind: SyntaxKind.JSDocTypeExpression,
    type: TypeNode
  } & TypeNode;

  declare export type JSDocType = {
    _jsDocTypeBrand: any
  } & TypeNode;

  declare export type JSDocAllType = {
    kind: SyntaxKind.JSDocAllType
  } & JSDocType;

  declare export type JSDocUnknownType = {
    kind: SyntaxKind.JSDocUnknownType
  } & JSDocType;

  declare export type JSDocNonNullableType = {
    kind: SyntaxKind.JSDocNonNullableType,
    type: TypeNode
  } & JSDocType;

  declare export type JSDocNullableType = {
    kind: SyntaxKind.JSDocNullableType,
    type: TypeNode
  } & JSDocType;

  declare export type JSDocOptionalType = {
    kind: SyntaxKind.JSDocOptionalType,
    type: TypeNode
  } & JSDocType;

  declare export type JSDocFunctionType = {
    kind: SyntaxKind.JSDocFunctionType
  } & JSDocType &
    SignatureDeclarationBase;

  declare export type JSDocVariadicType = {
    kind: SyntaxKind.JSDocVariadicType,
    type: TypeNode
  } & JSDocType;

  declare export type JSDocTypeReferencingNode =
    | JSDocVariadicType
    | JSDocOptionalType
    | JSDocNullableType
    | JSDocNonNullableType;
  declare export type JSDoc = {
    kind: SyntaxKind.JSDocComment,
    parent: HasJSDoc,
    tags?: NodeArray<JSDocTag>,
    comment?: string
  } & Node;

  declare export type JSDocTag = {
    parent: JSDoc | JSDocTypeLiteral,
    tagName: Identifier,
    comment?: string
  } & Node;

  declare export type JSDocUnknownTag = {
    kind: SyntaxKind.JSDocTag
  } & JSDocTag;

  /**
   * Note that `@extends` is a synonym of `@augments`.
   * Both tags are represented by this interface.
   */
  declare export type JSDocAugmentsTag = {
    kind: SyntaxKind.JSDocAugmentsTag,
    class: ExpressionWithTypeArguments & {
      expression: Identifier | PropertyAccessEntityNameExpression
    }
  } & JSDocTag;

  declare export type JSDocClassTag = {
    kind: SyntaxKind.JSDocClassTag
  } & JSDocTag;

  declare export type JSDocEnumTag = {
    kind: SyntaxKind.JSDocEnumTag,
    typeExpression?: JSDocTypeExpression
  } & JSDocTag;

  declare export type JSDocThisTag = {
    kind: SyntaxKind.JSDocThisTag,
    typeExpression?: JSDocTypeExpression
  } & JSDocTag;

  declare export type JSDocTemplateTag = {
    kind: SyntaxKind.JSDocTemplateTag,
    constraint: JSDocTypeExpression | void,
    typeParameters: NodeArray<TypeParameterDeclaration>
  } & JSDocTag;

  declare export type JSDocReturnTag = {
    kind: SyntaxKind.JSDocReturnTag,
    typeExpression?: JSDocTypeExpression
  } & JSDocTag;

  declare export type JSDocTypeTag = {
    kind: SyntaxKind.JSDocTypeTag,
    typeExpression?: JSDocTypeExpression
  } & JSDocTag;

  declare export type JSDocTypedefTag = {
    parent: JSDoc,
    kind: SyntaxKind.JSDocTypedefTag,
    fullName?: JSDocNamespaceDeclaration | Identifier,
    name?: Identifier,
    typeExpression?: JSDocTypeExpression | JSDocTypeLiteral
  } & JSDocTag &
    NamedDeclaration;

  declare export type JSDocCallbackTag = {
    parent: JSDoc,
    kind: SyntaxKind.JSDocCallbackTag,
    fullName?: JSDocNamespaceDeclaration | Identifier,
    name?: Identifier,
    typeExpression: JSDocSignature
  } & JSDocTag &
    NamedDeclaration;

  declare export type JSDocSignature = {
    kind: SyntaxKind.JSDocSignature,
    typeParameters?: $ReadOnlyArray<JSDocTemplateTag>,
    parameters: $ReadOnlyArray<JSDocParameterTag>,
    type: JSDocReturnTag | void
  } & JSDocType &
    Declaration;

  declare export type JSDocPropertyLikeTag = {
    parent: JSDoc,
    name: EntityName,
    typeExpression?: JSDocTypeExpression,

    /**
     * Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like
     */
    isNameFirst: boolean,
    isBracketed: boolean
  } & JSDocTag &
    Declaration;

  declare export type JSDocPropertyTag = {
    kind: SyntaxKind.JSDocPropertyTag
  } & JSDocPropertyLikeTag;

  declare export type JSDocParameterTag = {
    kind: SyntaxKind.JSDocParameterTag
  } & JSDocPropertyLikeTag;

  declare export type JSDocTypeLiteral = {
    kind: SyntaxKind.JSDocTypeLiteral,
    jsDocPropertyTags?: $ReadOnlyArray<JSDocPropertyLikeTag>,

    /**
     * If true, then this type literal represents an *array* of its type.
     */
    isArrayType?: boolean
  } & JSDocType;

  declare class FlowFlags__Unreachable mixins FlowFlags {}
  declare class FlowFlags__Start mixins FlowFlags {}
  declare class FlowFlags__BranchLabel mixins FlowFlags {}
  declare class FlowFlags__LoopLabel mixins FlowFlags {}
  declare class FlowFlags__Assignment mixins FlowFlags {}
  declare class FlowFlags__TrueCondition mixins FlowFlags {}
  declare class FlowFlags__FalseCondition mixins FlowFlags {}
  declare class FlowFlags__SwitchClause mixins FlowFlags {}
  declare class FlowFlags__ArrayMutation mixins FlowFlags {}
  declare class FlowFlags__Referenced mixins FlowFlags {}
  declare class FlowFlags__Shared mixins FlowFlags {}
  declare class FlowFlags__PreFinally mixins FlowFlags {}
  declare class FlowFlags__AfterFinally mixins FlowFlags {}
  declare class FlowFlags__Label mixins FlowFlags {}
  declare class FlowFlags__Condition mixins FlowFlags {}

  declare export class FlowFlags {
    constructor(...args: empty): mixed;
    static Unreachable: Class<FlowFlags__Unreachable> &
      FlowFlags__Unreachable &
      1; // 1
    static Start: Class<FlowFlags__Start> & FlowFlags__Start & 2; // 2
    static BranchLabel: Class<FlowFlags__BranchLabel> &
      FlowFlags__BranchLabel &
      4; // 4
    static LoopLabel: Class<FlowFlags__LoopLabel> & FlowFlags__LoopLabel & 8; // 8
    static Assignment: Class<FlowFlags__Assignment> &
      FlowFlags__Assignment &
      16; // 16
    static TrueCondition: Class<FlowFlags__TrueCondition> &
      FlowFlags__TrueCondition &
      32; // 32
    static FalseCondition: Class<FlowFlags__FalseCondition> &
      FlowFlags__FalseCondition &
      64; // 64
    static SwitchClause: Class<FlowFlags__SwitchClause> &
      FlowFlags__SwitchClause &
      128; // 128
    static ArrayMutation: Class<FlowFlags__ArrayMutation> &
      FlowFlags__ArrayMutation &
      256; // 256
    static Referenced: Class<FlowFlags__Referenced> &
      FlowFlags__Referenced &
      512; // 512
    static Shared: Class<FlowFlags__Shared> & FlowFlags__Shared & 1024; // 1024
    static PreFinally: Class<FlowFlags__PreFinally> &
      FlowFlags__PreFinally &
      2048; // 2048
    static AfterFinally: Class<FlowFlags__AfterFinally> &
      FlowFlags__AfterFinally &
      4096; // 4096
    static Label: Class<FlowFlags__Label> & FlowFlags__Label & 12; // 12
    static Condition: Class<FlowFlags__Condition> & FlowFlags__Condition & 96; // 96
  }

  declare export interface FlowLock {
    locked?: boolean;
  }
  declare export type AfterFinallyFlow = {
    antecedent: FlowNode
  } & FlowNodeBase &
    FlowLock;

  declare export type PreFinallyFlow = {
    antecedent: FlowNode,
    lock: FlowLock
  } & FlowNodeBase;

  declare export type FlowNode =
    | AfterFinallyFlow
    | PreFinallyFlow
    | FlowStart
    | FlowLabel
    | FlowAssignment
    | FlowCondition
    | FlowSwitchClause
    | FlowArrayMutation;
  declare export interface FlowNodeBase {
    flags: FlowFlags;
    id?: number;
  }
  declare export type FlowStart = {
    container?: FunctionExpression | ArrowFunction | MethodDeclaration
  } & FlowNodeBase;

  declare export type FlowLabel = {
    antecedents: FlowNode[] | void
  } & FlowNodeBase;

  declare export type FlowAssignment = {
    node: Expression | VariableDeclaration | BindingElement,
    antecedent: FlowNode
  } & FlowNodeBase;

  declare export type FlowCondition = {
    expression: Expression,
    antecedent: FlowNode
  } & FlowNodeBase;

  declare export type FlowSwitchClause = {
    switchStatement: SwitchStatement,
    clauseStart: number,
    clauseEnd: number,
    antecedent: FlowNode
  } & FlowNodeBase;

  declare export type FlowArrayMutation = {
    node: CallExpression | BinaryExpression,
    antecedent: FlowNode
  } & FlowNodeBase;

  declare export type FlowType = Type | IncompleteType;
  declare export interface IncompleteType {
    flags: TypeFlags;
    type: Type;
  }
  declare export interface AmdDependency {
    path: string;
    name?: string;
  }
  declare export type SourceFile = {
    kind: SyntaxKind.SourceFile,
    statements: NodeArray<Statement>,
    endOfFileToken: Token<SyntaxKind.EndOfFileToken>,
    fileName: string,
    text: string,
    amdDependencies: $ReadOnlyArray<AmdDependency>,
    moduleName?: string,
    referencedFiles: $ReadOnlyArray<FileReference>,
    typeReferenceDirectives: $ReadOnlyArray<FileReference>,
    libReferenceDirectives: $ReadOnlyArray<FileReference>,
    languageVariant: LanguageVariant,
    isDeclarationFile: boolean,

    /**
 * lib.d.ts should have a reference comment like
 * 
  /// <reference no-default-lib="true"/>

If any other file has this comment, it signals not to include lib.d.ts
because this containing file is intended to act as a default library.
*/
    hasNoDefaultLib: boolean,
    languageVersion: ScriptTarget,
    getLineAndCharacterOfPosition(pos: number): LineAndCharacter,
    getLineEndOfPosition(pos: number): number,
    getLineStarts(): $ReadOnlyArray<number>,
    getPositionOfLineAndCharacter(line: number, character: number): number,
    update(newText: string, textChangeRange: TextChangeRange): SourceFile
  } & Declaration;

  declare export type Bundle = {
    kind: SyntaxKind.Bundle,
    prepends: $ReadOnlyArray<InputFiles | UnparsedSource>,
    sourceFiles: $ReadOnlyArray<SourceFile>
  } & Node;

  declare export type InputFiles = {
    kind: SyntaxKind.InputFiles,
    javascriptPath?: string,
    javascriptText: string,
    javascriptMapPath?: string,
    javascriptMapText?: string,
    declarationPath?: string,
    declarationText: string,
    declarationMapPath?: string,
    declarationMapText?: string
  } & Node;

  declare export type UnparsedSource = {
    kind: SyntaxKind.UnparsedSource,
    fileName?: string,
    text: string,
    sourceMapPath?: string,
    sourceMapText?: string
  } & Node;

  declare export type JsonSourceFile = {
    statements: NodeArray<JsonObjectExpressionStatement>
  } & SourceFile;

  declare export type TsConfigSourceFile = {
    extendedSourceFiles?: string[]
  } & JsonSourceFile;

  declare export type JsonMinusNumericLiteral = {
    kind: SyntaxKind.PrefixUnaryExpression,
    operator: SyntaxKind.MinusToken,
    operand: NumericLiteral
  } & PrefixUnaryExpression;

  declare export type JsonObjectExpressionStatement = {
    expression:
      | ObjectLiteralExpression
      | ArrayLiteralExpression
      | JsonMinusNumericLiteral
      | NumericLiteral
      | StringLiteral
      | BooleanLiteral
      | NullLiteral
  } & ExpressionStatement;

  declare export interface ScriptReferenceHost {
    getCompilerOptions(): CompilerOptions;
    getSourceFile(fileName: string): SourceFile | void;
    getSourceFileByPath(path: Path): SourceFile | void;
    getCurrentDirectory(): string;
  }
  declare export interface ParseConfigHost {
    useCaseSensitiveFileNames: boolean;
    readDirectory(
      rootDir: string,
      extensions: $ReadOnlyArray<string>,
      excludes: $ReadOnlyArray<string> | void,
      includes: $ReadOnlyArray<string>,
      depth?: number
    ): $ReadOnlyArray<string>;

    /**
     * Gets a value indicating whether the specified path exists and is a file.
     * @param path The path to test.
     */
    fileExists(path: string): boolean;
    readFile(path: string): string | void;
    trace(s: string): void;
  }

  /**
 * Branded string for keeping track of when we've turned an ambiguous path
 * specified like "./blah" to an absolute path to an actual
tsconfig file, e.g. "/root/blah/tsconfig.json"
*/
  declare export type ResolvedConfigFileName = string & {
    _isResolvedConfigFileName: empty
  };
  declare export type WriteFileCallback = (
    fileName: string,
    data: string,
    writeByteOrderMark: boolean,
    onError?: (message: string) => void,
    sourceFiles?: $ReadOnlyArray<SourceFile>
  ) => void;
  declare export class OperationCanceledException {}
  declare export interface CancellationToken {
    isCancellationRequested(): boolean;

    /**
     *
     * @throws OperationCanceledException if isCancellationRequested is true
     */
    throwIfCancellationRequested(): void;
  }
  declare export type Program = {
    /**
     * Get a list of root file names that were passed to a 'createProgram'
     */
    getRootFileNames(): $ReadOnlyArray<string>,

    /**
     * Get a list of files in the program
     */
    getSourceFiles(): $ReadOnlyArray<SourceFile>,

    /**
 * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then
 * the JavaScript and declaration files will be produced for all the files in this program.
If targetSourceFile is specified, then only the JavaScript and declaration for that
specific file will be generated.

If writeFile is not specified then the writeFile callback from the compiler host will be
used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter
will be invoked when writing the JavaScript and declaration files.
*/
    emit(
      targetSourceFile?: SourceFile,
      writeFile?: WriteFileCallback,
      cancellationToken?: CancellationToken,
      emitOnlyDtsFiles?: boolean,
      customTransformers?: CustomTransformers
    ): EmitResult,
    getOptionsDiagnostics(
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<Diagnostic>,
    getGlobalDiagnostics(
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<Diagnostic>,
    getSyntacticDiagnostics(
      sourceFile?: SourceFile,
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<DiagnosticWithLocation>,

    /**
     * The first time this is called, it will return global diagnostics (no location).
     */
    getSemanticDiagnostics(
      sourceFile?: SourceFile,
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<Diagnostic>,
    getDeclarationDiagnostics(
      sourceFile?: SourceFile,
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<DiagnosticWithLocation>,
    getConfigFileParsingDiagnostics(): $ReadOnlyArray<Diagnostic>,

    /**
     * Gets a type checker that can be used to semantically analyze source files in the program.
     */
    getTypeChecker(): TypeChecker,
    isSourceFileFromExternalLibrary(file: SourceFile): boolean,
    isSourceFileDefaultLibrary(file: SourceFile): boolean,
    getProjectReferences(): $ReadOnlyArray<ProjectReference> | void,
    getResolvedProjectReferences(): $ReadOnlyArray<ResolvedProjectReference | void> | void
  } & ScriptReferenceHost;

  declare export interface ResolvedProjectReference {
    commandLine: ParsedCommandLine;
    sourceFile: SourceFile;
    references?: $ReadOnlyArray<ResolvedProjectReference | void>;
  }
  declare export interface CustomTransformers {
    /**
     * Custom transformers to evaluate before built-in .js transformations.
     */
    before?: TransformerFactory<SourceFile>[];

    /**
     * Custom transformers to evaluate after built-in .js transformations.
     */
    after?: TransformerFactory<SourceFile>[];

    /**
     * Custom transformers to evaluate after built-in .d.ts transformations.
     */
    afterDeclarations?: TransformerFactory<Bundle | SourceFile>[];
  }
  declare export interface SourceMapSpan {
    /**
     * Line number in the .js file.
     */
    emittedLine: number;

    /**
     * Column number in the .js file.
     */
    emittedColumn: number;

    /**
     * Line number in the .ts file.
     */
    sourceLine: number;

    /**
     * Column number in the .ts file.
     */
    sourceColumn: number;

    /**
     * Optional name (index into names array) associated with this span.
     */
    nameIndex?: number;

    /**
     * .ts file (index into sources array) associated with this span
     */
    sourceIndex: number;
  }

  /**
   * Return code used by getEmitOutput function to indicate status of the function
   */
  declare class ExitStatus__Success mixins ExitStatus {}
  declare class ExitStatus__DiagnosticsPresent_OutputsSkipped
    mixins ExitStatus {}
  declare class ExitStatus__DiagnosticsPresent_OutputsGenerated
    mixins ExitStatus {}

  declare export class ExitStatus {
    constructor(...args: empty): mixed;
    static Success: Class<ExitStatus__Success> & ExitStatus__Success & 0; // 0
    static DiagnosticsPresent_OutputsSkipped: Class<ExitStatus__DiagnosticsPresent_OutputsSkipped> &
      ExitStatus__DiagnosticsPresent_OutputsSkipped &
      1; // 1
    static DiagnosticsPresent_OutputsGenerated: Class<ExitStatus__DiagnosticsPresent_OutputsGenerated> &
      ExitStatus__DiagnosticsPresent_OutputsGenerated &
      2; // 2
  }

  declare export interface EmitResult {
    emitSkipped: boolean;

    /**
     * Contains declaration emit diagnostics
     */
    diagnostics: $ReadOnlyArray<Diagnostic>;
    emittedFiles?: string[];
  }
  declare export interface TypeChecker {
    getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;
    getDeclaredTypeOfSymbol(symbol: Symbol): Type;
    getPropertiesOfType(type: Type): Symbol[];
    getPropertyOfType(type: Type, propertyName: string): Symbol | void;
    getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | void;
    getSignaturesOfType(
      type: Type,
      kind: SignatureKind
    ): $ReadOnlyArray<Signature>;
    getIndexTypeOfType(type: Type, kind: IndexKind): Type | void;
    getBaseTypes(type: InterfaceType): BaseType[];
    getBaseTypeOfLiteralType(type: Type): Type;
    getWidenedType(type: Type): Type;
    getReturnTypeOfSignature(signature: Signature): Type;
    getNullableType(type: Type, flags: TypeFlags): Type;
    getNonNullableType(type: Type): Type;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    typeToTypeNode(
      type: Type,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ): TypeNode | void;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    signatureToSignatureDeclaration(
      signature: Signature,
      kind: SyntaxKind,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ):
      | (SignatureDeclaration & {
          typeArguments?: NodeArray<TypeNode>
        })
      | void;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    indexInfoToIndexSignatureDeclaration(
      indexInfo: IndexInfo,
      kind: IndexKind,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ): IndexSignatureDeclaration | void;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    symbolToEntityName(
      symbol: Symbol,
      meaning: SymbolFlags,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ): EntityName | void;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    symbolToExpression(
      symbol: Symbol,
      meaning: SymbolFlags,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ): Expression | void;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    symbolToTypeParameterDeclarations(
      symbol: Symbol,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ): NodeArray<TypeParameterDeclaration> | void;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    symbolToParameterDeclaration(
      symbol: Symbol,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ): ParameterDeclaration | void;

    /**
     * Note that the resulting nodes cannot be checked.
     */
    typeParameterToDeclaration(
      parameter: TypeParameter,
      enclosingDeclaration?: Node,
      flags?: NodeBuilderFlags
    ): TypeParameterDeclaration | void;
    getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];
    getSymbolAtLocation(node: Node): Symbol | void;
    getSymbolsOfParameterPropertyDeclaration(
      parameter: ParameterDeclaration,
      parameterName: string
    ): Symbol[];

    /**
     * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.
     * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.
     */
    getShorthandAssignmentValueSymbol(location: Node): Symbol | void;
    getExportSpecifierLocalTargetSymbol(
      location: ExportSpecifier
    ): Symbol | void;

    /**
 * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.
 * Otherwise returns its input.
For example, at `export type T = number;`:
     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.
     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.
     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.
*/
    getExportSymbolOfSymbol(symbol: Symbol): Symbol;
    getPropertySymbolOfDestructuringAssignment(
      location: Identifier
    ): Symbol | void;
    getTypeAtLocation(node: Node): Type;
    getTypeFromTypeNode(node: TypeNode): Type;
    signatureToString(
      signature: Signature,
      enclosingDeclaration?: Node,
      flags?: TypeFormatFlags,
      kind?: SignatureKind
    ): string;
    typeToString(
      type: Type,
      enclosingDeclaration?: Node,
      flags?: TypeFormatFlags
    ): string;
    symbolToString(
      symbol: Symbol,
      enclosingDeclaration?: Node,
      meaning?: SymbolFlags,
      flags?: SymbolFormatFlags
    ): string;
    typePredicateToString(
      predicate: TypePredicate,
      enclosingDeclaration?: Node,
      flags?: TypeFormatFlags
    ): string;
    getFullyQualifiedName(symbol: Symbol): string;
    getAugmentedPropertiesOfType(type: Type): Symbol[];
    getRootSymbols(symbol: Symbol): $ReadOnlyArray<Symbol>;
    getContextualType(node: Expression): Type | void;

    /**
     * returns unknownSignature in the case of an error.
     * returns undefined if the node is not valid.
     * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.
     */
    getResolvedSignature(
      node: CallLikeExpression,
      candidatesOutArray?: Signature[],
      argumentCount?: number
    ): Signature | void;
    getSignatureFromDeclaration(
      declaration: SignatureDeclaration
    ): Signature | void;
    isImplementationOfOverload(node: SignatureDeclaration): boolean | void;
    isUndefinedSymbol(symbol: Symbol): boolean;
    isArgumentsSymbol(symbol: Symbol): boolean;
    isUnknownSymbol(symbol: Symbol): boolean;
    getConstantValue(
      node: EnumMember | PropertyAccessExpression | ElementAccessExpression
    ): string | number | void;
    isValidPropertyAccess(
      node: PropertyAccessExpression | QualifiedName | ImportTypeNode,
      propertyName: string
    ): boolean;

    /**
     * Follow all aliases to get the original symbol.
     */
    getAliasedSymbol(symbol: Symbol): Symbol;
    getExportsOfModule(moduleSymbol: Symbol): Symbol[];
    getJsxIntrinsicTagNamesAt(location: Node): Symbol[];
    isOptionalParameter(node: ParameterDeclaration): boolean;
    getAmbientModules(): Symbol[];
    tryGetMemberInModuleExports(
      memberName: string,
      moduleSymbol: Symbol
    ): Symbol | void;
    getApparentType(type: Type): Type;
    getBaseConstraintOfType(type: Type): Type | void;
    getDefaultFromTypeParameter(type: Type): Type | void;

    /**
 * Depending on the operation performed, it may be appropriate to throw away the checker
 * if the cancellation token is triggered. Typically, if it is used for error checking
and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.
*/
    runWithCancellationToken<T>(
      token: CancellationToken,
      cb: (checker: TypeChecker) => T
    ): T;
  }
  declare class NodeBuilderFlags__None mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__NoTruncation mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__WriteArrayAsGenericType
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__GenerateNamesForShadowedTypeParams
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__UseStructuralFallback
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__ForbidIndexedAccessSymbolReferences
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__WriteTypeArgumentsOfSignature
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__UseFullyQualifiedType
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__UseOnlyExternalAliasing
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__SuppressAnyReturnType
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__WriteTypeParametersInQualifiedName
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__MultilineObjectLiterals
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__WriteClassExpressionAsTypeLiteral
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__UseTypeOfFunction mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__OmitParameterModifiers
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__UseAliasDefinedOutsideCurrentScope
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowThisInObjectLiteral
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowQualifedNameInPlaceOfIdentifier
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowAnonymousIdentifier
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowEmptyUnionOrIntersection
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowEmptyTuple mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowUniqueESSymbolType
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowEmptyIndexInfoType
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__AllowNodeModulesRelativePaths
    mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__IgnoreErrors mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__InObjectTypeLiteral mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__InTypeAlias mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__InInitialEntityName mixins NodeBuilderFlags {}
  declare class NodeBuilderFlags__InReverseMappedType mixins NodeBuilderFlags {}

  declare export class NodeBuilderFlags {
    constructor(...args: empty): mixed;
    static None: Class<NodeBuilderFlags__None> & NodeBuilderFlags__None & 0; // 0
    static NoTruncation: Class<NodeBuilderFlags__NoTruncation> &
      NodeBuilderFlags__NoTruncation &
      1; // 1
    static WriteArrayAsGenericType: Class<NodeBuilderFlags__WriteArrayAsGenericType> &
      NodeBuilderFlags__WriteArrayAsGenericType &
      2; // 2
    static GenerateNamesForShadowedTypeParams: Class<NodeBuilderFlags__GenerateNamesForShadowedTypeParams> &
      NodeBuilderFlags__GenerateNamesForShadowedTypeParams &
      4; // 4
    static UseStructuralFallback: Class<NodeBuilderFlags__UseStructuralFallback> &
      NodeBuilderFlags__UseStructuralFallback &
      8; // 8
    static ForbidIndexedAccessSymbolReferences: Class<NodeBuilderFlags__ForbidIndexedAccessSymbolReferences> &
      NodeBuilderFlags__ForbidIndexedAccessSymbolReferences &
      16; // 16
    static WriteTypeArgumentsOfSignature: Class<NodeBuilderFlags__WriteTypeArgumentsOfSignature> &
      NodeBuilderFlags__WriteTypeArgumentsOfSignature &
      32; // 32
    static UseFullyQualifiedType: Class<NodeBuilderFlags__UseFullyQualifiedType> &
      NodeBuilderFlags__UseFullyQualifiedType &
      64; // 64
    static UseOnlyExternalAliasing: Class<NodeBuilderFlags__UseOnlyExternalAliasing> &
      NodeBuilderFlags__UseOnlyExternalAliasing &
      128; // 128
    static SuppressAnyReturnType: Class<NodeBuilderFlags__SuppressAnyReturnType> &
      NodeBuilderFlags__SuppressAnyReturnType &
      256; // 256
    static WriteTypeParametersInQualifiedName: Class<NodeBuilderFlags__WriteTypeParametersInQualifiedName> &
      NodeBuilderFlags__WriteTypeParametersInQualifiedName &
      512; // 512
    static MultilineObjectLiterals: Class<NodeBuilderFlags__MultilineObjectLiterals> &
      NodeBuilderFlags__MultilineObjectLiterals &
      1024; // 1024
    static WriteClassExpressionAsTypeLiteral: Class<NodeBuilderFlags__WriteClassExpressionAsTypeLiteral> &
      NodeBuilderFlags__WriteClassExpressionAsTypeLiteral &
      2048; // 2048
    static UseTypeOfFunction: Class<NodeBuilderFlags__UseTypeOfFunction> &
      NodeBuilderFlags__UseTypeOfFunction &
      4096; // 4096
    static OmitParameterModifiers: Class<NodeBuilderFlags__OmitParameterModifiers> &
      NodeBuilderFlags__OmitParameterModifiers &
      8192; // 8192
    static UseAliasDefinedOutsideCurrentScope: Class<NodeBuilderFlags__UseAliasDefinedOutsideCurrentScope> &
      NodeBuilderFlags__UseAliasDefinedOutsideCurrentScope &
      16384; // 16384
    static AllowThisInObjectLiteral: Class<NodeBuilderFlags__AllowThisInObjectLiteral> &
      NodeBuilderFlags__AllowThisInObjectLiteral &
      32768; // 32768
    static AllowQualifedNameInPlaceOfIdentifier: Class<NodeBuilderFlags__AllowQualifedNameInPlaceOfIdentifier> &
      NodeBuilderFlags__AllowQualifedNameInPlaceOfIdentifier &
      65536; // 65536
    static AllowAnonymousIdentifier: Class<NodeBuilderFlags__AllowAnonymousIdentifier> &
      NodeBuilderFlags__AllowAnonymousIdentifier &
      131072; // 131072
    static AllowEmptyUnionOrIntersection: Class<NodeBuilderFlags__AllowEmptyUnionOrIntersection> &
      NodeBuilderFlags__AllowEmptyUnionOrIntersection &
      262144; // 262144
    static AllowEmptyTuple: Class<NodeBuilderFlags__AllowEmptyTuple> &
      NodeBuilderFlags__AllowEmptyTuple &
      524288; // 524288
    static AllowUniqueESSymbolType: Class<NodeBuilderFlags__AllowUniqueESSymbolType> &
      NodeBuilderFlags__AllowUniqueESSymbolType &
      1048576; // 1048576
    static AllowEmptyIndexInfoType: Class<NodeBuilderFlags__AllowEmptyIndexInfoType> &
      NodeBuilderFlags__AllowEmptyIndexInfoType &
      2097152; // 2097152
    static AllowNodeModulesRelativePaths: Class<NodeBuilderFlags__AllowNodeModulesRelativePaths> &
      NodeBuilderFlags__AllowNodeModulesRelativePaths &
      67108864; // 67108864
    static IgnoreErrors: Class<NodeBuilderFlags__IgnoreErrors> &
      NodeBuilderFlags__IgnoreErrors &
      70221824; // 70221824
    static InObjectTypeLiteral: Class<NodeBuilderFlags__InObjectTypeLiteral> &
      NodeBuilderFlags__InObjectTypeLiteral &
      4194304; // 4194304
    static InTypeAlias: Class<NodeBuilderFlags__InTypeAlias> &
      NodeBuilderFlags__InTypeAlias &
      8388608; // 8388608
    static InInitialEntityName: Class<NodeBuilderFlags__InInitialEntityName> &
      NodeBuilderFlags__InInitialEntityName &
      16777216; // 16777216
    static InReverseMappedType: Class<NodeBuilderFlags__InReverseMappedType> &
      NodeBuilderFlags__InReverseMappedType &
      33554432; // 33554432
  }

  declare class TypeFormatFlags__None mixins TypeFormatFlags {}
  declare class TypeFormatFlags__NoTruncation mixins TypeFormatFlags {}
  declare class TypeFormatFlags__WriteArrayAsGenericType
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__UseStructuralFallback mixins TypeFormatFlags {}
  declare class TypeFormatFlags__WriteTypeArgumentsOfSignature
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__UseFullyQualifiedType mixins TypeFormatFlags {}
  declare class TypeFormatFlags__SuppressAnyReturnType mixins TypeFormatFlags {}
  declare class TypeFormatFlags__MultilineObjectLiterals
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__WriteClassExpressionAsTypeLiteral
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__UseTypeOfFunction mixins TypeFormatFlags {}
  declare class TypeFormatFlags__OmitParameterModifiers
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__UseAliasDefinedOutsideCurrentScope
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__AllowUniqueESSymbolType
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__AddUndefined mixins TypeFormatFlags {}
  declare class TypeFormatFlags__WriteArrowStyleSignature
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__InArrayType mixins TypeFormatFlags {}
  declare class TypeFormatFlags__InElementType mixins TypeFormatFlags {}
  declare class TypeFormatFlags__InFirstTypeArgument mixins TypeFormatFlags {}
  declare class TypeFormatFlags__InTypeAlias mixins TypeFormatFlags {}
  declare class TypeFormatFlags__WriteOwnNameForAnyLike
    mixins TypeFormatFlags {}
  declare class TypeFormatFlags__NodeBuilderFlagsMask mixins TypeFormatFlags {}

  declare export class TypeFormatFlags {
    constructor(...args: empty): mixed;
    static None: Class<TypeFormatFlags__None> & TypeFormatFlags__None & 0; // 0
    static NoTruncation: Class<TypeFormatFlags__NoTruncation> &
      TypeFormatFlags__NoTruncation &
      1; // 1
    static WriteArrayAsGenericType: Class<TypeFormatFlags__WriteArrayAsGenericType> &
      TypeFormatFlags__WriteArrayAsGenericType &
      2; // 2
    static UseStructuralFallback: Class<TypeFormatFlags__UseStructuralFallback> &
      TypeFormatFlags__UseStructuralFallback &
      8; // 8
    static WriteTypeArgumentsOfSignature: Class<TypeFormatFlags__WriteTypeArgumentsOfSignature> &
      TypeFormatFlags__WriteTypeArgumentsOfSignature &
      32; // 32
    static UseFullyQualifiedType: Class<TypeFormatFlags__UseFullyQualifiedType> &
      TypeFormatFlags__UseFullyQualifiedType &
      64; // 64
    static SuppressAnyReturnType: Class<TypeFormatFlags__SuppressAnyReturnType> &
      TypeFormatFlags__SuppressAnyReturnType &
      256; // 256
    static MultilineObjectLiterals: Class<TypeFormatFlags__MultilineObjectLiterals> &
      TypeFormatFlags__MultilineObjectLiterals &
      1024; // 1024
    static WriteClassExpressionAsTypeLiteral: Class<TypeFormatFlags__WriteClassExpressionAsTypeLiteral> &
      TypeFormatFlags__WriteClassExpressionAsTypeLiteral &
      2048; // 2048
    static UseTypeOfFunction: Class<TypeFormatFlags__UseTypeOfFunction> &
      TypeFormatFlags__UseTypeOfFunction &
      4096; // 4096
    static OmitParameterModifiers: Class<TypeFormatFlags__OmitParameterModifiers> &
      TypeFormatFlags__OmitParameterModifiers &
      8192; // 8192
    static UseAliasDefinedOutsideCurrentScope: Class<TypeFormatFlags__UseAliasDefinedOutsideCurrentScope> &
      TypeFormatFlags__UseAliasDefinedOutsideCurrentScope &
      16384; // 16384
    static AllowUniqueESSymbolType: Class<TypeFormatFlags__AllowUniqueESSymbolType> &
      TypeFormatFlags__AllowUniqueESSymbolType &
      1048576; // 1048576
    static AddUndefined: Class<TypeFormatFlags__AddUndefined> &
      TypeFormatFlags__AddUndefined &
      131072; // 131072
    static WriteArrowStyleSignature: Class<TypeFormatFlags__WriteArrowStyleSignature> &
      TypeFormatFlags__WriteArrowStyleSignature &
      262144; // 262144
    static InArrayType: Class<TypeFormatFlags__InArrayType> &
      TypeFormatFlags__InArrayType &
      524288; // 524288
    static InElementType: Class<TypeFormatFlags__InElementType> &
      TypeFormatFlags__InElementType &
      2097152; // 2097152
    static InFirstTypeArgument: Class<TypeFormatFlags__InFirstTypeArgument> &
      TypeFormatFlags__InFirstTypeArgument &
      4194304; // 4194304
    static InTypeAlias: Class<TypeFormatFlags__InTypeAlias> &
      TypeFormatFlags__InTypeAlias &
      8388608; // 8388608
    static WriteOwnNameForAnyLike: Class<TypeFormatFlags__WriteOwnNameForAnyLike> &
      TypeFormatFlags__WriteOwnNameForAnyLike &
      0; // 0
    static NodeBuilderFlagsMask: Class<TypeFormatFlags__NodeBuilderFlagsMask> &
      TypeFormatFlags__NodeBuilderFlagsMask &
      9469291; // 9469291
  }

  declare class SymbolFormatFlags__None mixins SymbolFormatFlags {}
  declare class SymbolFormatFlags__WriteTypeParametersOrArguments
    mixins SymbolFormatFlags {}
  declare class SymbolFormatFlags__UseOnlyExternalAliasing
    mixins SymbolFormatFlags {}
  declare class SymbolFormatFlags__AllowAnyNodeKind mixins SymbolFormatFlags {}
  declare class SymbolFormatFlags__UseAliasDefinedOutsideCurrentScope
    mixins SymbolFormatFlags {}

  declare export class SymbolFormatFlags {
    constructor(...args: empty): mixed;
    static None: Class<SymbolFormatFlags__None> & SymbolFormatFlags__None & 0; // 0
    static WriteTypeParametersOrArguments: Class<SymbolFormatFlags__WriteTypeParametersOrArguments> &
      SymbolFormatFlags__WriteTypeParametersOrArguments &
      1; // 1
    static UseOnlyExternalAliasing: Class<SymbolFormatFlags__UseOnlyExternalAliasing> &
      SymbolFormatFlags__UseOnlyExternalAliasing &
      2; // 2
    static AllowAnyNodeKind: Class<SymbolFormatFlags__AllowAnyNodeKind> &
      SymbolFormatFlags__AllowAnyNodeKind &
      4; // 4
    static UseAliasDefinedOutsideCurrentScope: Class<SymbolFormatFlags__UseAliasDefinedOutsideCurrentScope> &
      SymbolFormatFlags__UseAliasDefinedOutsideCurrentScope &
      8; // 8
  }

  declare class TypePredicateKind__This mixins TypePredicateKind {}
  declare class TypePredicateKind__Identifier mixins TypePredicateKind {}

  declare export class TypePredicateKind {
    constructor(...args: empty): mixed;
    static This: Class<TypePredicateKind__This> & TypePredicateKind__This & 0; // 0
    static Identifier: Class<TypePredicateKind__Identifier> &
      TypePredicateKind__Identifier &
      1; // 1
  }

  declare export interface TypePredicateBase {
    kind: TypePredicateKind;
    type: Type;
  }
  declare export type ThisTypePredicate = {
    kind: TypePredicateKind.This
  } & TypePredicateBase;

  declare export type IdentifierTypePredicate = {
    kind: TypePredicateKind.Identifier,
    parameterName: string,
    parameterIndex: number
  } & TypePredicateBase;

  declare export type TypePredicate = IdentifierTypePredicate | ThisTypePredicate;
  declare class SymbolFlags__None mixins SymbolFlags {}
  declare class SymbolFlags__FunctionScopedVariable mixins SymbolFlags {}
  declare class SymbolFlags__BlockScopedVariable mixins SymbolFlags {}
  declare class SymbolFlags__Property mixins SymbolFlags {}
  declare class SymbolFlags__EnumMember mixins SymbolFlags {}
  declare class SymbolFlags__Function mixins SymbolFlags {}
  declare class SymbolFlags__Class mixins SymbolFlags {}
  declare class SymbolFlags__Interface mixins SymbolFlags {}
  declare class SymbolFlags__ConstEnum mixins SymbolFlags {}
  declare class SymbolFlags__RegularEnum mixins SymbolFlags {}
  declare class SymbolFlags__ValueModule mixins SymbolFlags {}
  declare class SymbolFlags__NamespaceModule mixins SymbolFlags {}
  declare class SymbolFlags__TypeLiteral mixins SymbolFlags {}
  declare class SymbolFlags__ObjectLiteral mixins SymbolFlags {}
  declare class SymbolFlags__Method mixins SymbolFlags {}
  declare class SymbolFlags__Constructor mixins SymbolFlags {}
  declare class SymbolFlags__GetAccessor mixins SymbolFlags {}
  declare class SymbolFlags__SetAccessor mixins SymbolFlags {}
  declare class SymbolFlags__Signature mixins SymbolFlags {}
  declare class SymbolFlags__TypeParameter mixins SymbolFlags {}
  declare class SymbolFlags__TypeAlias mixins SymbolFlags {}
  declare class SymbolFlags__ExportValue mixins SymbolFlags {}
  declare class SymbolFlags__Alias mixins SymbolFlags {}
  declare class SymbolFlags__Prototype mixins SymbolFlags {}
  declare class SymbolFlags__ExportStar mixins SymbolFlags {}
  declare class SymbolFlags__Optional mixins SymbolFlags {}
  declare class SymbolFlags__Transient mixins SymbolFlags {}
  declare class SymbolFlags__Assignment mixins SymbolFlags {}
  declare class SymbolFlags__ModuleExports mixins SymbolFlags {}
  declare class SymbolFlags__Enum mixins SymbolFlags {}
  declare class SymbolFlags__Variable mixins SymbolFlags {}
  declare class SymbolFlags__Value mixins SymbolFlags {}
  declare class SymbolFlags__Type mixins SymbolFlags {}
  declare class SymbolFlags__Namespace mixins SymbolFlags {}
  declare class SymbolFlags__Module mixins SymbolFlags {}
  declare class SymbolFlags__Accessor mixins SymbolFlags {}
  declare class SymbolFlags__FunctionScopedVariableExcludes
    mixins SymbolFlags {}
  declare class SymbolFlags__BlockScopedVariableExcludes mixins SymbolFlags {}
  declare class SymbolFlags__ParameterExcludes mixins SymbolFlags {}
  declare class SymbolFlags__PropertyExcludes mixins SymbolFlags {}
  declare class SymbolFlags__EnumMemberExcludes mixins SymbolFlags {}
  declare class SymbolFlags__FunctionExcludes mixins SymbolFlags {}
  declare class SymbolFlags__ClassExcludes mixins SymbolFlags {}
  declare class SymbolFlags__InterfaceExcludes mixins SymbolFlags {}
  declare class SymbolFlags__RegularEnumExcludes mixins SymbolFlags {}
  declare class SymbolFlags__ConstEnumExcludes mixins SymbolFlags {}
  declare class SymbolFlags__ValueModuleExcludes mixins SymbolFlags {}
  declare class SymbolFlags__NamespaceModuleExcludes mixins SymbolFlags {}
  declare class SymbolFlags__MethodExcludes mixins SymbolFlags {}
  declare class SymbolFlags__GetAccessorExcludes mixins SymbolFlags {}
  declare class SymbolFlags__SetAccessorExcludes mixins SymbolFlags {}
  declare class SymbolFlags__TypeParameterExcludes mixins SymbolFlags {}
  declare class SymbolFlags__TypeAliasExcludes mixins SymbolFlags {}
  declare class SymbolFlags__AliasExcludes mixins SymbolFlags {}
  declare class SymbolFlags__ModuleMember mixins SymbolFlags {}
  declare class SymbolFlags__ExportHasLocal mixins SymbolFlags {}
  declare class SymbolFlags__BlockScoped mixins SymbolFlags {}
  declare class SymbolFlags__PropertyOrAccessor mixins SymbolFlags {}
  declare class SymbolFlags__ClassMember mixins SymbolFlags {}

  declare export class SymbolFlags {
    constructor(...args: empty): mixed;
    static None: Class<SymbolFlags__None> & SymbolFlags__None & 0; // 0
    static FunctionScopedVariable: Class<SymbolFlags__FunctionScopedVariable> &
      SymbolFlags__FunctionScopedVariable &
      1; // 1
    static BlockScopedVariable: Class<SymbolFlags__BlockScopedVariable> &
      SymbolFlags__BlockScopedVariable &
      2; // 2
    static Property: Class<SymbolFlags__Property> & SymbolFlags__Property & 4; // 4
    static EnumMember: Class<SymbolFlags__EnumMember> &
      SymbolFlags__EnumMember &
      8; // 8
    static Function: Class<SymbolFlags__Function> & SymbolFlags__Function & 16; // 16
    static Class: Class<SymbolFlags__Class> & SymbolFlags__Class & 32; // 32
    static Interface: Class<SymbolFlags__Interface> &
      SymbolFlags__Interface &
      64; // 64
    static ConstEnum: Class<SymbolFlags__ConstEnum> &
      SymbolFlags__ConstEnum &
      128; // 128
    static RegularEnum: Class<SymbolFlags__RegularEnum> &
      SymbolFlags__RegularEnum &
      256; // 256
    static ValueModule: Class<SymbolFlags__ValueModule> &
      SymbolFlags__ValueModule &
      512; // 512
    static NamespaceModule: Class<SymbolFlags__NamespaceModule> &
      SymbolFlags__NamespaceModule &
      1024; // 1024
    static TypeLiteral: Class<SymbolFlags__TypeLiteral> &
      SymbolFlags__TypeLiteral &
      2048; // 2048
    static ObjectLiteral: Class<SymbolFlags__ObjectLiteral> &
      SymbolFlags__ObjectLiteral &
      4096; // 4096
    static Method: Class<SymbolFlags__Method> & SymbolFlags__Method & 8192; // 8192
    static Constructor: Class<SymbolFlags__Constructor> &
      SymbolFlags__Constructor &
      16384; // 16384
    static GetAccessor: Class<SymbolFlags__GetAccessor> &
      SymbolFlags__GetAccessor &
      32768; // 32768
    static SetAccessor: Class<SymbolFlags__SetAccessor> &
      SymbolFlags__SetAccessor &
      65536; // 65536
    static Signature: Class<SymbolFlags__Signature> &
      SymbolFlags__Signature &
      131072; // 131072
    static TypeParameter: Class<SymbolFlags__TypeParameter> &
      SymbolFlags__TypeParameter &
      262144; // 262144
    static TypeAlias: Class<SymbolFlags__TypeAlias> &
      SymbolFlags__TypeAlias &
      524288; // 524288
    static ExportValue: Class<SymbolFlags__ExportValue> &
      SymbolFlags__ExportValue &
      1048576; // 1048576
    static Alias: Class<SymbolFlags__Alias> & SymbolFlags__Alias & 2097152; // 2097152
    static Prototype: Class<SymbolFlags__Prototype> &
      SymbolFlags__Prototype &
      4194304; // 4194304
    static ExportStar: Class<SymbolFlags__ExportStar> &
      SymbolFlags__ExportStar &
      8388608; // 8388608
    static Optional: Class<SymbolFlags__Optional> &
      SymbolFlags__Optional &
      16777216; // 16777216
    static Transient: Class<SymbolFlags__Transient> &
      SymbolFlags__Transient &
      33554432; // 33554432
    static Assignment: Class<SymbolFlags__Assignment> &
      SymbolFlags__Assignment &
      67108864; // 67108864
    static ModuleExports: Class<SymbolFlags__ModuleExports> &
      SymbolFlags__ModuleExports &
      134217728; // 134217728
    static Enum: Class<SymbolFlags__Enum> & SymbolFlags__Enum & 384; // 384
    static Variable: Class<SymbolFlags__Variable> & SymbolFlags__Variable & 3; // 3
    static Value: Class<SymbolFlags__Value> & SymbolFlags__Value & 67220415; // 67220415
    static Type: Class<SymbolFlags__Type> & SymbolFlags__Type & 67897832; // 67897832
    static Namespace: Class<SymbolFlags__Namespace> &
      SymbolFlags__Namespace &
      1920; // 1920
    static Module: Class<SymbolFlags__Module> & SymbolFlags__Module & 1536; // 1536
    static Accessor: Class<SymbolFlags__Accessor> &
      SymbolFlags__Accessor &
      98304; // 98304
    static FunctionScopedVariableExcludes: Class<SymbolFlags__FunctionScopedVariableExcludes> &
      SymbolFlags__FunctionScopedVariableExcludes &
      67220414; // 67220414
    static BlockScopedVariableExcludes: Class<SymbolFlags__BlockScopedVariableExcludes> &
      SymbolFlags__BlockScopedVariableExcludes &
      67220415; // 67220415
    static ParameterExcludes: Class<SymbolFlags__ParameterExcludes> &
      SymbolFlags__ParameterExcludes &
      67220415; // 67220415
    static PropertyExcludes: Class<SymbolFlags__PropertyExcludes> &
      SymbolFlags__PropertyExcludes &
      0; // 0
    static EnumMemberExcludes: Class<SymbolFlags__EnumMemberExcludes> &
      SymbolFlags__EnumMemberExcludes &
      68008959; // 68008959
    static FunctionExcludes: Class<SymbolFlags__FunctionExcludes> &
      SymbolFlags__FunctionExcludes &
      67219887; // 67219887
    static ClassExcludes: Class<SymbolFlags__ClassExcludes> &
      SymbolFlags__ClassExcludes &
      68008383; // 68008383
    static InterfaceExcludes: Class<SymbolFlags__InterfaceExcludes> &
      SymbolFlags__InterfaceExcludes &
      67897736; // 67897736
    static RegularEnumExcludes: Class<SymbolFlags__RegularEnumExcludes> &
      SymbolFlags__RegularEnumExcludes &
      68008191; // 68008191
    static ConstEnumExcludes: Class<SymbolFlags__ConstEnumExcludes> &
      SymbolFlags__ConstEnumExcludes &
      68008831; // 68008831
    static ValueModuleExcludes: Class<SymbolFlags__ValueModuleExcludes> &
      SymbolFlags__ValueModuleExcludes &
      110735; // 110735
    static NamespaceModuleExcludes: Class<SymbolFlags__NamespaceModuleExcludes> &
      SymbolFlags__NamespaceModuleExcludes &
      0; // 0
    static MethodExcludes: Class<SymbolFlags__MethodExcludes> &
      SymbolFlags__MethodExcludes &
      67212223; // 67212223
    static GetAccessorExcludes: Class<SymbolFlags__GetAccessorExcludes> &
      SymbolFlags__GetAccessorExcludes &
      67154879; // 67154879
    static SetAccessorExcludes: Class<SymbolFlags__SetAccessorExcludes> &
      SymbolFlags__SetAccessorExcludes &
      67187647; // 67187647
    static TypeParameterExcludes: Class<SymbolFlags__TypeParameterExcludes> &
      SymbolFlags__TypeParameterExcludes &
      67635688; // 67635688
    static TypeAliasExcludes: Class<SymbolFlags__TypeAliasExcludes> &
      SymbolFlags__TypeAliasExcludes &
      67897832; // 67897832
    static AliasExcludes: Class<SymbolFlags__AliasExcludes> &
      SymbolFlags__AliasExcludes &
      2097152; // 2097152
    static ModuleMember: Class<SymbolFlags__ModuleMember> &
      SymbolFlags__ModuleMember &
      2623475; // 2623475
    static ExportHasLocal: Class<SymbolFlags__ExportHasLocal> &
      SymbolFlags__ExportHasLocal &
      944; // 944
    static BlockScoped: Class<SymbolFlags__BlockScoped> &
      SymbolFlags__BlockScoped &
      418; // 418
    static PropertyOrAccessor: Class<SymbolFlags__PropertyOrAccessor> &
      SymbolFlags__PropertyOrAccessor &
      98308; // 98308
    static ClassMember: Class<SymbolFlags__ClassMember> &
      SymbolFlags__ClassMember &
      106500; // 106500
  }

  declare export interface Symbol {
    flags: SymbolFlags;
    escapedName: __String;
    declarations: Declaration[];
    valueDeclaration: Declaration;
    members?: SymbolTable;
    exports?: SymbolTable;
    globalExports?: SymbolTable;
    name: string;
    getFlags(): SymbolFlags;
    getEscapedName(): __String;
    getName(): string;
    getDeclarations(): Declaration[] | void;
    getDocumentationComment(
      typeChecker: TypeChecker | void
    ): SymbolDisplayPart[];
    getJsDocTags(): JSDocTagInfo[];
  }
  declare class InternalSymbolName__Call mixins InternalSymbolName {}
  declare class InternalSymbolName__Constructor mixins InternalSymbolName {}
  declare class InternalSymbolName__New mixins InternalSymbolName {}
  declare class InternalSymbolName__Index mixins InternalSymbolName {}
  declare class InternalSymbolName__ExportStar mixins InternalSymbolName {}
  declare class InternalSymbolName__Global mixins InternalSymbolName {}
  declare class InternalSymbolName__Missing mixins InternalSymbolName {}
  declare class InternalSymbolName__Type mixins InternalSymbolName {}
  declare class InternalSymbolName__Object mixins InternalSymbolName {}
  declare class InternalSymbolName__JSXAttributes mixins InternalSymbolName {}
  declare class InternalSymbolName__Class mixins InternalSymbolName {}
  declare class InternalSymbolName__Function mixins InternalSymbolName {}
  declare class InternalSymbolName__Computed mixins InternalSymbolName {}
  declare class InternalSymbolName__Resolving mixins InternalSymbolName {}
  declare class InternalSymbolName__ExportEquals mixins InternalSymbolName {}
  declare class InternalSymbolName__Default mixins InternalSymbolName {}
  declare class InternalSymbolName__This mixins InternalSymbolName {}

  declare export class InternalSymbolName {
    constructor(...args: empty): mixed;
    static Call: Class<InternalSymbolName__Call> &
      InternalSymbolName__Call &
      "__call"; // "__call"
    static Constructor: Class<InternalSymbolName__Constructor> &
      InternalSymbolName__Constructor &
      "__constructor"; // "__constructor"
    static New: Class<InternalSymbolName__New> &
      InternalSymbolName__New &
      "__new"; // "__new"
    static Index: Class<InternalSymbolName__Index> &
      InternalSymbolName__Index &
      "__index"; // "__index"
    static ExportStar: Class<InternalSymbolName__ExportStar> &
      InternalSymbolName__ExportStar &
      "__export"; // "__export"
    static Global: Class<InternalSymbolName__Global> &
      InternalSymbolName__Global &
      "__global"; // "__global"
    static Missing: Class<InternalSymbolName__Missing> &
      InternalSymbolName__Missing &
      "__missing"; // "__missing"
    static Type: Class<InternalSymbolName__Type> &
      InternalSymbolName__Type &
      "__type"; // "__type"
    static Object: Class<InternalSymbolName__Object> &
      InternalSymbolName__Object &
      "__object"; // "__object"
    static JSXAttributes: Class<InternalSymbolName__JSXAttributes> &
      InternalSymbolName__JSXAttributes &
      "__jsxAttributes"; // "__jsxAttributes"
    static Class: Class<InternalSymbolName__Class> &
      InternalSymbolName__Class &
      "__class"; // "__class"
    static Function: Class<InternalSymbolName__Function> &
      InternalSymbolName__Function &
      "__function"; // "__function"
    static Computed: Class<InternalSymbolName__Computed> &
      InternalSymbolName__Computed &
      "__computed"; // "__computed"
    static Resolving: Class<InternalSymbolName__Resolving> &
      InternalSymbolName__Resolving &
      "__resolving__"; // "__resolving__"
    static ExportEquals: Class<InternalSymbolName__ExportEquals> &
      InternalSymbolName__ExportEquals &
      "export="; // "export="
    static Default: Class<InternalSymbolName__Default> &
      InternalSymbolName__Default &
      "default"; // "default"
    static This: Class<InternalSymbolName__This> &
      InternalSymbolName__This &
      "this"; // "this"
  }

  /**
 * This represents a string whose leading underscore have been escaped by adding extra leading underscores.
 * The shape of this brand is rather unique compared to others we've used.
Instead of just an intersection of a string and an object, it is that union-ed
with an intersection of void and an object. This makes it wholly incompatible
with a normal string (which is good, it cannot be misused on assignment or on usage),
while still being comparable with a normal string via === (also good) and castable from a string.
*/
  declare export type __String =
    | (string & {
        __escapedIdentifier: void
      })
    | (void & {
        __escapedIdentifier: void
      })
    | InternalSymbolName;

  /**
   * ReadonlyMap where keys are `__String`s.
   */
  declare export interface ReadonlyUnderscoreEscapedMap<T> {
    get(key: __String): T | void;
    has(key: __String): boolean;
    forEach(action: (value: T, key: __String) => void): void;
    size: number;
    keys(): Iterator<__String>;
    values(): Iterator<T>;
    entries(): Iterator<[__String, T]>;
  }

  /**
   * Map where keys are `__String`s.
   */
  declare export type UnderscoreEscapedMap<T> = {
    set(key: __String, value: T): UnderscoreEscapedMap<T>,
    delete(key: __String): boolean,
    clear(): void
  } & ReadonlyUnderscoreEscapedMap<T>;

  /**
   * SymbolTable based on ES6 Map interface.
   */
  declare export type SymbolTable = UnderscoreEscapedMap<Symbol>;
  declare class TypeFlags__Any mixins TypeFlags {}
  declare class TypeFlags__Unknown mixins TypeFlags {}
  declare class TypeFlags__String mixins TypeFlags {}
  declare class TypeFlags__Number mixins TypeFlags {}
  declare class TypeFlags__Boolean mixins TypeFlags {}
  declare class TypeFlags__Enum mixins TypeFlags {}
  declare class TypeFlags__BigInt mixins TypeFlags {}
  declare class TypeFlags__StringLiteral mixins TypeFlags {}
  declare class TypeFlags__NumberLiteral mixins TypeFlags {}
  declare class TypeFlags__BooleanLiteral mixins TypeFlags {}
  declare class TypeFlags__EnumLiteral mixins TypeFlags {}
  declare class TypeFlags__BigIntLiteral mixins TypeFlags {}
  declare class TypeFlags__ESSymbol mixins TypeFlags {}
  declare class TypeFlags__UniqueESSymbol mixins TypeFlags {}
  declare class TypeFlags__Void mixins TypeFlags {}
  declare class TypeFlags__Undefined mixins TypeFlags {}
  declare class TypeFlags__Null mixins TypeFlags {}
  declare class TypeFlags__Never mixins TypeFlags {}
  declare class TypeFlags__TypeParameter mixins TypeFlags {}
  declare class TypeFlags__Object mixins TypeFlags {}
  declare class TypeFlags__Union mixins TypeFlags {}
  declare class TypeFlags__Intersection mixins TypeFlags {}
  declare class TypeFlags__Index mixins TypeFlags {}
  declare class TypeFlags__IndexedAccess mixins TypeFlags {}
  declare class TypeFlags__Conditional mixins TypeFlags {}
  declare class TypeFlags__Substitution mixins TypeFlags {}
  declare class TypeFlags__NonPrimitive mixins TypeFlags {}
  declare class TypeFlags__Literal mixins TypeFlags {}
  declare class TypeFlags__Unit mixins TypeFlags {}
  declare class TypeFlags__StringOrNumberLiteral mixins TypeFlags {}
  declare class TypeFlags__PossiblyFalsy mixins TypeFlags {}
  declare class TypeFlags__StringLike mixins TypeFlags {}
  declare class TypeFlags__NumberLike mixins TypeFlags {}
  declare class TypeFlags__BigIntLike mixins TypeFlags {}
  declare class TypeFlags__BooleanLike mixins TypeFlags {}
  declare class TypeFlags__EnumLike mixins TypeFlags {}
  declare class TypeFlags__ESSymbolLike mixins TypeFlags {}
  declare class TypeFlags__VoidLike mixins TypeFlags {}
  declare class TypeFlags__UnionOrIntersection mixins TypeFlags {}
  declare class TypeFlags__StructuredType mixins TypeFlags {}
  declare class TypeFlags__TypeVariable mixins TypeFlags {}
  declare class TypeFlags__InstantiableNonPrimitive mixins TypeFlags {}
  declare class TypeFlags__InstantiablePrimitive mixins TypeFlags {}
  declare class TypeFlags__Instantiable mixins TypeFlags {}
  declare class TypeFlags__StructuredOrInstantiable mixins TypeFlags {}
  declare class TypeFlags__Narrowable mixins TypeFlags {}
  declare class TypeFlags__NotUnionOrUnit mixins TypeFlags {}

  declare export class TypeFlags {
    constructor(...args: empty): mixed;
    static Any: Class<TypeFlags__Any> & TypeFlags__Any & 1; // 1
    static Unknown: Class<TypeFlags__Unknown> & TypeFlags__Unknown & 2; // 2
    static String: Class<TypeFlags__String> & TypeFlags__String & 4; // 4
    static Number: Class<TypeFlags__Number> & TypeFlags__Number & 8; // 8
    static Boolean: Class<TypeFlags__Boolean> & TypeFlags__Boolean & 16; // 16
    static Enum: Class<TypeFlags__Enum> & TypeFlags__Enum & 32; // 32
    static BigInt: Class<TypeFlags__BigInt> & TypeFlags__BigInt & 64; // 64
    static StringLiteral: Class<TypeFlags__StringLiteral> &
      TypeFlags__StringLiteral &
      128; // 128
    static NumberLiteral: Class<TypeFlags__NumberLiteral> &
      TypeFlags__NumberLiteral &
      256; // 256
    static BooleanLiteral: Class<TypeFlags__BooleanLiteral> &
      TypeFlags__BooleanLiteral &
      512; // 512
    static EnumLiteral: Class<TypeFlags__EnumLiteral> &
      TypeFlags__EnumLiteral &
      1024; // 1024
    static BigIntLiteral: Class<TypeFlags__BigIntLiteral> &
      TypeFlags__BigIntLiteral &
      2048; // 2048
    static ESSymbol: Class<TypeFlags__ESSymbol> & TypeFlags__ESSymbol & 4096; // 4096
    static UniqueESSymbol: Class<TypeFlags__UniqueESSymbol> &
      TypeFlags__UniqueESSymbol &
      8192; // 8192
    static Void: Class<TypeFlags__Void> & TypeFlags__Void & 16384; // 16384
    static Undefined: Class<TypeFlags__Undefined> &
      TypeFlags__Undefined &
      32768; // 32768
    static Null: Class<TypeFlags__Null> & TypeFlags__Null & 65536; // 65536
    static Never: Class<TypeFlags__Never> & TypeFlags__Never & 131072; // 131072
    static TypeParameter: Class<TypeFlags__TypeParameter> &
      TypeFlags__TypeParameter &
      262144; // 262144
    static Object: Class<TypeFlags__Object> & TypeFlags__Object & 524288; // 524288
    static Union: Class<TypeFlags__Union> & TypeFlags__Union & 1048576; // 1048576
    static Intersection: Class<TypeFlags__Intersection> &
      TypeFlags__Intersection &
      2097152; // 2097152
    static Index: Class<TypeFlags__Index> & TypeFlags__Index & 4194304; // 4194304
    static IndexedAccess: Class<TypeFlags__IndexedAccess> &
      TypeFlags__IndexedAccess &
      8388608; // 8388608
    static Conditional: Class<TypeFlags__Conditional> &
      TypeFlags__Conditional &
      16777216; // 16777216
    static Substitution: Class<TypeFlags__Substitution> &
      TypeFlags__Substitution &
      33554432; // 33554432
    static NonPrimitive: Class<TypeFlags__NonPrimitive> &
      TypeFlags__NonPrimitive &
      67108864; // 67108864
    static Literal: Class<TypeFlags__Literal> & TypeFlags__Literal & 2944; // 2944
    static Unit: Class<TypeFlags__Unit> & TypeFlags__Unit & 109440; // 109440
    static StringOrNumberLiteral: Class<TypeFlags__StringOrNumberLiteral> &
      TypeFlags__StringOrNumberLiteral &
      384; // 384
    static PossiblyFalsy: Class<TypeFlags__PossiblyFalsy> &
      TypeFlags__PossiblyFalsy &
      117724; // 117724
    static StringLike: Class<TypeFlags__StringLike> &
      TypeFlags__StringLike &
      132; // 132
    static NumberLike: Class<TypeFlags__NumberLike> &
      TypeFlags__NumberLike &
      296; // 296
    static BigIntLike: Class<TypeFlags__BigIntLike> &
      TypeFlags__BigIntLike &
      2112; // 2112
    static BooleanLike: Class<TypeFlags__BooleanLike> &
      TypeFlags__BooleanLike &
      528; // 528
    static EnumLike: Class<TypeFlags__EnumLike> & TypeFlags__EnumLike & 1056; // 1056
    static ESSymbolLike: Class<TypeFlags__ESSymbolLike> &
      TypeFlags__ESSymbolLike &
      12288; // 12288
    static VoidLike: Class<TypeFlags__VoidLike> & TypeFlags__VoidLike & 49152; // 49152
    static UnionOrIntersection: Class<TypeFlags__UnionOrIntersection> &
      TypeFlags__UnionOrIntersection &
      3145728; // 3145728
    static StructuredType: Class<TypeFlags__StructuredType> &
      TypeFlags__StructuredType &
      3670016; // 3670016
    static TypeVariable: Class<TypeFlags__TypeVariable> &
      TypeFlags__TypeVariable &
      8650752; // 8650752
    static InstantiableNonPrimitive: Class<TypeFlags__InstantiableNonPrimitive> &
      TypeFlags__InstantiableNonPrimitive &
      58982400; // 58982400
    static InstantiablePrimitive: Class<TypeFlags__InstantiablePrimitive> &
      TypeFlags__InstantiablePrimitive &
      4194304; // 4194304
    static Instantiable: Class<TypeFlags__Instantiable> &
      TypeFlags__Instantiable &
      63176704; // 63176704
    static StructuredOrInstantiable: Class<TypeFlags__StructuredOrInstantiable> &
      TypeFlags__StructuredOrInstantiable &
      66846720; // 66846720
    static Narrowable: Class<TypeFlags__Narrowable> &
      TypeFlags__Narrowable &
      133970943; // 133970943
    static NotUnionOrUnit: Class<TypeFlags__NotUnionOrUnit> &
      TypeFlags__NotUnionOrUnit &
      67637251; // 67637251
  }

  declare export type DestructuringPattern =
    | BindingPattern
    | ObjectLiteralExpression
    | ArrayLiteralExpression;
  declare export interface Type {
    flags: TypeFlags;
    symbol: Symbol;
    pattern?: DestructuringPattern;
    aliasSymbol?: Symbol;
    aliasTypeArguments?: $ReadOnlyArray<Type>;
    getFlags(): TypeFlags;
    getSymbol(): Symbol | void;
    getProperties(): Symbol[];
    getProperty(propertyName: string): Symbol | void;
    getApparentProperties(): Symbol[];
    getCallSignatures(): $ReadOnlyArray<Signature>;
    getConstructSignatures(): $ReadOnlyArray<Signature>;
    getStringIndexType(): Type | void;
    getNumberIndexType(): Type | void;
    getBaseTypes(): BaseType[] | void;
    getNonNullableType(): Type;
    getConstraint(): Type | void;
    getDefault(): Type | void;
    isUnion(): boolean;
    isIntersection(): boolean;
    isUnionOrIntersection(): boolean;
    isLiteral(): boolean;
    isStringLiteral(): boolean;
    isNumberLiteral(): boolean;
    isTypeParameter(): boolean;
    isClassOrInterface(): boolean;
    isClass(): boolean;
  }
  declare export type LiteralType = {
    value: string | number | PseudoBigInt,
    freshType: LiteralType,
    regularType: LiteralType
  } & Type;

  declare export type UniqueESSymbolType = {
    symbol: Symbol,
    escapedName: __String
  } & Type;

  declare export type StringLiteralType = {
    value: string
  } & LiteralType;

  declare export type NumberLiteralType = {
    value: number
  } & LiteralType;

  declare export type BigIntLiteralType = {
    value: PseudoBigInt
  } & LiteralType;

  declare export type EnumType = {} & Type;

  declare class ObjectFlags__Class mixins ObjectFlags {}
  declare class ObjectFlags__Interface mixins ObjectFlags {}
  declare class ObjectFlags__Reference mixins ObjectFlags {}
  declare class ObjectFlags__Tuple mixins ObjectFlags {}
  declare class ObjectFlags__Anonymous mixins ObjectFlags {}
  declare class ObjectFlags__Mapped mixins ObjectFlags {}
  declare class ObjectFlags__Instantiated mixins ObjectFlags {}
  declare class ObjectFlags__ObjectLiteral mixins ObjectFlags {}
  declare class ObjectFlags__EvolvingArray mixins ObjectFlags {}
  declare class ObjectFlags__ObjectLiteralPatternWithComputedProperties
    mixins ObjectFlags {}
  declare class ObjectFlags__ContainsSpread mixins ObjectFlags {}
  declare class ObjectFlags__ReverseMapped mixins ObjectFlags {}
  declare class ObjectFlags__JsxAttributes mixins ObjectFlags {}
  declare class ObjectFlags__MarkerType mixins ObjectFlags {}
  declare class ObjectFlags__JSLiteral mixins ObjectFlags {}
  declare class ObjectFlags__FreshLiteral mixins ObjectFlags {}
  declare class ObjectFlags__ClassOrInterface mixins ObjectFlags {}

  declare export class ObjectFlags {
    constructor(...args: empty): mixed;
    static Class: Class<ObjectFlags__Class> & ObjectFlags__Class & 1; // 1
    static Interface: Class<ObjectFlags__Interface> &
      ObjectFlags__Interface &
      2; // 2
    static Reference: Class<ObjectFlags__Reference> &
      ObjectFlags__Reference &
      4; // 4
    static Tuple: Class<ObjectFlags__Tuple> & ObjectFlags__Tuple & 8; // 8
    static Anonymous: Class<ObjectFlags__Anonymous> &
      ObjectFlags__Anonymous &
      16; // 16
    static Mapped: Class<ObjectFlags__Mapped> & ObjectFlags__Mapped & 32; // 32
    static Instantiated: Class<ObjectFlags__Instantiated> &
      ObjectFlags__Instantiated &
      64; // 64
    static ObjectLiteral: Class<ObjectFlags__ObjectLiteral> &
      ObjectFlags__ObjectLiteral &
      128; // 128
    static EvolvingArray: Class<ObjectFlags__EvolvingArray> &
      ObjectFlags__EvolvingArray &
      256; // 256
    static ObjectLiteralPatternWithComputedProperties: Class<ObjectFlags__ObjectLiteralPatternWithComputedProperties> &
      ObjectFlags__ObjectLiteralPatternWithComputedProperties &
      512; // 512
    static ContainsSpread: Class<ObjectFlags__ContainsSpread> &
      ObjectFlags__ContainsSpread &
      1024; // 1024
    static ReverseMapped: Class<ObjectFlags__ReverseMapped> &
      ObjectFlags__ReverseMapped &
      2048; // 2048
    static JsxAttributes: Class<ObjectFlags__JsxAttributes> &
      ObjectFlags__JsxAttributes &
      4096; // 4096
    static MarkerType: Class<ObjectFlags__MarkerType> &
      ObjectFlags__MarkerType &
      8192; // 8192
    static JSLiteral: Class<ObjectFlags__JSLiteral> &
      ObjectFlags__JSLiteral &
      16384; // 16384
    static FreshLiteral: Class<ObjectFlags__FreshLiteral> &
      ObjectFlags__FreshLiteral &
      32768; // 32768
    static ClassOrInterface: Class<ObjectFlags__ClassOrInterface> &
      ObjectFlags__ClassOrInterface &
      3; // 3
  }

  declare export type ObjectType = {
    objectFlags: ObjectFlags
  } & Type;

  /**
   * Class and interface types (ObjectFlags.Class and ObjectFlags.Interface).
   */
  declare export type InterfaceType = {
    typeParameters: TypeParameter[] | void,
    outerTypeParameters: TypeParameter[] | void,
    localTypeParameters: TypeParameter[] | void,
    thisType: TypeParameter | void
  } & ObjectType;

  declare export type BaseType = ObjectType | IntersectionType;
  declare export type InterfaceTypeWithDeclaredMembers = {
    declaredProperties: Symbol[],
    declaredCallSignatures: Signature[],
    declaredConstructSignatures: Signature[],
    declaredStringIndexInfo?: IndexInfo,
    declaredNumberIndexInfo?: IndexInfo
  } & InterfaceType;

  /**
 * Type references (ObjectFlags.Reference). When a class or interface has type parameters or
 * a "this" type, references to the class or interface are made using type references. The
typeArguments property specifies the types to substitute for the type parameters of the
class or interface and optionally includes an extra element that specifies the type to
substitute for "this" in the resulting instantiation. When no extra argument is present,
the type reference itself is substituted for "this". The typeArguments property is undefined
if the class or interface has no type parameters and the reference isn't specifying an
explicit "this" argument.
*/
  declare export type TypeReference = {
    target: GenericType,
    typeArguments?: $ReadOnlyArray<Type>
  } & ObjectType;

  declare export type GenericType = {} & InterfaceType & TypeReference;

  declare export type TupleType = {
    minLength: number,
    hasRestElement: boolean,
    associatedNames?: __String[]
  } & GenericType;

  declare export type TupleTypeReference = {
    target: TupleType
  } & TypeReference;

  declare export type UnionOrIntersectionType = {
    types: Type[]
  } & Type;

  declare export type UnionType = {} & UnionOrIntersectionType;

  declare export type IntersectionType = {} & UnionOrIntersectionType;

  declare export type StructuredType = ObjectType | UnionType | IntersectionType;
  declare export type EvolvingArrayType = {
    elementType: Type,
    finalArrayType?: Type
  } & ObjectType;

  declare export type InstantiableType = {} & Type;

  declare export type TypeParameter = {} & InstantiableType;

  declare export type IndexedAccessType = {
    objectType: Type,
    indexType: Type,
    constraint?: Type,
    simplified?: Type
  } & InstantiableType;

  declare export type TypeVariable = TypeParameter | IndexedAccessType;
  declare export type IndexType = {
    type: InstantiableType | UnionOrIntersectionType
  } & InstantiableType;

  declare export interface ConditionalRoot {
    node: ConditionalTypeNode;
    checkType: Type;
    extendsType: Type;
    trueType: Type;
    falseType: Type;
    isDistributive: boolean;
    inferTypeParameters?: TypeParameter[];
    outerTypeParameters?: TypeParameter[];
    instantiations?: Map<Type>;
    aliasSymbol?: Symbol;
    aliasTypeArguments?: Type[];
  }
  declare export type ConditionalType = {
    root: ConditionalRoot,
    checkType: Type,
    extendsType: Type,
    resolvedTrueType?: Type,
    resolvedFalseType?: Type
  } & InstantiableType;

  declare export type SubstitutionType = {
    typeVariable: TypeVariable,
    substitute: Type
  } & InstantiableType;

  declare class SignatureKind__Call mixins SignatureKind {}
  declare class SignatureKind__Construct mixins SignatureKind {}

  declare export class SignatureKind {
    constructor(...args: empty): mixed;
    static Call: Class<SignatureKind__Call> & SignatureKind__Call & 0; // 0
    static Construct: Class<SignatureKind__Construct> &
      SignatureKind__Construct &
      1; // 1
  }

  declare export interface Signature {
    declaration?: SignatureDeclaration | JSDocSignature;
    typeParameters?: $ReadOnlyArray<TypeParameter>;
    parameters: $ReadOnlyArray<Symbol>;
    getDeclaration(): SignatureDeclaration;
    getTypeParameters(): TypeParameter[] | void;
    getParameters(): Symbol[];
    getReturnType(): Type;
    getDocumentationComment(
      typeChecker: TypeChecker | void
    ): SymbolDisplayPart[];
    getJsDocTags(): JSDocTagInfo[];
  }
  declare class IndexKind__String mixins IndexKind {}
  declare class IndexKind__Number mixins IndexKind {}

  declare export class IndexKind {
    constructor(...args: empty): mixed;
    static String: Class<IndexKind__String> & IndexKind__String & 0; // 0
    static Number: Class<IndexKind__Number> & IndexKind__Number & 1; // 1
  }

  declare export interface IndexInfo {
    type: Type;
    isReadonly: boolean;
    declaration?: IndexSignatureDeclaration;
  }
  declare class InferencePriority__NakedTypeVariable mixins InferencePriority {}
  declare class InferencePriority__HomomorphicMappedType
    mixins InferencePriority {}
  declare class InferencePriority__MappedTypeConstraint
    mixins InferencePriority {}
  declare class InferencePriority__ReturnType mixins InferencePriority {}
  declare class InferencePriority__LiteralKeyof mixins InferencePriority {}
  declare class InferencePriority__NoConstraints mixins InferencePriority {}
  declare class InferencePriority__AlwaysStrict mixins InferencePriority {}
  declare class InferencePriority__PriorityImpliesCombination
    mixins InferencePriority {}

  declare export class InferencePriority {
    constructor(...args: empty): mixed;
    static NakedTypeVariable: Class<InferencePriority__NakedTypeVariable> &
      InferencePriority__NakedTypeVariable &
      1; // 1
    static HomomorphicMappedType: Class<InferencePriority__HomomorphicMappedType> &
      InferencePriority__HomomorphicMappedType &
      2; // 2
    static MappedTypeConstraint: Class<InferencePriority__MappedTypeConstraint> &
      InferencePriority__MappedTypeConstraint &
      4; // 4
    static ReturnType: Class<InferencePriority__ReturnType> &
      InferencePriority__ReturnType &
      8; // 8
    static LiteralKeyof: Class<InferencePriority__LiteralKeyof> &
      InferencePriority__LiteralKeyof &
      16; // 16
    static NoConstraints: Class<InferencePriority__NoConstraints> &
      InferencePriority__NoConstraints &
      32; // 32
    static AlwaysStrict: Class<InferencePriority__AlwaysStrict> &
      InferencePriority__AlwaysStrict &
      64; // 64
    static PriorityImpliesCombination: Class<InferencePriority__PriorityImpliesCombination> &
      InferencePriority__PriorityImpliesCombination &
      28; // 28
  }

  /**
   *
   * @deprecated Use FileExtensionInfo instead.
   */
  declare export type JsFileExtensionInfo = FileExtensionInfo;
  declare export interface FileExtensionInfo {
    extension: string;
    isMixedContent: boolean;
    scriptKind?: ScriptKind;
  }
  declare export interface DiagnosticMessage {
    key: string;
    category: DiagnosticCategory;
    code: number;
    message: string;
    reportsUnnecessary?: {};
  }

  /**
 * A linked list of formatted diagnostic messages to be used as part of a multiline message.
 * It is built from the bottom up, leaving the head to be the "main" diagnostic.
While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,
the difference is that messages are all preformatted in DMC.
*/
  declare export interface DiagnosticMessageChain {
    messageText: string;
    category: DiagnosticCategory;
    code: number;
    next?: DiagnosticMessageChain;
  }
  declare export type Diagnostic = {
    /**
     * May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic.
     */
    reportsUnnecessary?: {},
    source?: string,
    relatedInformation?: DiagnosticRelatedInformation[]
  } & DiagnosticRelatedInformation;

  declare export interface DiagnosticRelatedInformation {
    category: DiagnosticCategory;
    code: number;
    file: SourceFile | void;
    start: number | void;
    length: number | void;
    messageText: string | DiagnosticMessageChain;
  }
  declare export type DiagnosticWithLocation = {
    file: SourceFile,
    start: number,
    length: number
  } & Diagnostic;

  declare class DiagnosticCategory__Warning mixins DiagnosticCategory {}
  declare class DiagnosticCategory__Error mixins DiagnosticCategory {}
  declare class DiagnosticCategory__Suggestion mixins DiagnosticCategory {}
  declare class DiagnosticCategory__Message mixins DiagnosticCategory {}

  declare export class DiagnosticCategory {
    constructor(...args: empty): mixed;
    static Warning: Class<DiagnosticCategory__Warning> &
      DiagnosticCategory__Warning &
      0; // 0
    static Error: Class<DiagnosticCategory__Error> &
      DiagnosticCategory__Error &
      1; // 1
    static Suggestion: Class<DiagnosticCategory__Suggestion> &
      DiagnosticCategory__Suggestion &
      2; // 2
    static Message: Class<DiagnosticCategory__Message> &
      DiagnosticCategory__Message &
      3; // 3
  }

  declare class ModuleResolutionKind__Classic mixins ModuleResolutionKind {}
  declare class ModuleResolutionKind__NodeJs mixins ModuleResolutionKind {}

  declare export class ModuleResolutionKind {
    constructor(...args: empty): mixed;
    static Classic: Class<ModuleResolutionKind__Classic> &
      ModuleResolutionKind__Classic &
      1; // 1
    static NodeJs: Class<ModuleResolutionKind__NodeJs> &
      ModuleResolutionKind__NodeJs &
      2; // 2
  }

  declare export interface PluginImport {
    name: string;
  }
  declare export interface ProjectReference {
    /**
     * A normalized path on disk
     */
    path: string;

    /**
     * The path as the user originally wrote it
     */
    originalPath?: string;

    /**
     * True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations
     */
    prepend?: boolean;

    /**
     * True if it is intended that this reference form a circularity
     */
    circular?: boolean;
  }
  declare export type CompilerOptionsValue =
    | string
    | number
    | boolean
    | (string | number)[]
    | string[]
    | MapLike<string[]>
    | PluginImport[]
    | ProjectReference[]
    | null
    | void;
  declare export interface CompilerOptions {
    allowJs?: boolean;
    allowSyntheticDefaultImports?: boolean;
    allowUnreachableCode?: boolean;
    allowUnusedLabels?: boolean;
    alwaysStrict?: boolean;
    baseUrl?: string;
    charset?: string;
    checkJs?: boolean;
    declaration?: boolean;
    declarationMap?: boolean;
    emitDeclarationOnly?: boolean;
    declarationDir?: string;
    disableSizeLimit?: boolean;
    downlevelIteration?: boolean;
    emitBOM?: boolean;
    emitDecoratorMetadata?: boolean;
    experimentalDecorators?: boolean;
    forceConsistentCasingInFileNames?: boolean;
    importHelpers?: boolean;
    inlineSourceMap?: boolean;
    inlineSources?: boolean;
    isolatedModules?: boolean;
    jsx?: JsxEmit;
    keyofStringsOnly?: boolean;
    lib?: string[];
    locale?: string;
    mapRoot?: string;
    maxNodeModuleJsDepth?: number;
    module?: ModuleKind;
    moduleResolution?: ModuleResolutionKind;
    newLine?: NewLineKind;
    noEmit?: boolean;
    noEmitHelpers?: boolean;
    noEmitOnError?: boolean;
    noErrorTruncation?: boolean;
    noFallthroughCasesInSwitch?: boolean;
    noImplicitAny?: boolean;
    noImplicitReturns?: boolean;
    noImplicitThis?: boolean;
    noStrictGenericChecks?: boolean;
    noUnusedLocals?: boolean;
    noUnusedParameters?: boolean;
    noImplicitUseStrict?: boolean;
    noLib?: boolean;
    noResolve?: boolean;
    out?: string;
    outDir?: string;
    outFile?: string;
    paths?: MapLike<string[]>;
    preserveConstEnums?: boolean;
    preserveSymlinks?: boolean;
    project?: string;
    reactNamespace?: string;
    jsxFactory?: string;
    composite?: boolean;
    removeComments?: boolean;
    rootDir?: string;
    rootDirs?: string[];
    skipLibCheck?: boolean;
    skipDefaultLibCheck?: boolean;
    sourceMap?: boolean;
    sourceRoot?: string;
    strict?: boolean;
    strictFunctionTypes?: boolean;
    strictBindCallApply?: boolean;
    strictNullChecks?: boolean;
    strictPropertyInitialization?: boolean;
    stripInternal?: boolean;
    suppressExcessPropertyErrors?: boolean;
    suppressImplicitAnyIndexErrors?: boolean;
    target?: ScriptTarget;
    traceResolution?: boolean;
    resolveJsonModule?: boolean;
    types?: string[];

    /**
     * Paths used to compute primary types search locations
     */
    typeRoots?: string[];
    esModuleInterop?: boolean;
    [option: string]: CompilerOptionsValue | TsConfigSourceFile | void;
  }
  declare export interface TypeAcquisition {
    enableAutoDiscovery?: boolean;
    enable?: boolean;
    include?: string[];
    exclude?: string[];
    [option: string]: string[] | boolean | void;
  }
  declare class ModuleKind__None mixins ModuleKind {}
  declare class ModuleKind__CommonJS mixins ModuleKind {}
  declare class ModuleKind__AMD mixins ModuleKind {}
  declare class ModuleKind__UMD mixins ModuleKind {}
  declare class ModuleKind__System mixins ModuleKind {}
  declare class ModuleKind__ES2015 mixins ModuleKind {}
  declare class ModuleKind__ESNext mixins ModuleKind {}

  declare export class ModuleKind {
    constructor(...args: empty): mixed;
    static None: Class<ModuleKind__None> & ModuleKind__None & 0; // 0
    static CommonJS: Class<ModuleKind__CommonJS> & ModuleKind__CommonJS & 1; // 1
    static AMD: Class<ModuleKind__AMD> & ModuleKind__AMD & 2; // 2
    static UMD: Class<ModuleKind__UMD> & ModuleKind__UMD & 3; // 3
    static System: Class<ModuleKind__System> & ModuleKind__System & 4; // 4
    static ES2015: Class<ModuleKind__ES2015> & ModuleKind__ES2015 & 5; // 5
    static ESNext: Class<ModuleKind__ESNext> & ModuleKind__ESNext & 6; // 6
  }

  declare class JsxEmit__None mixins JsxEmit {}
  declare class JsxEmit__Preserve mixins JsxEmit {}
  declare class JsxEmit__React mixins JsxEmit {}
  declare class JsxEmit__ReactNative mixins JsxEmit {}

  declare export class JsxEmit {
    constructor(...args: empty): mixed;
    static None: Class<JsxEmit__None> & JsxEmit__None & 0; // 0
    static Preserve: Class<JsxEmit__Preserve> & JsxEmit__Preserve & 1; // 1
    static React: Class<JsxEmit__React> & JsxEmit__React & 2; // 2
    static ReactNative: Class<JsxEmit__ReactNative> & JsxEmit__ReactNative & 3; // 3
  }

  declare class NewLineKind__CarriageReturnLineFeed mixins NewLineKind {}
  declare class NewLineKind__LineFeed mixins NewLineKind {}

  declare export class NewLineKind {
    constructor(...args: empty): mixed;
    static CarriageReturnLineFeed: Class<NewLineKind__CarriageReturnLineFeed> &
      NewLineKind__CarriageReturnLineFeed &
      0; // 0
    static LineFeed: Class<NewLineKind__LineFeed> & NewLineKind__LineFeed & 1; // 1
  }

  declare export interface LineAndCharacter {
    /**
     * 0-based.
     */
    line: number;
    character: number;
  }
  declare class ScriptKind__Unknown mixins ScriptKind {}
  declare class ScriptKind__JS mixins ScriptKind {}
  declare class ScriptKind__JSX mixins ScriptKind {}
  declare class ScriptKind__TS mixins ScriptKind {}
  declare class ScriptKind__TSX mixins ScriptKind {}
  declare class ScriptKind__External mixins ScriptKind {}
  declare class ScriptKind__JSON mixins ScriptKind {}
  declare class ScriptKind__Deferred mixins ScriptKind {}

  declare export class ScriptKind {
    constructor(...args: empty): mixed;
    static Unknown: Class<ScriptKind__Unknown> & ScriptKind__Unknown & 0; // 0
    static JS: Class<ScriptKind__JS> & ScriptKind__JS & 1; // 1
    static JSX: Class<ScriptKind__JSX> & ScriptKind__JSX & 2; // 2
    static TS: Class<ScriptKind__TS> & ScriptKind__TS & 3; // 3
    static TSX: Class<ScriptKind__TSX> & ScriptKind__TSX & 4; // 4
    static External: Class<ScriptKind__External> & ScriptKind__External & 5; // 5
    static JSON: Class<ScriptKind__JSON> & ScriptKind__JSON & 6; // 6
    static Deferred: Class<ScriptKind__Deferred> & ScriptKind__Deferred & 7; // 7
  }

  declare class ScriptTarget__ES3 mixins ScriptTarget {}
  declare class ScriptTarget__ES5 mixins ScriptTarget {}
  declare class ScriptTarget__ES2015 mixins ScriptTarget {}
  declare class ScriptTarget__ES2016 mixins ScriptTarget {}
  declare class ScriptTarget__ES2017 mixins ScriptTarget {}
  declare class ScriptTarget__ES2018 mixins ScriptTarget {}
  declare class ScriptTarget__ESNext mixins ScriptTarget {}
  declare class ScriptTarget__JSON mixins ScriptTarget {}
  declare class ScriptTarget__Latest mixins ScriptTarget {}

  declare export class ScriptTarget {
    constructor(...args: empty): mixed;
    static ES3: Class<ScriptTarget__ES3> & ScriptTarget__ES3 & 0; // 0
    static ES5: Class<ScriptTarget__ES5> & ScriptTarget__ES5 & 1; // 1
    static ES2015: Class<ScriptTarget__ES2015> & ScriptTarget__ES2015 & 2; // 2
    static ES2016: Class<ScriptTarget__ES2016> & ScriptTarget__ES2016 & 3; // 3
    static ES2017: Class<ScriptTarget__ES2017> & ScriptTarget__ES2017 & 4; // 4
    static ES2018: Class<ScriptTarget__ES2018> & ScriptTarget__ES2018 & 5; // 5
    static ESNext: Class<ScriptTarget__ESNext> & ScriptTarget__ESNext & 6; // 6
    static JSON: Class<ScriptTarget__JSON> & ScriptTarget__JSON & 100; // 100
    static Latest: Class<ScriptTarget__Latest> & ScriptTarget__Latest & 6; // 6
  }

  declare class LanguageVariant__Standard mixins LanguageVariant {}
  declare class LanguageVariant__JSX mixins LanguageVariant {}

  declare export class LanguageVariant {
    constructor(...args: empty): mixed;
    static Standard: Class<LanguageVariant__Standard> &
      LanguageVariant__Standard &
      0; // 0
    static JSX: Class<LanguageVariant__JSX> & LanguageVariant__JSX & 1; // 1
  }

  /**
   * Either a parsed command line or a parsed tsconfig.json
   */
  declare export interface ParsedCommandLine {
    options: CompilerOptions;
    typeAcquisition?: TypeAcquisition;
    fileNames: string[];
    projectReferences?: $ReadOnlyArray<ProjectReference>;
    raw?: any;
    errors: Diagnostic[];
    wildcardDirectories?: MapLike<WatchDirectoryFlags>;
    compileOnSave?: boolean;
  }
  declare class WatchDirectoryFlags__None mixins WatchDirectoryFlags {}
  declare class WatchDirectoryFlags__Recursive mixins WatchDirectoryFlags {}

  declare export class WatchDirectoryFlags {
    constructor(...args: empty): mixed;
    static None: Class<WatchDirectoryFlags__None> &
      WatchDirectoryFlags__None &
      0; // 0
    static Recursive: Class<WatchDirectoryFlags__Recursive> &
      WatchDirectoryFlags__Recursive &
      1; // 1
  }

  declare export interface ExpandResult {
    fileNames: string[];
    wildcardDirectories: MapLike<WatchDirectoryFlags>;
  }
  declare export interface CreateProgramOptions {
    rootNames: $ReadOnlyArray<string>;
    options: CompilerOptions;
    projectReferences?: $ReadOnlyArray<ProjectReference>;
    host?: CompilerHost;
    oldProgram?: Program;
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>;
  }
  declare export interface ModuleResolutionHost {
    fileExists(fileName: string): boolean;
    readFile(fileName: string): string | void;
    trace(s: string): void;
    directoryExists(directoryName: string): boolean;

    /**
     * Resolve a symbolic link.
     * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options
     */
    realpath(path: string): string;
    getCurrentDirectory(): string;
    getDirectories(path: string): string[];
  }

  /**
 * Represents the result of module resolution.
 * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.
The Program will then filter results based on these flags.

Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.
*/
  declare export interface ResolvedModule {
    /**
     * Path of the file the module was resolved to.
     */
    resolvedFileName: string;

    /**
     * True if `resolvedFileName` comes from `node_modules`.
     */
    isExternalLibraryImport?: boolean;
  }

  /**
 * ResolvedModule with an explicitly provided `extension` property.
 * Prefer this over `ResolvedModule`.
If changing this, remember to change `moduleResolutionIsEqualTo`.
*/
  declare export type ResolvedModuleFull = {
    /**
     * Extension of resolvedFileName. This must match what's at the end of resolvedFileName.
     * This is optional for backwards-compatibility, but will be added if not provided.
     */
    extension: Extension,
    packageId?: PackageId
  } & ResolvedModule;

  /**
   * Unique identifier with a package name and version.
   * If changing this, remember to change `packageIdIsEqual`.
   */
  declare export interface PackageId {
    /**
 * Name of the package.
 * Should not include `@types`.
If accessing a non-index file, this should include its name e.g. "foo/bar".
*/
    name: string;

    /**
     * Name of a submodule within this package.
     * May be "".
     */
    subModuleName: string;

    /**
     * Version of the package, e.g. "1.2.3"
     */
    version: string;
  }
  declare class Extension__Ts mixins Extension {}
  declare class Extension__Tsx mixins Extension {}
  declare class Extension__Dts mixins Extension {}
  declare class Extension__Js mixins Extension {}
  declare class Extension__Jsx mixins Extension {}
  declare class Extension__Json mixins Extension {}

  declare export class Extension {
    constructor(...args: empty): mixed;
    static Ts: Class<Extension__Ts> & Extension__Ts & ".ts"; // ".ts"
    static Tsx: Class<Extension__Tsx> & Extension__Tsx & ".tsx"; // ".tsx"
    static Dts: Class<Extension__Dts> & Extension__Dts & ".d.ts"; // ".d.ts"
    static Js: Class<Extension__Js> & Extension__Js & ".js"; // ".js"
    static Jsx: Class<Extension__Jsx> & Extension__Jsx & ".jsx"; // ".jsx"
    static Json: Class<Extension__Json> & Extension__Json & ".json"; // ".json"
  }

  declare export interface ResolvedModuleWithFailedLookupLocations {
    resolvedModule: ResolvedModuleFull | void;
  }
  declare export interface ResolvedTypeReferenceDirective {
    primary: boolean;
    resolvedFileName: string | void;
    packageId?: PackageId;

    /**
     * True if `resolvedFileName` comes from `node_modules`.
     */
    isExternalLibraryImport?: boolean;
  }
  declare export interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
    resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | void;
    failedLookupLocations: $ReadOnlyArray<string>;
  }
  declare export type CompilerHost = {
    getSourceFile(
      fileName: string,
      languageVersion: ScriptTarget,
      onError?: (message: string) => void,
      shouldCreateNewSourceFile?: boolean
    ): SourceFile | void,
    getSourceFileByPath(
      fileName: string,
      path: Path,
      languageVersion: ScriptTarget,
      onError?: (message: string) => void,
      shouldCreateNewSourceFile?: boolean
    ): SourceFile | void,
    getCancellationToken(): CancellationToken,
    getDefaultLibFileName(options: CompilerOptions): string,
    getDefaultLibLocation(): string,
    writeFile: WriteFileCallback,
    getCurrentDirectory(): string,
    getCanonicalFileName(fileName: string): string,
    useCaseSensitiveFileNames(): boolean,
    getNewLine(): string,
    readDirectory(
      rootDir: string,
      extensions: $ReadOnlyArray<string>,
      excludes: $ReadOnlyArray<string> | void,
      includes: $ReadOnlyArray<string>,
      depth?: number
    ): string[],
    resolveModuleNames(
      moduleNames: string[],
      containingFile: string,
      reusedNames?: string[],
      redirectedReference?: ResolvedProjectReference
    ): (ResolvedModule | void)[],

    /**
     * This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files
     */
    resolveTypeReferenceDirectives(
      typeReferenceDirectiveNames: string[],
      containingFile: string,
      redirectedReference?: ResolvedProjectReference
    ): (ResolvedTypeReferenceDirective | void)[],
    getEnvironmentVariable(name: string): string | void,
    createHash(data: string): string
  } & ModuleResolutionHost;

  declare export type SourceMapRange = {
    source?: SourceMapSource
  } & TextRange;

  declare export interface SourceMapSource {
    fileName: string;
    text: string;
    skipTrivia?: (pos: number) => number;
    getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
  }
  declare class EmitFlags__None mixins EmitFlags {}
  declare class EmitFlags__SingleLine mixins EmitFlags {}
  declare class EmitFlags__AdviseOnEmitNode mixins EmitFlags {}
  declare class EmitFlags__NoSubstitution mixins EmitFlags {}
  declare class EmitFlags__CapturesThis mixins EmitFlags {}
  declare class EmitFlags__NoLeadingSourceMap mixins EmitFlags {}
  declare class EmitFlags__NoTrailingSourceMap mixins EmitFlags {}
  declare class EmitFlags__NoSourceMap mixins EmitFlags {}
  declare class EmitFlags__NoNestedSourceMaps mixins EmitFlags {}
  declare class EmitFlags__NoTokenLeadingSourceMaps mixins EmitFlags {}
  declare class EmitFlags__NoTokenTrailingSourceMaps mixins EmitFlags {}
  declare class EmitFlags__NoTokenSourceMaps mixins EmitFlags {}
  declare class EmitFlags__NoLeadingComments mixins EmitFlags {}
  declare class EmitFlags__NoTrailingComments mixins EmitFlags {}
  declare class EmitFlags__NoComments mixins EmitFlags {}
  declare class EmitFlags__NoNestedComments mixins EmitFlags {}
  declare class EmitFlags__HelperName mixins EmitFlags {}
  declare class EmitFlags__ExportName mixins EmitFlags {}
  declare class EmitFlags__LocalName mixins EmitFlags {}
  declare class EmitFlags__InternalName mixins EmitFlags {}
  declare class EmitFlags__Indented mixins EmitFlags {}
  declare class EmitFlags__NoIndentation mixins EmitFlags {}
  declare class EmitFlags__AsyncFunctionBody mixins EmitFlags {}
  declare class EmitFlags__ReuseTempVariableScope mixins EmitFlags {}
  declare class EmitFlags__CustomPrologue mixins EmitFlags {}
  declare class EmitFlags__NoHoisting mixins EmitFlags {}
  declare class EmitFlags__HasEndOfDeclarationMarker mixins EmitFlags {}
  declare class EmitFlags__Iterator mixins EmitFlags {}
  declare class EmitFlags__NoAsciiEscaping mixins EmitFlags {}

  declare export class EmitFlags {
    constructor(...args: empty): mixed;
    static None: Class<EmitFlags__None> & EmitFlags__None & 0; // 0
    static SingleLine: Class<EmitFlags__SingleLine> & EmitFlags__SingleLine & 1; // 1
    static AdviseOnEmitNode: Class<EmitFlags__AdviseOnEmitNode> &
      EmitFlags__AdviseOnEmitNode &
      2; // 2
    static NoSubstitution: Class<EmitFlags__NoSubstitution> &
      EmitFlags__NoSubstitution &
      4; // 4
    static CapturesThis: Class<EmitFlags__CapturesThis> &
      EmitFlags__CapturesThis &
      8; // 8
    static NoLeadingSourceMap: Class<EmitFlags__NoLeadingSourceMap> &
      EmitFlags__NoLeadingSourceMap &
      16; // 16
    static NoTrailingSourceMap: Class<EmitFlags__NoTrailingSourceMap> &
      EmitFlags__NoTrailingSourceMap &
      32; // 32
    static NoSourceMap: Class<EmitFlags__NoSourceMap> &
      EmitFlags__NoSourceMap &
      48; // 48
    static NoNestedSourceMaps: Class<EmitFlags__NoNestedSourceMaps> &
      EmitFlags__NoNestedSourceMaps &
      64; // 64
    static NoTokenLeadingSourceMaps: Class<EmitFlags__NoTokenLeadingSourceMaps> &
      EmitFlags__NoTokenLeadingSourceMaps &
      128; // 128
    static NoTokenTrailingSourceMaps: Class<EmitFlags__NoTokenTrailingSourceMaps> &
      EmitFlags__NoTokenTrailingSourceMaps &
      256; // 256
    static NoTokenSourceMaps: Class<EmitFlags__NoTokenSourceMaps> &
      EmitFlags__NoTokenSourceMaps &
      384; // 384
    static NoLeadingComments: Class<EmitFlags__NoLeadingComments> &
      EmitFlags__NoLeadingComments &
      512; // 512
    static NoTrailingComments: Class<EmitFlags__NoTrailingComments> &
      EmitFlags__NoTrailingComments &
      1024; // 1024
    static NoComments: Class<EmitFlags__NoComments> &
      EmitFlags__NoComments &
      1536; // 1536
    static NoNestedComments: Class<EmitFlags__NoNestedComments> &
      EmitFlags__NoNestedComments &
      2048; // 2048
    static HelperName: Class<EmitFlags__HelperName> &
      EmitFlags__HelperName &
      4096; // 4096
    static ExportName: Class<EmitFlags__ExportName> &
      EmitFlags__ExportName &
      8192; // 8192
    static LocalName: Class<EmitFlags__LocalName> &
      EmitFlags__LocalName &
      16384; // 16384
    static InternalName: Class<EmitFlags__InternalName> &
      EmitFlags__InternalName &
      32768; // 32768
    static Indented: Class<EmitFlags__Indented> & EmitFlags__Indented & 65536; // 65536
    static NoIndentation: Class<EmitFlags__NoIndentation> &
      EmitFlags__NoIndentation &
      131072; // 131072
    static AsyncFunctionBody: Class<EmitFlags__AsyncFunctionBody> &
      EmitFlags__AsyncFunctionBody &
      262144; // 262144
    static ReuseTempVariableScope: Class<EmitFlags__ReuseTempVariableScope> &
      EmitFlags__ReuseTempVariableScope &
      524288; // 524288
    static CustomPrologue: Class<EmitFlags__CustomPrologue> &
      EmitFlags__CustomPrologue &
      1048576; // 1048576
    static NoHoisting: Class<EmitFlags__NoHoisting> &
      EmitFlags__NoHoisting &
      2097152; // 2097152
    static HasEndOfDeclarationMarker: Class<EmitFlags__HasEndOfDeclarationMarker> &
      EmitFlags__HasEndOfDeclarationMarker &
      4194304; // 4194304
    static Iterator: Class<EmitFlags__Iterator> & EmitFlags__Iterator & 8388608; // 8388608
    static NoAsciiEscaping: Class<EmitFlags__NoAsciiEscaping> &
      EmitFlags__NoAsciiEscaping &
      16777216; // 16777216
  }

  declare export interface EmitHelper {
    name: string;
    scoped: boolean;
    text: string | ((node: EmitHelperUniqueNameCallback) => string);
    priority?: number;
  }
  declare export type EmitHelperUniqueNameCallback = (name: string) => string;
  declare class EmitHint__SourceFile mixins EmitHint {}
  declare class EmitHint__Expression mixins EmitHint {}
  declare class EmitHint__IdentifierName mixins EmitHint {}
  declare class EmitHint__MappedTypeParameter mixins EmitHint {}
  declare class EmitHint__Unspecified mixins EmitHint {}
  declare class EmitHint__EmbeddedStatement mixins EmitHint {}

  declare export class EmitHint {
    constructor(...args: empty): mixed;
    static SourceFile: Class<EmitHint__SourceFile> & EmitHint__SourceFile & 0; // 0
    static Expression: Class<EmitHint__Expression> & EmitHint__Expression & 1; // 1
    static IdentifierName: Class<EmitHint__IdentifierName> &
      EmitHint__IdentifierName &
      2; // 2
    static MappedTypeParameter: Class<EmitHint__MappedTypeParameter> &
      EmitHint__MappedTypeParameter &
      3; // 3
    static Unspecified: Class<EmitHint__Unspecified> &
      EmitHint__Unspecified &
      4; // 4
    static EmbeddedStatement: Class<EmitHint__EmbeddedStatement> &
      EmitHint__EmbeddedStatement &
      5; // 5
  }

  declare export interface TransformationContext {
    /**
     * Gets the compiler options supplied to the transformer.
     */
    getCompilerOptions(): CompilerOptions;

    /**
     * Starts a new lexical environment.
     */
    startLexicalEnvironment(): void;

    /**
     * Suspends the current lexical environment, usually after visiting a parameter list.
     */
    suspendLexicalEnvironment(): void;

    /**
     * Resumes a suspended lexical environment, usually before visiting a function body.
     */
    resumeLexicalEnvironment(): void;

    /**
     * Ends a lexical environment, returning any declarations.
     */
    endLexicalEnvironment(): Statement[] | void;

    /**
     * Hoists a function declaration to the containing scope.
     */
    hoistFunctionDeclaration(node: FunctionDeclaration): void;

    /**
     * Hoists a variable declaration to the containing scope.
     */
    hoistVariableDeclaration(node: Identifier): void;

    /**
     * Records a request for a non-scoped emit helper in the current context.
     */
    requestEmitHelper(helper: EmitHelper): void;

    /**
     * Gets and resets the requested non-scoped emit helpers.
     */
    readEmitHelpers(): EmitHelper[] | void;

    /**
     * Enables expression substitutions in the pretty printer for the provided SyntaxKind.
     */
    enableSubstitution(kind: SyntaxKind): void;

    /**
     * Determines whether expression substitutions are enabled for the provided node.
     */
    isSubstitutionEnabled(node: Node): boolean;

    /**
 * Hook used by transformers to substitute expressions just before they
 * are emitted by the pretty printer.

NOTE: Transformation hooks should only be modified during `Transformer` initialization,
before returning the `NodeTransformer` callback.
*/
    onSubstituteNode: (hint: EmitHint, node: Node) => Node;

    /**
     * Enables before/after emit notifications in the pretty printer for the provided
     * SyntaxKind.
     */
    enableEmitNotification(kind: SyntaxKind): void;

    /**
     * Determines whether before/after emit notifications should be raised in the pretty
     * printer when it emits a node.
     */
    isEmitNotificationEnabled(node: Node): boolean;

    /**
 * Hook used to allow transformers to capture state before or after
 * the printer emits a node.

NOTE: Transformation hooks should only be modified during `Transformer` initialization,
before returning the `NodeTransformer` callback.
*/
    onEmitNode: (
      hint: EmitHint,
      node: Node,
      emitCallback: (hint: EmitHint, node: Node) => void
    ) => void;
  }
  declare export interface TransformationResult<T: Node> {
    /**
     * Gets the transformed source files.
     */
    transformed: T[];

    /**
     * Gets diagnostics for the transformation.
     */
    diagnostics?: DiagnosticWithLocation[];

    /**
     * Gets a substitute for a node, if one is available; otherwise, returns the original node.
     * @param hint A hint as to the intended usage of the node.
     * @param node The node to substitute.
     */
    substituteNode(hint: EmitHint, node: Node): Node;

    /**
     * Emits a node with possible notification.
     * @param hint A hint as to the intended usage of the node.
     * @param node The node to emit.
     * @param emitCallback A callback used to emit the node.
     */
    emitNodeWithNotification(
      hint: EmitHint,
      node: Node,
      emitCallback: (hint: EmitHint, node: Node) => void
    ): void;

    /**
     * Clean up EmitNode entries on any parse-tree nodes.
     */
    dispose(): void;
  }

  /**
   * A function that is used to initialize and return a `Transformer` callback, which in turn
   * will be used to transform one or more nodes.
   */
  declare export type TransformerFactory<T: Node> = (
    context: TransformationContext
  ) => Transformer<T>;

  /**
   * A function that transforms a node.
   */
  declare export type Transformer<T: Node> = (node: T) => T;

  /**
   * A function that accepts and possibly transforms a node.
   */
  declare export type Visitor = (node: Node) => VisitResult<Node>;
  declare export type VisitResult<T: Node> = T | T[] | void;
  declare export interface Printer {
    /**
 * Print a node and its subtree as-is, without any emit transformations.
 * @param hint A value indicating the purpose of a node. This is primarily used to
distinguish between an `Identifier` used in an expression position, versus an
`Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you
should just pass `Unspecified`.
 * @param node The node to print. The node and its subtree are printed as-is, without any
emit transformations.
 * @param sourceFile A source file that provides context for the node. The source text of
the file is used to emit the original source content for literals and identifiers, while
the identifiers of the source file are used when generating unique names to avoid
collisions.
*/
    printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;

    /**
     * Prints a list of nodes using the given format flags
     */
    printList<T: Node>(
      format: ListFormat,
      list: NodeArray<T>,
      sourceFile: SourceFile
    ): string;

    /**
     * Prints a source file as-is, without any emit transformations.
     */
    printFile(sourceFile: SourceFile): string;

    /**
     * Prints a bundle of source files as-is, without any emit transformations.
     */
    printBundle(bundle: Bundle): string;
  }
  declare export interface PrintHandlers {
    /**
     * A hook used by the Printer when generating unique names to avoid collisions with
     * globally defined names that exist outside of the current source file.
     */
    hasGlobalName(name: string): boolean;

    /**
 * A hook used by the Printer to provide notifications prior to emitting a node. A
 * compatible implementation **must** invoke `emitCallback` with the provided `hint` and
`node` values.
 * @param hint A hint indicating the intended purpose of the node.
 * @param node The node to emit.
 * @param emitCallback A callback that, when invoked, will emit the node.
 * @example ```ts
       * var printer = createPrinter(printerOptions, {
       *   onEmitNode(hint, node, emitCallback) {
       *     // set up or track state prior to emitting the node...
       *     emitCallback(hint, node);
       *     // restore state after emitting the node...
       *   }
       * });
       * ```
*/
    onEmitNode(
      hint: EmitHint,
      node: Node | void,
      emitCallback: (hint: EmitHint, node: Node | void) => void
    ): void;

    /**
 * A hook used by the Printer to perform just-in-time substitution of a node. This is
 * primarily used by node transformations that need to substitute one node for another,
such as replacing `myExportedVar` with `exports.myExportedVar`.
 * @param hint A hint indicating the intended purpose of the node.
 * @param node The node to emit.
 * @example ```ts
       * var printer = createPrinter(printerOptions, {
       *   substituteNode(hint, node) {
       *     // perform substitution if necessary...
       *     return node;
       *   }
       * });
       * ```
*/
    substituteNode(hint: EmitHint, node: Node): Node;
  }
  declare export interface PrinterOptions {
    removeComments?: boolean;
    newLine?: NewLineKind;
    omitTrailingSemicolon?: boolean;
    noEmitHelpers?: boolean;
  }
  declare export interface GetEffectiveTypeRootsHost {
    directoryExists(directoryName: string): boolean;
    getCurrentDirectory(): string;
  }
  declare export interface TextSpan {
    start: number;
    length: number;
  }
  declare export interface TextChangeRange {
    span: TextSpan;
    newLength: number;
  }
  declare export type SyntaxList = {
    _children: Node[]
  } & Node;

  declare class ListFormat__None mixins ListFormat {}
  declare class ListFormat__SingleLine mixins ListFormat {}
  declare class ListFormat__MultiLine mixins ListFormat {}
  declare class ListFormat__PreserveLines mixins ListFormat {}
  declare class ListFormat__LinesMask mixins ListFormat {}
  declare class ListFormat__NotDelimited mixins ListFormat {}
  declare class ListFormat__BarDelimited mixins ListFormat {}
  declare class ListFormat__AmpersandDelimited mixins ListFormat {}
  declare class ListFormat__CommaDelimited mixins ListFormat {}
  declare class ListFormat__AsteriskDelimited mixins ListFormat {}
  declare class ListFormat__DelimitersMask mixins ListFormat {}
  declare class ListFormat__AllowTrailingComma mixins ListFormat {}
  declare class ListFormat__Indented mixins ListFormat {}
  declare class ListFormat__SpaceBetweenBraces mixins ListFormat {}
  declare class ListFormat__SpaceBetweenSiblings mixins ListFormat {}
  declare class ListFormat__Braces mixins ListFormat {}
  declare class ListFormat__Parenthesis mixins ListFormat {}
  declare class ListFormat__AngleBrackets mixins ListFormat {}
  declare class ListFormat__SquareBrackets mixins ListFormat {}
  declare class ListFormat__BracketsMask mixins ListFormat {}
  declare class ListFormat__OptionalIfUndefined mixins ListFormat {}
  declare class ListFormat__OptionalIfEmpty mixins ListFormat {}
  declare class ListFormat__Optional mixins ListFormat {}
  declare class ListFormat__PreferNewLine mixins ListFormat {}
  declare class ListFormat__NoTrailingNewLine mixins ListFormat {}
  declare class ListFormat__NoInterveningComments mixins ListFormat {}
  declare class ListFormat__NoSpaceIfEmpty mixins ListFormat {}
  declare class ListFormat__SingleElement mixins ListFormat {}
  declare class ListFormat__Modifiers mixins ListFormat {}
  declare class ListFormat__HeritageClauses mixins ListFormat {}
  declare class ListFormat__SingleLineTypeLiteralMembers mixins ListFormat {}
  declare class ListFormat__MultiLineTypeLiteralMembers mixins ListFormat {}
  declare class ListFormat__TupleTypeElements mixins ListFormat {}
  declare class ListFormat__UnionTypeConstituents mixins ListFormat {}
  declare class ListFormat__IntersectionTypeConstituents mixins ListFormat {}
  declare class ListFormat__ObjectBindingPatternElements mixins ListFormat {}
  declare class ListFormat__ArrayBindingPatternElements mixins ListFormat {}
  declare class ListFormat__ObjectLiteralExpressionProperties
    mixins ListFormat {}
  declare class ListFormat__ArrayLiteralExpressionElements mixins ListFormat {}
  declare class ListFormat__CommaListElements mixins ListFormat {}
  declare class ListFormat__CallExpressionArguments mixins ListFormat {}
  declare class ListFormat__NewExpressionArguments mixins ListFormat {}
  declare class ListFormat__TemplateExpressionSpans mixins ListFormat {}
  declare class ListFormat__SingleLineBlockStatements mixins ListFormat {}
  declare class ListFormat__MultiLineBlockStatements mixins ListFormat {}
  declare class ListFormat__VariableDeclarationList mixins ListFormat {}
  declare class ListFormat__SingleLineFunctionBodyStatements
    mixins ListFormat {}
  declare class ListFormat__MultiLineFunctionBodyStatements mixins ListFormat {}
  declare class ListFormat__ClassHeritageClauses mixins ListFormat {}
  declare class ListFormat__ClassMembers mixins ListFormat {}
  declare class ListFormat__InterfaceMembers mixins ListFormat {}
  declare class ListFormat__EnumMembers mixins ListFormat {}
  declare class ListFormat__CaseBlockClauses mixins ListFormat {}
  declare class ListFormat__NamedImportsOrExportsElements mixins ListFormat {}
  declare class ListFormat__JsxElementOrFragmentChildren mixins ListFormat {}
  declare class ListFormat__JsxElementAttributes mixins ListFormat {}
  declare class ListFormat__CaseOrDefaultClauseStatements mixins ListFormat {}
  declare class ListFormat__HeritageClauseTypes mixins ListFormat {}
  declare class ListFormat__SourceFileStatements mixins ListFormat {}
  declare class ListFormat__Decorators mixins ListFormat {}
  declare class ListFormat__TypeArguments mixins ListFormat {}
  declare class ListFormat__TypeParameters mixins ListFormat {}
  declare class ListFormat__Parameters mixins ListFormat {}
  declare class ListFormat__IndexSignatureParameters mixins ListFormat {}
  declare class ListFormat__JSDocComment mixins ListFormat {}

  declare export class ListFormat {
    constructor(...args: empty): mixed;
    static None: Class<ListFormat__None> & ListFormat__None & 0; // 0
    static SingleLine: Class<ListFormat__SingleLine> &
      ListFormat__SingleLine &
      0; // 0
    static MultiLine: Class<ListFormat__MultiLine> & ListFormat__MultiLine & 1; // 1
    static PreserveLines: Class<ListFormat__PreserveLines> &
      ListFormat__PreserveLines &
      2; // 2
    static LinesMask: Class<ListFormat__LinesMask> & ListFormat__LinesMask & 3; // 3
    static NotDelimited: Class<ListFormat__NotDelimited> &
      ListFormat__NotDelimited &
      0; // 0
    static BarDelimited: Class<ListFormat__BarDelimited> &
      ListFormat__BarDelimited &
      4; // 4
    static AmpersandDelimited: Class<ListFormat__AmpersandDelimited> &
      ListFormat__AmpersandDelimited &
      8; // 8
    static CommaDelimited: Class<ListFormat__CommaDelimited> &
      ListFormat__CommaDelimited &
      16; // 16
    static AsteriskDelimited: Class<ListFormat__AsteriskDelimited> &
      ListFormat__AsteriskDelimited &
      32; // 32
    static DelimitersMask: Class<ListFormat__DelimitersMask> &
      ListFormat__DelimitersMask &
      60; // 60
    static AllowTrailingComma: Class<ListFormat__AllowTrailingComma> &
      ListFormat__AllowTrailingComma &
      64; // 64
    static Indented: Class<ListFormat__Indented> & ListFormat__Indented & 128; // 128
    static SpaceBetweenBraces: Class<ListFormat__SpaceBetweenBraces> &
      ListFormat__SpaceBetweenBraces &
      256; // 256
    static SpaceBetweenSiblings: Class<ListFormat__SpaceBetweenSiblings> &
      ListFormat__SpaceBetweenSiblings &
      512; // 512
    static Braces: Class<ListFormat__Braces> & ListFormat__Braces & 1024; // 1024
    static Parenthesis: Class<ListFormat__Parenthesis> &
      ListFormat__Parenthesis &
      2048; // 2048
    static AngleBrackets: Class<ListFormat__AngleBrackets> &
      ListFormat__AngleBrackets &
      4096; // 4096
    static SquareBrackets: Class<ListFormat__SquareBrackets> &
      ListFormat__SquareBrackets &
      8192; // 8192
    static BracketsMask: Class<ListFormat__BracketsMask> &
      ListFormat__BracketsMask &
      15360; // 15360
    static OptionalIfUndefined: Class<ListFormat__OptionalIfUndefined> &
      ListFormat__OptionalIfUndefined &
      16384; // 16384
    static OptionalIfEmpty: Class<ListFormat__OptionalIfEmpty> &
      ListFormat__OptionalIfEmpty &
      32768; // 32768
    static Optional: Class<ListFormat__Optional> & ListFormat__Optional & 49152; // 49152
    static PreferNewLine: Class<ListFormat__PreferNewLine> &
      ListFormat__PreferNewLine &
      65536; // 65536
    static NoTrailingNewLine: Class<ListFormat__NoTrailingNewLine> &
      ListFormat__NoTrailingNewLine &
      131072; // 131072
    static NoInterveningComments: Class<ListFormat__NoInterveningComments> &
      ListFormat__NoInterveningComments &
      262144; // 262144
    static NoSpaceIfEmpty: Class<ListFormat__NoSpaceIfEmpty> &
      ListFormat__NoSpaceIfEmpty &
      524288; // 524288
    static SingleElement: Class<ListFormat__SingleElement> &
      ListFormat__SingleElement &
      1048576; // 1048576
    static Modifiers: Class<ListFormat__Modifiers> &
      ListFormat__Modifiers &
      262656; // 262656
    static HeritageClauses: Class<ListFormat__HeritageClauses> &
      ListFormat__HeritageClauses &
      512; // 512
    static SingleLineTypeLiteralMembers: Class<ListFormat__SingleLineTypeLiteralMembers> &
      ListFormat__SingleLineTypeLiteralMembers &
      768; // 768
    static MultiLineTypeLiteralMembers: Class<ListFormat__MultiLineTypeLiteralMembers> &
      ListFormat__MultiLineTypeLiteralMembers &
      32897; // 32897
    static TupleTypeElements: Class<ListFormat__TupleTypeElements> &
      ListFormat__TupleTypeElements &
      528; // 528
    static UnionTypeConstituents: Class<ListFormat__UnionTypeConstituents> &
      ListFormat__UnionTypeConstituents &
      516; // 516
    static IntersectionTypeConstituents: Class<ListFormat__IntersectionTypeConstituents> &
      ListFormat__IntersectionTypeConstituents &
      520; // 520
    static ObjectBindingPatternElements: Class<ListFormat__ObjectBindingPatternElements> &
      ListFormat__ObjectBindingPatternElements &
      525136; // 525136
    static ArrayBindingPatternElements: Class<ListFormat__ArrayBindingPatternElements> &
      ListFormat__ArrayBindingPatternElements &
      524880; // 524880
    static ObjectLiteralExpressionProperties: Class<ListFormat__ObjectLiteralExpressionProperties> &
      ListFormat__ObjectLiteralExpressionProperties &
      526226; // 526226
    static ArrayLiteralExpressionElements: Class<ListFormat__ArrayLiteralExpressionElements> &
      ListFormat__ArrayLiteralExpressionElements &
      8914; // 8914
    static CommaListElements: Class<ListFormat__CommaListElements> &
      ListFormat__CommaListElements &
      528; // 528
    static CallExpressionArguments: Class<ListFormat__CallExpressionArguments> &
      ListFormat__CallExpressionArguments &
      2576; // 2576
    static NewExpressionArguments: Class<ListFormat__NewExpressionArguments> &
      ListFormat__NewExpressionArguments &
      18960; // 18960
    static TemplateExpressionSpans: Class<ListFormat__TemplateExpressionSpans> &
      ListFormat__TemplateExpressionSpans &
      262144; // 262144
    static SingleLineBlockStatements: Class<ListFormat__SingleLineBlockStatements> &
      ListFormat__SingleLineBlockStatements &
      768; // 768
    static MultiLineBlockStatements: Class<ListFormat__MultiLineBlockStatements> &
      ListFormat__MultiLineBlockStatements &
      129; // 129
    static VariableDeclarationList: Class<ListFormat__VariableDeclarationList> &
      ListFormat__VariableDeclarationList &
      528; // 528
    static SingleLineFunctionBodyStatements: Class<ListFormat__SingleLineFunctionBodyStatements> &
      ListFormat__SingleLineFunctionBodyStatements &
      768; // 768
    static MultiLineFunctionBodyStatements: Class<ListFormat__MultiLineFunctionBodyStatements> &
      ListFormat__MultiLineFunctionBodyStatements &
      1; // 1
    static ClassHeritageClauses: Class<ListFormat__ClassHeritageClauses> &
      ListFormat__ClassHeritageClauses &
      0; // 0
    static ClassMembers: Class<ListFormat__ClassMembers> &
      ListFormat__ClassMembers &
      129; // 129
    static InterfaceMembers: Class<ListFormat__InterfaceMembers> &
      ListFormat__InterfaceMembers &
      129; // 129
    static EnumMembers: Class<ListFormat__EnumMembers> &
      ListFormat__EnumMembers &
      145; // 145
    static CaseBlockClauses: Class<ListFormat__CaseBlockClauses> &
      ListFormat__CaseBlockClauses &
      129; // 129
    static NamedImportsOrExportsElements: Class<ListFormat__NamedImportsOrExportsElements> &
      ListFormat__NamedImportsOrExportsElements &
      525136; // 525136
    static JsxElementOrFragmentChildren: Class<ListFormat__JsxElementOrFragmentChildren> &
      ListFormat__JsxElementOrFragmentChildren &
      262144; // 262144
    static JsxElementAttributes: Class<ListFormat__JsxElementAttributes> &
      ListFormat__JsxElementAttributes &
      262656; // 262656
    static CaseOrDefaultClauseStatements: Class<ListFormat__CaseOrDefaultClauseStatements> &
      ListFormat__CaseOrDefaultClauseStatements &
      163969; // 163969
    static HeritageClauseTypes: Class<ListFormat__HeritageClauseTypes> &
      ListFormat__HeritageClauseTypes &
      528; // 528
    static SourceFileStatements: Class<ListFormat__SourceFileStatements> &
      ListFormat__SourceFileStatements &
      131073; // 131073
    static Decorators: Class<ListFormat__Decorators> &
      ListFormat__Decorators &
      49153; // 49153
    static TypeArguments: Class<ListFormat__TypeArguments> &
      ListFormat__TypeArguments &
      53776; // 53776
    static TypeParameters: Class<ListFormat__TypeParameters> &
      ListFormat__TypeParameters &
      53776; // 53776
    static Parameters: Class<ListFormat__Parameters> &
      ListFormat__Parameters &
      2576; // 2576
    static IndexSignatureParameters: Class<ListFormat__IndexSignatureParameters> &
      ListFormat__IndexSignatureParameters &
      8848; // 8848
    static JSDocComment: Class<ListFormat__JSDocComment> &
      ListFormat__JSDocComment &
      33; // 33
  }

  declare export interface UserPreferences {
    disableSuggestions?: boolean;
    quotePreference?: "double" | "single";
    includeCompletionsForModuleExports?: boolean;
    includeCompletionsWithInsertText?: boolean;
    importModuleSpecifierPreference?: "relative" | "non-relative";

    /**
     * Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js"
     */
    importModuleSpecifierEnding?: "minimal" | "index" | "js";
    allowTextChangesInNewFiles?: boolean;
    providePrefixAndSuffixTextForRename?: boolean;
  }

  /**
   * Represents a bigint literal value without requiring bigint support
   */
  declare export interface PseudoBigInt {
    negative: boolean;
    base10Value: string;
  }
  declare class FileWatcherEventKind__Created mixins FileWatcherEventKind {}
  declare class FileWatcherEventKind__Changed mixins FileWatcherEventKind {}
  declare class FileWatcherEventKind__Deleted mixins FileWatcherEventKind {}

  declare export class FileWatcherEventKind {
    constructor(...args: empty): mixed;
    static Created: Class<FileWatcherEventKind__Created> &
      FileWatcherEventKind__Created &
      0; // 0
    static Changed: Class<FileWatcherEventKind__Changed> &
      FileWatcherEventKind__Changed &
      1; // 1
    static Deleted: Class<FileWatcherEventKind__Deleted> &
      FileWatcherEventKind__Deleted &
      2; // 2
  }

  declare export type FileWatcherCallback = (
    fileName: string,
    eventKind: FileWatcherEventKind
  ) => void;
  declare export type DirectoryWatcherCallback = (fileName: string) => void;
  declare export interface System {
    args: string[];
    newLine: string;
    useCaseSensitiveFileNames: boolean;
    write(s: string): void;
    writeOutputIsTTY(): boolean;
    readFile(path: string, encoding?: string): string | void;
    getFileSize(path: string): number;
    writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;

    /**
 * 
 * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that
use native OS file watching
*/
    watchFile(
      path: string,
      callback: FileWatcherCallback,
      pollingInterval?: number
    ): FileWatcher;
    watchDirectory(
      path: string,
      callback: DirectoryWatcherCallback,
      recursive?: boolean
    ): FileWatcher;
    resolvePath(path: string): string;
    fileExists(path: string): boolean;
    directoryExists(path: string): boolean;
    createDirectory(path: string): void;
    getExecutingFilePath(): string;
    getCurrentDirectory(): string;
    getDirectories(path: string): string[];
    readDirectory(
      path: string,
      extensions?: $ReadOnlyArray<string>,
      exclude?: $ReadOnlyArray<string>,
      include?: $ReadOnlyArray<string>,
      depth?: number
    ): string[];
    getModifiedTime(path: string): Date | void;
    setModifiedTime(path: string, time: Date): void;
    deleteFile(path: string): void;

    /**
     * A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)
     */
    createHash(data: string): string;

    /**
     * This must be cryptographically secure. Only implement this method using `crypto.createHash("sha256")`.
     */
    createSHA256Hash(data: string): string;
    getMemoryUsage(): number;
    exit(exitCode?: number): void;
    realpath(path: string): string;
    setTimeout(
      callback: (...args: any[]) => void,
      ms: number,
      ...args: any[]
    ): any;
    clearTimeout(timeoutId: any): void;
    clearScreen(): void;
    base64decode(input: string): string;
    base64encode(input: string): string;
  }
  declare export interface FileWatcher {
    close(): void;
  }
  declare export function getNodeMajorVersion(): number | void;

  declare export var sys: System;
  declare export type ErrorCallback = (
    message: DiagnosticMessage,
    length: number
  ) => void;
  declare export interface Scanner {
    getStartPos(): number;
    getToken(): SyntaxKind;
    getTextPos(): number;
    getTokenPos(): number;
    getTokenText(): string;
    getTokenValue(): string;
    hasExtendedUnicodeEscape(): boolean;
    hasPrecedingLineBreak(): boolean;
    isIdentifier(): boolean;
    isReservedWord(): boolean;
    isUnterminated(): boolean;
    reScanGreaterToken(): SyntaxKind;
    reScanSlashToken(): SyntaxKind;
    reScanTemplateToken(): SyntaxKind;
    scanJsxIdentifier(): SyntaxKind;
    scanJsxAttributeValue(): SyntaxKind;
    reScanJsxToken(): JsxTokenSyntaxKind;
    reScanLessThanToken(): SyntaxKind;
    scanJsxToken(): JsxTokenSyntaxKind;
    scanJSDocToken(): JsDocSyntaxKind;
    scan(): SyntaxKind;
    getText(): string;
    setText(text: string | void, start?: number, length?: number): void;
    setOnError(onError: ErrorCallback | void): void;
    setScriptTarget(scriptTarget: ScriptTarget): void;
    setLanguageVariant(variant: LanguageVariant): void;
    setTextPos(textPos: number): void;
    lookAhead<T>(callback: () => T): T;
    scanRange<T>(start: number, length: number, callback: () => T): T;
    tryScan<T>(callback: () => T): T;
  }
  declare export function tokenToString(t: SyntaxKind): string | void;

  declare export function getPositionOfLineAndCharacter(
    sourceFile: SourceFileLike,
    line: number,
    character: number
  ): number;

  declare export function getLineAndCharacterOfPosition(
    sourceFile: SourceFileLike,
    position: number
  ): LineAndCharacter;

  declare export function isWhiteSpaceLike(ch: number): boolean;

  /**
   * Does not include line breaks. For that, see isWhiteSpaceLike.
   */
  declare export function isWhiteSpaceSingleLine(ch: number): boolean;

  declare export function isLineBreak(ch: number): boolean;

  declare export function couldStartTrivia(text: string, pos: number): boolean;

  declare export function forEachLeadingCommentRange<U>(
    text: string,
    pos: number,
    cb: (
      pos: number,
      end: number,
      kind: CommentKind,
      hasTrailingNewLine: boolean
    ) => U
  ): U | void;

  declare export function forEachLeadingCommentRange<T, U>(
    text: string,
    pos: number,
    cb: (
      pos: number,
      end: number,
      kind: CommentKind,
      hasTrailingNewLine: boolean,
      state: T
    ) => U,
    state: T
  ): U | void;

  declare export function forEachTrailingCommentRange<U>(
    text: string,
    pos: number,
    cb: (
      pos: number,
      end: number,
      kind: CommentKind,
      hasTrailingNewLine: boolean
    ) => U
  ): U | void;

  declare export function forEachTrailingCommentRange<T, U>(
    text: string,
    pos: number,
    cb: (
      pos: number,
      end: number,
      kind: CommentKind,
      hasTrailingNewLine: boolean,
      state: T
    ) => U,
    state: T
  ): U | void;

  declare export function reduceEachLeadingCommentRange<T, U>(
    text: string,
    pos: number,
    cb: (
      pos: number,
      end: number,
      kind: CommentKind,
      hasTrailingNewLine: boolean,
      state: T,
      memo: U
    ) => U,
    state: T,
    initial: U
  ): U | void;

  declare export function reduceEachTrailingCommentRange<T, U>(
    text: string,
    pos: number,
    cb: (
      pos: number,
      end: number,
      kind: CommentKind,
      hasTrailingNewLine: boolean,
      state: T,
      memo: U
    ) => U,
    state: T,
    initial: U
  ): U | void;

  declare export function getLeadingCommentRanges(
    text: string,
    pos: number
  ): CommentRange[] | void;

  declare export function getTrailingCommentRanges(
    text: string,
    pos: number
  ): CommentRange[] | void;

  /**
   * Optionally, get the shebang
   */
  declare export function getShebang(text: string): string | void;

  declare export function isIdentifierStart(
    ch: number,
    languageVersion: ScriptTarget | void
  ): boolean;

  declare export function isIdentifierPart(
    ch: number,
    languageVersion: ScriptTarget | void
  ): boolean;

  declare export function createScanner(
    languageVersion: ScriptTarget,
    skipTrivia: boolean,
    languageVariant?: LanguageVariant,
    textInitial?: string,
    onError?: ErrorCallback,
    start?: number,
    length?: number
  ): Scanner;

  declare export function isExternalModuleNameRelative(moduleName: string): boolean;

  declare export function sortAndDeduplicateDiagnostics<T: Diagnostic>(
    diagnostics: $ReadOnlyArray<T>
  ): SortedReadonlyArray<T>;

  declare export function getDefaultLibFileName(options: CompilerOptions): string;

  declare export function textSpanEnd(span: TextSpan): number;

  declare export function textSpanIsEmpty(span: TextSpan): boolean;

  declare export function textSpanContainsPosition(
    span: TextSpan,
    position: number
  ): boolean;

  declare export function textSpanContainsTextSpan(
    span: TextSpan,
    other: TextSpan
  ): boolean;

  declare export function textSpanOverlapsWith(
    span: TextSpan,
    other: TextSpan
  ): boolean;

  declare export function textSpanOverlap(
    span1: TextSpan,
    span2: TextSpan
  ): TextSpan | void;

  declare export function textSpanIntersectsWithTextSpan(
    span: TextSpan,
    other: TextSpan
  ): boolean;

  declare export function textSpanIntersectsWith(
    span: TextSpan,
    start: number,
    length: number
  ): boolean;

  declare export function decodedTextSpanIntersectsWith(
    start1: number,
    length1: number,
    start2: number,
    length2: number
  ): boolean;

  declare export function textSpanIntersectsWithPosition(
    span: TextSpan,
    position: number
  ): boolean;

  declare export function textSpanIntersection(
    span1: TextSpan,
    span2: TextSpan
  ): TextSpan | void;

  declare export function createTextSpan(start: number, length: number): TextSpan;

  declare export function createTextSpanFromBounds(
    start: number,
    end: number
  ): TextSpan;

  declare export function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;

  declare export function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;

  declare export function createTextChangeRange(
    span: TextSpan,
    newLength: number
  ): TextChangeRange;

  declare export var unchangedTextChangeRange: TextChangeRange;

  /**
 * Called to merge all the changes that occurred across several versions of a script snapshot
 * into a single change.  i.e. if a user keeps making successive edits to a script we will
have a text change from V1 to V2, V2 to V3, ..., Vn.

This function will then merge those changes into a single change range valid between V1 and
Vn.
*/
  declare export function collapseTextChangeRangesAcrossMultipleVersions(
    changes: $ReadOnlyArray<TextChangeRange>
  ): TextChangeRange;

  declare export function getTypeParameterOwner(d: Declaration): Declaration | void;

  declare export type ParameterPropertyDeclaration = ParameterDeclaration & {
    parent: ConstructorDeclaration,
    name: Identifier
  };
  declare export function isParameterPropertyDeclaration(node: Node): boolean;

  declare export function isEmptyBindingPattern(node: BindingName): boolean;

  declare export function isEmptyBindingElement(node: BindingElement): boolean;

  declare export function walkUpBindingElementsAndPatterns(
    binding: BindingElement
  ): VariableDeclaration | ParameterDeclaration;

  declare export function getCombinedModifierFlags(node: Declaration): ModifierFlags;

  declare export function getCombinedNodeFlags(node: Node): NodeFlags;

  /**
   * Checks to see if the locale is in the appropriate format,
   * and if it is, attempts to set the appropriate language.
   */
  declare export function validateLocaleAndSetLanguage(
    locale: string,
    sys: {
      getExecutingFilePath(): string,
      resolvePath(path: string): string,
      fileExists(fileName: string): boolean,
      readFile(fileName: string): string | void
    },
    errors?: Push<Diagnostic>
  ): void;

  declare export function getOriginalNode(node: Node): Node;

  declare export function getOriginalNode<T: Node>(
    node: Node,
    nodeTest: (node: Node) => boolean
  ): T;

  declare export function getOriginalNode(node: Node | void): Node | void;

  declare export function getOriginalNode<T: Node>(
    node: Node | void,
    nodeTest: (node: Node | void) => boolean
  ): T | void;

  /**
   * Gets a value indicating whether a node originated in the parse tree.
   * @param node The node to test.
   */
  declare export function isParseTreeNode(node: Node): boolean;

  /**
   * Gets the original parse tree node for a node.
   * @param node The original node.
   * @returns The original parse tree node if found; otherwise, undefined.
   */
  declare export function getParseTreeNode(node: Node): Node;

  /**
   * Gets the original parse tree node for a node.
   * @param node The original node.
   * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
   * @returns The original parse tree node if found; otherwise, undefined.
   */
  declare export function getParseTreeNode<T: Node>(
    node: Node | void,
    nodeTest?: (node: Node) => boolean
  ): T | void;

  /**
   * Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'
   */
  declare export function escapeLeadingUnderscores(identifier: string): __String;

  /**
   * Remove extra underscore from escaped identifier text content.
   * @param identifier The escaped identifier text.
   * @returns The unescaped identifier text.
   */
  declare export function unescapeLeadingUnderscores(identifier: __String): string;

  declare export function idText(identifier: Identifier): string;

  declare export function symbolName(symbol: Symbol): string;

  declare export function getNameOfJSDocTypedef(
    declaration: JSDocTypedefTag
  ): Identifier | void;

  declare export function getNameOfDeclaration(
    declaration: Declaration | Expression
  ): DeclarationName | void;

  /**
 * Gets the JSDoc parameter tags for the node if present.
 * @remarks Returns any JSDoc param tag whose name matches the provided
parameter, whether a param tag on a containing function
expression, or a param tag on a variable declaration whose
initializer is the containing function. The tags closest to the
node are returned first, so in the previous example, the param
tag on the containing function expression would be first.

For binding patterns, parameter tags are matched by position.
*/
  declare export function getJSDocParameterTags(
    param: ParameterDeclaration
  ): $ReadOnlyArray<JSDocParameterTag>;

  /**
 * Gets the JSDoc type parameter tags for the node if present.
 * @remarks Returns any JSDoc template tag whose names match the provided
parameter, whether a template tag on a containing function
expression, or a template tag on a variable declaration whose
initializer is the containing function. The tags closest to the
node are returned first, so in the previous example, the template
tag on the containing function expression would be first.
*/
  declare export function getJSDocTypeParameterTags(
    param: TypeParameterDeclaration
  ): $ReadOnlyArray<JSDocTemplateTag>;

  /**
 * Return true if the node has JSDoc parameter tags.
 * @remarks Includes parameter tags that are not directly on the node,
for example on a variable declaration whose initializer is a function expression.
*/
  declare export function hasJSDocParameterTags(
    node: FunctionLikeDeclaration | SignatureDeclaration
  ): boolean;

  /**
   * Gets the JSDoc augments tag for the node if present
   */
  declare export function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | void;

  /**
   * Gets the JSDoc class tag for the node if present
   */
  declare export function getJSDocClassTag(node: Node): JSDocClassTag | void;

  /**
   * Gets the JSDoc enum tag for the node if present
   */
  declare export function getJSDocEnumTag(node: Node): JSDocEnumTag | void;

  /**
   * Gets the JSDoc this tag for the node if present
   */
  declare export function getJSDocThisTag(node: Node): JSDocThisTag | void;

  /**
   * Gets the JSDoc return tag for the node if present
   */
  declare export function getJSDocReturnTag(node: Node): JSDocReturnTag | void;

  /**
   * Gets the JSDoc template tag for the node if present
   */
  declare export function getJSDocTemplateTag(node: Node): JSDocTemplateTag | void;

  /**
   * Gets the JSDoc type tag for the node if present and valid
   */
  declare export function getJSDocTypeTag(node: Node): JSDocTypeTag | void;

  /**
 * Gets the type node for the node if provided via JSDoc.
 * @remarks The search includes any JSDoc param tag that relates
to the provided parameter, for example a type tag on the
parameter itself, or a param tag on a containing function
expression, or a param tag on a variable declaration whose
initializer is the containing function. The tags closest to the
node are examined first, so in the previous example, the type
tag directly on the node would be returned.
*/
  declare export function getJSDocType(node: Node): TypeNode | void;

  /**
 * Gets the return type node for the node if provided via JSDoc return tag or type tag.
 * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
gets the type from inside the braces, after the fat arrow, etc.
*/
  declare export function getJSDocReturnType(node: Node): TypeNode | void;

  /**
   * Get all JSDoc tags related to a node, including those on parent nodes.
   */
  declare export function getJSDocTags(node: Node): $ReadOnlyArray<JSDocTag>;

  /**
   * Gets all JSDoc tags of a specified kind, or undefined if not present.
   */
  declare export function getAllJSDocTagsOfKind(
    node: Node,
    kind: SyntaxKind
  ): $ReadOnlyArray<JSDocTag>;

  /**
   * Gets the effective type parameters. If the node was parsed in a
   * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
   */
  declare export function getEffectiveTypeParameterDeclarations(
    node: DeclarationWithTypeParameters
  ): $ReadOnlyArray<TypeParameterDeclaration>;

  declare export function getEffectiveConstraintOfTypeParameter(
    node: TypeParameterDeclaration
  ): TypeNode | void;

  declare export function isNumericLiteral(node: Node): boolean;

  declare export function isBigIntLiteral(node: Node): boolean;

  declare export function isStringLiteral(node: Node): boolean;

  declare export function isJsxText(node: Node): boolean;

  declare export function isRegularExpressionLiteral(node: Node): boolean;

  declare export function isNoSubstitutionTemplateLiteral(node: Node): boolean;

  declare export function isTemplateHead(node: Node): boolean;

  declare export function isTemplateMiddle(node: Node): boolean;

  declare export function isTemplateTail(node: Node): boolean;

  declare export function isIdentifier(node: Node): boolean;

  declare export function isQualifiedName(node: Node): boolean;

  declare export function isComputedPropertyName(node: Node): boolean;

  declare export function isTypeParameterDeclaration(node: Node): boolean;

  declare export function isParameter(node: Node): boolean;

  declare export function isDecorator(node: Node): boolean;

  declare export function isPropertySignature(node: Node): boolean;

  declare export function isPropertyDeclaration(node: Node): boolean;

  declare export function isMethodSignature(node: Node): boolean;

  declare export function isMethodDeclaration(node: Node): boolean;

  declare export function isConstructorDeclaration(node: Node): boolean;

  declare export function isGetAccessorDeclaration(node: Node): boolean;

  declare export function isSetAccessorDeclaration(node: Node): boolean;

  declare export function isCallSignatureDeclaration(node: Node): boolean;

  declare export function isConstructSignatureDeclaration(node: Node): boolean;

  declare export function isIndexSignatureDeclaration(node: Node): boolean;

  declare export function isTypePredicateNode(node: Node): boolean;

  declare export function isTypeReferenceNode(node: Node): boolean;

  declare export function isFunctionTypeNode(node: Node): boolean;

  declare export function isConstructorTypeNode(node: Node): boolean;

  declare export function isTypeQueryNode(node: Node): boolean;

  declare export function isTypeLiteralNode(node: Node): boolean;

  declare export function isArrayTypeNode(node: Node): boolean;

  declare export function isTupleTypeNode(node: Node): boolean;

  declare export function isUnionTypeNode(node: Node): boolean;

  declare export function isIntersectionTypeNode(node: Node): boolean;

  declare export function isConditionalTypeNode(node: Node): boolean;

  declare export function isInferTypeNode(node: Node): boolean;

  declare export function isParenthesizedTypeNode(node: Node): boolean;

  declare export function isThisTypeNode(node: Node): boolean;

  declare export function isTypeOperatorNode(node: Node): boolean;

  declare export function isIndexedAccessTypeNode(node: Node): boolean;

  declare export function isMappedTypeNode(node: Node): boolean;

  declare export function isLiteralTypeNode(node: Node): boolean;

  declare export function isImportTypeNode(node: Node): boolean;

  declare export function isObjectBindingPattern(node: Node): boolean;

  declare export function isArrayBindingPattern(node: Node): boolean;

  declare export function isBindingElement(node: Node): boolean;

  declare export function isArrayLiteralExpression(node: Node): boolean;

  declare export function isObjectLiteralExpression(node: Node): boolean;

  declare export function isPropertyAccessExpression(node: Node): boolean;

  declare export function isElementAccessExpression(node: Node): boolean;

  declare export function isCallExpression(node: Node): boolean;

  declare export function isNewExpression(node: Node): boolean;

  declare export function isTaggedTemplateExpression(node: Node): boolean;

  declare export function isTypeAssertion(node: Node): boolean;

  declare export function isParenthesizedExpression(node: Node): boolean;

  declare export function skipPartiallyEmittedExpressions(
    node: Expression
  ): Expression;

  declare export function skipPartiallyEmittedExpressions(node: Node): Node;

  declare export function isFunctionExpression(node: Node): boolean;

  declare export function isArrowFunction(node: Node): boolean;

  declare export function isDeleteExpression(node: Node): boolean;

  declare export function isTypeOfExpression(node: Node): boolean;

  declare export function isVoidExpression(node: Node): boolean;

  declare export function isAwaitExpression(node: Node): boolean;

  declare export function isPrefixUnaryExpression(node: Node): boolean;

  declare export function isPostfixUnaryExpression(node: Node): boolean;

  declare export function isBinaryExpression(node: Node): boolean;

  declare export function isConditionalExpression(node: Node): boolean;

  declare export function isTemplateExpression(node: Node): boolean;

  declare export function isYieldExpression(node: Node): boolean;

  declare export function isSpreadElement(node: Node): boolean;

  declare export function isClassExpression(node: Node): boolean;

  declare export function isOmittedExpression(node: Node): boolean;

  declare export function isExpressionWithTypeArguments(node: Node): boolean;

  declare export function isAsExpression(node: Node): boolean;

  declare export function isNonNullExpression(node: Node): boolean;

  declare export function isMetaProperty(node: Node): boolean;

  declare export function isTemplateSpan(node: Node): boolean;

  declare export function isSemicolonClassElement(node: Node): boolean;

  declare export function isBlock(node: Node): boolean;

  declare export function isVariableStatement(node: Node): boolean;

  declare export function isEmptyStatement(node: Node): boolean;

  declare export function isExpressionStatement(node: Node): boolean;

  declare export function isIfStatement(node: Node): boolean;

  declare export function isDoStatement(node: Node): boolean;

  declare export function isWhileStatement(node: Node): boolean;

  declare export function isForStatement(node: Node): boolean;

  declare export function isForInStatement(node: Node): boolean;

  declare export function isForOfStatement(node: Node): boolean;

  declare export function isContinueStatement(node: Node): boolean;

  declare export function isBreakStatement(node: Node): boolean;

  declare export function isBreakOrContinueStatement(node: Node): boolean;

  declare export function isReturnStatement(node: Node): boolean;

  declare export function isWithStatement(node: Node): boolean;

  declare export function isSwitchStatement(node: Node): boolean;

  declare export function isLabeledStatement(node: Node): boolean;

  declare export function isThrowStatement(node: Node): boolean;

  declare export function isTryStatement(node: Node): boolean;

  declare export function isDebuggerStatement(node: Node): boolean;

  declare export function isVariableDeclaration(node: Node): boolean;

  declare export function isVariableDeclarationList(node: Node): boolean;

  declare export function isFunctionDeclaration(node: Node): boolean;

  declare export function isClassDeclaration(node: Node): boolean;

  declare export function isInterfaceDeclaration(node: Node): boolean;

  declare export function isTypeAliasDeclaration(node: Node): boolean;

  declare export function isEnumDeclaration(node: Node): boolean;

  declare export function isModuleDeclaration(node: Node): boolean;

  declare export function isModuleBlock(node: Node): boolean;

  declare export function isCaseBlock(node: Node): boolean;

  declare export function isNamespaceExportDeclaration(node: Node): boolean;

  declare export function isImportEqualsDeclaration(node: Node): boolean;

  declare export function isImportDeclaration(node: Node): boolean;

  declare export function isImportClause(node: Node): boolean;

  declare export function isNamespaceImport(node: Node): boolean;

  declare export function isNamedImports(node: Node): boolean;

  declare export function isImportSpecifier(node: Node): boolean;

  declare export function isExportAssignment(node: Node): boolean;

  declare export function isExportDeclaration(node: Node): boolean;

  declare export function isNamedExports(node: Node): boolean;

  declare export function isExportSpecifier(node: Node): boolean;

  declare export function isMissingDeclaration(node: Node): boolean;

  declare export function isExternalModuleReference(node: Node): boolean;

  declare export function isJsxElement(node: Node): boolean;

  declare export function isJsxSelfClosingElement(node: Node): boolean;

  declare export function isJsxOpeningElement(node: Node): boolean;

  declare export function isJsxClosingElement(node: Node): boolean;

  declare export function isJsxFragment(node: Node): boolean;

  declare export function isJsxOpeningFragment(node: Node): boolean;

  declare export function isJsxClosingFragment(node: Node): boolean;

  declare export function isJsxAttribute(node: Node): boolean;

  declare export function isJsxAttributes(node: Node): boolean;

  declare export function isJsxSpreadAttribute(node: Node): boolean;

  declare export function isJsxExpression(node: Node): boolean;

  declare export function isCaseClause(node: Node): boolean;

  declare export function isDefaultClause(node: Node): boolean;

  declare export function isHeritageClause(node: Node): boolean;

  declare export function isCatchClause(node: Node): boolean;

  declare export function isPropertyAssignment(node: Node): boolean;

  declare export function isShorthandPropertyAssignment(node: Node): boolean;

  declare export function isSpreadAssignment(node: Node): boolean;

  declare export function isEnumMember(node: Node): boolean;

  declare export function isSourceFile(node: Node): boolean;

  declare export function isBundle(node: Node): boolean;

  declare export function isUnparsedSource(node: Node): boolean;

  declare export function isJSDocTypeExpression(node: Node): boolean;

  declare export function isJSDocAllType(node: JSDocAllType): boolean;

  declare export function isJSDocUnknownType(node: Node): boolean;

  declare export function isJSDocNullableType(node: Node): boolean;

  declare export function isJSDocNonNullableType(node: Node): boolean;

  declare export function isJSDocOptionalType(node: Node): boolean;

  declare export function isJSDocFunctionType(node: Node): boolean;

  declare export function isJSDocVariadicType(node: Node): boolean;

  declare export function isJSDoc(node: Node): boolean;

  declare export function isJSDocAugmentsTag(node: Node): boolean;

  declare export function isJSDocClassTag(node: Node): boolean;

  declare export function isJSDocEnumTag(node: Node): boolean;

  declare export function isJSDocThisTag(node: Node): boolean;

  declare export function isJSDocParameterTag(node: Node): boolean;

  declare export function isJSDocReturnTag(node: Node): boolean;

  declare export function isJSDocTypeTag(node: Node): boolean;

  declare export function isJSDocTemplateTag(node: Node): boolean;

  declare export function isJSDocTypedefTag(node: Node): boolean;

  declare export function isJSDocPropertyTag(node: Node): boolean;

  declare export function isJSDocPropertyLikeTag(node: Node): boolean;

  declare export function isJSDocTypeLiteral(node: Node): boolean;

  declare export function isJSDocCallbackTag(node: Node): boolean;

  declare export function isJSDocSignature(node: Node): boolean;

  /**
 * True if node is of some token syntax kind.
 * For example, this is true for an IfKeyword but not for an IfStatement.
Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
*/
  declare export function isToken(n: Node): boolean;

  declare export function isLiteralExpression(node: Node): boolean;

  declare export type TemplateLiteralToken =
    | NoSubstitutionTemplateLiteral
    | TemplateHead
    | TemplateMiddle
    | TemplateTail;
  declare export function isTemplateLiteralToken(node: Node): boolean;

  declare export function isTemplateMiddleOrTemplateTail(node: Node): boolean;

  declare export function isImportOrExportSpecifier(node: Node): boolean;

  declare export function isStringTextContainingNode(node: Node): boolean;

  declare export function isModifier(node: Node): boolean;

  declare export function isEntityName(node: Node): boolean;

  declare export function isPropertyName(node: Node): boolean;

  declare export function isBindingName(node: Node): boolean;

  declare export function isFunctionLike(node: Node): boolean;

  declare export function isClassElement(node: Node): boolean;

  declare export function isClassLike(node: Node): boolean;

  declare export function isAccessor(node: Node): boolean;

  declare export function isTypeElement(node: Node): boolean;

  declare export function isClassOrTypeElement(node: Node): boolean;

  declare export function isObjectLiteralElementLike(node: Node): boolean;

  /**
 * Node test that determines whether a node is a valid type node.
 * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
of a TypeNode.
*/
  declare export function isTypeNode(node: Node): boolean;

  declare export function isFunctionOrConstructorTypeNode(node: Node): boolean;

  declare export function isPropertyAccessOrQualifiedName(node: Node): boolean;

  declare export function isCallLikeExpression(node: Node): boolean;

  declare export function isCallOrNewExpression(node: Node): boolean;

  declare export function isTemplateLiteral(node: Node): boolean;

  declare export function isAssertionExpression(node: Node): boolean;

  declare export function isIterationStatement(
    node: Node,
    lookInLabeledStatements: false
  ): boolean;

  declare export function isIterationStatement(
    node: Node,
    lookInLabeledStatements: boolean
  ): boolean;

  declare export function isJsxOpeningLikeElement(node: Node): boolean;

  declare export function isCaseOrDefaultClause(node: Node): boolean;

  /**
   * True if node is of a kind that may contain comment text.
   */
  declare export function isJSDocCommentContainingNode(node: Node): boolean;

  declare export function isSetAccessor(node: Node): boolean;

  declare export function isGetAccessor(node: Node): boolean;

  declare export function isObjectLiteralElement(node: Node): boolean;

  declare export function isStringLiteralLike(node: Node): boolean;

  declare export function createNode(
    kind: SyntaxKind,
    pos?: number,
    end?: number
  ): Node;

  /**
 * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
 * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
 * @param node a given node to visit its children
 * @param cbNode a callback to be invoked for all child nodes
 * @param cbNodes a callback to be invoked for embedded array
 * @remarks `forEachChild` must visit the children of a node in the order
that they appear in the source code. The language service depends on this property to locate nodes by position.
*/
  declare export function forEachChild<T>(
    node: Node,
    cbNode: (node: Node) => T | void,
    cbNodes?: (nodes: NodeArray<Node>) => T | void
  ): T | void;

  declare export function createSourceFile(
    fileName: string,
    sourceText: string,
    languageVersion: ScriptTarget,
    setParentNodes?: boolean,
    scriptKind?: ScriptKind
  ): SourceFile;

  declare export function parseIsolatedEntityName(
    text: string,
    languageVersion: ScriptTarget
  ): EntityName | void;

  /**
   * Parse json text into SyntaxTree and return node and parse errors if any
   * @param fileName
   * @param sourceText
   */
  declare export function parseJsonText(
    fileName: string,
    sourceText: string
  ): JsonSourceFile;

  declare export function isExternalModule(file: SourceFile): boolean;

  declare export function updateSourceFile(
    sourceFile: SourceFile,
    newText: string,
    textChangeRange: TextChangeRange,
    aggressiveChecks?: boolean
  ): SourceFile;

  declare export function parseCommandLine(
    commandLine: $ReadOnlyArray<string>,
    readFile?: (path: string) => string | void
  ): ParsedCommandLine;

  declare export type DiagnosticReporter = (diagnostic: Diagnostic) => void;

  /**
   * Reports config file diagnostics
   */
  declare export interface ConfigFileDiagnosticsReporter {
    /**
     * Reports unrecoverable error when parsing config file
     */
    onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
  }

  /**
   * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
   */
  declare export type ParseConfigFileHost = {
    getCurrentDirectory(): string
  } & ParseConfigHost &
    ConfigFileDiagnosticsReporter;

  /**
   * Reads the config file, reports errors if any and exits if the config file cannot be found
   */
  declare export function getParsedCommandLineOfConfigFile(
    configFileName: string,
    optionsToExtend: CompilerOptions,
    host: ParseConfigFileHost
  ): ParsedCommandLine | void;

  /**
   * Read tsconfig.json file
   * @param fileName The path to the config file
   */
  declare export function readConfigFile(
    fileName: string,
    readFile: (path: string) => string | void
  ): {
    config?: any,
    error?: Diagnostic
  };

  /**
   * Parse the text of the tsconfig.json file
   * @param fileName The path to the config file
   * @param jsonText The text of the config file
   */
  declare export function parseConfigFileTextToJson(
    fileName: string,
    jsonText: string
  ): {
    config?: any,
    error?: Diagnostic
  };

  /**
   * Read tsconfig.json file
   * @param fileName The path to the config file
   */
  declare export function readJsonConfigFile(
    fileName: string,
    readFile: (path: string) => string | void
  ): TsConfigSourceFile;

  /**
   * Convert the json syntax tree into the json value
   */
  declare export function convertToObject(
    sourceFile: JsonSourceFile,
    errors: Push<Diagnostic>
  ): any;

  /**
 * Parse the contents of a config file (tsconfig.json).
 * @param json The contents of the config file to parse
 * @param host Instance of ParseConfigHost used to enumerate files in folder.
 * @param basePath A root directory to resolve relative path entries in the config
file to. e.g. outDir
*/
  declare export function parseJsonConfigFileContent(
    json: any,
    host: ParseConfigHost,
    basePath: string,
    existingOptions?: CompilerOptions,
    configFileName?: string,
    resolutionStack?: Path[],
    extraFileExtensions?: $ReadOnlyArray<FileExtensionInfo>
  ): ParsedCommandLine;

  /**
 * Parse the contents of a config file (tsconfig.json).
 * @param jsonNode The contents of the config file to parse
 * @param host Instance of ParseConfigHost used to enumerate files in folder.
 * @param basePath A root directory to resolve relative path entries in the config
file to. e.g. outDir
*/
  declare export function parseJsonSourceFileConfigFileContent(
    sourceFile: TsConfigSourceFile,
    host: ParseConfigHost,
    basePath: string,
    existingOptions?: CompilerOptions,
    configFileName?: string,
    resolutionStack?: Path[],
    extraFileExtensions?: $ReadOnlyArray<FileExtensionInfo>
  ): ParsedCommandLine;

  declare export function convertCompilerOptionsFromJson(
    jsonOptions: any,
    basePath: string,
    configFileName?: string
  ): {
    options: CompilerOptions,
    errors: Diagnostic[]
  };

  declare export function convertTypeAcquisitionFromJson(
    jsonOptions: any,
    basePath: string,
    configFileName?: string
  ): {
    options: TypeAcquisition,
    errors: Diagnostic[]
  };

  declare export function getEffectiveTypeRoots(
    options: CompilerOptions,
    host: GetEffectiveTypeRootsHost
  ): string[] | void;

  /**
 * 
 * @param {string | void} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
is assumed to be the same as root directory of the project.
*/
  declare export function resolveTypeReferenceDirective(
    typeReferenceDirectiveName: string,
    containingFile: string | void,
    options: CompilerOptions,
    host: ModuleResolutionHost,
    redirectedReference?: ResolvedProjectReference
  ): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;

  /**
 * Given a set of options, returns the set of type directive names
 *    that should be included for this program automatically.
This list could either come from the config file,
   or from enumerating the types root + initial secondary types lookup location.
More type directives might appear in the program later as a result of loading actual source files;
   this list is only the set of defaults that are implicitly included.
*/
  declare export function getAutomaticTypeDirectiveNames(
    options: CompilerOptions,
    host: ModuleResolutionHost
  ): string[];

  /**
   * Cached module resolutions per containing directory.
   * This assumes that any module id will have the same resolution for sibling files located in the same folder.
   */
  declare export type ModuleResolutionCache = {
    getOrCreateCacheForDirectory(
      directoryName: string,
      redirectedReference?: ResolvedProjectReference
    ): Map<ResolvedModuleWithFailedLookupLocations>
  } & NonRelativeModuleNameResolutionCache;

  /**
   * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory
   * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.
   */
  declare export interface NonRelativeModuleNameResolutionCache {
    getOrCreateCacheForModuleName(
      nonRelativeModuleName: string,
      redirectedReference?: ResolvedProjectReference
    ): PerModuleNameCache;
  }
  declare export interface PerModuleNameCache {
    get(directory: string): ResolvedModuleWithFailedLookupLocations | void;
    set(
      directory: string,
      result: ResolvedModuleWithFailedLookupLocations
    ): void;
  }
  declare export function createModuleResolutionCache(
    currentDirectory: string,
    getCanonicalFileName: (s: string) => string
  ): ModuleResolutionCache;

  declare export function resolveModuleNameFromCache(
    moduleName: string,
    containingFile: string,
    cache: ModuleResolutionCache
  ): ResolvedModuleWithFailedLookupLocations | void;

  declare export function resolveModuleName(
    moduleName: string,
    containingFile: string,
    compilerOptions: CompilerOptions,
    host: ModuleResolutionHost,
    cache?: ModuleResolutionCache,
    redirectedReference?: ResolvedProjectReference
  ): ResolvedModuleWithFailedLookupLocations;

  declare export function nodeModuleNameResolver(
    moduleName: string,
    containingFile: string,
    compilerOptions: CompilerOptions,
    host: ModuleResolutionHost,
    cache?: ModuleResolutionCache,
    redirectedReference?: ResolvedProjectReference
  ): ResolvedModuleWithFailedLookupLocations;

  declare export function classicNameResolver(
    moduleName: string,
    containingFile: string,
    compilerOptions: CompilerOptions,
    host: ModuleResolutionHost,
    cache?: NonRelativeModuleNameResolutionCache,
    redirectedReference?: ResolvedProjectReference
  ): ResolvedModuleWithFailedLookupLocations;

  declare export function createNodeArray<T: Node>(
    elements?: $ReadOnlyArray<T>,
    hasTrailingComma?: boolean
  ): NodeArray<T>;

  /**
   * If a node is passed, creates a string literal whose source text is read from a source node during emit.
   */
  declare export function createLiteral(
    value:
      | string
      | StringLiteral
      | NoSubstitutionTemplateLiteral
      | NumericLiteral
      | Identifier
  ): StringLiteral;

  declare export function createLiteral(value: number | PseudoBigInt): NumericLiteral;

  declare export function createLiteral(value: boolean): BooleanLiteral;

  declare export function createLiteral(
    value: string | number | PseudoBigInt | boolean
  ): PrimaryExpression;

  declare export function createNumericLiteral(value: string): NumericLiteral;

  declare export function createBigIntLiteral(value: string): BigIntLiteral;

  declare export function createStringLiteral(text: string): StringLiteral;

  declare export function createRegularExpressionLiteral(
    text: string
  ): RegularExpressionLiteral;

  declare export function createIdentifier(text: string): Identifier;

  declare export function updateIdentifier(node: Identifier): Identifier;

  /**
   * Create a unique temporary variable.
   */
  declare export function createTempVariable(
    recordTempVariable: ((node: Identifier) => void) | void
  ): Identifier;

  /**
   * Create a unique temporary variable for use in a loop.
   */
  declare export function createLoopVariable(): Identifier;

  /**
   * Create a unique name based on the supplied text.
   */
  declare export function createUniqueName(text: string): Identifier;

  /**
   * Create a unique name based on the supplied text.
   */
  declare export function createOptimisticUniqueName(text: string): Identifier;

  /**
   * Create a unique name based on the supplied text. This does not consider names injected by the transformer.
   */
  declare export function createFileLevelUniqueName(text: string): Identifier;

  /**
   * Create a unique name generated for a node.
   */
  declare export function getGeneratedNameForNode(node: Node | void): Identifier;

  declare export function createToken<TKind: SyntaxKind>(token: TKind): Token<TKind>;

  declare export function createSuper(): SuperExpression;

  declare export function createThis(): ThisExpression & Token<SyntaxKind.ThisKeyword>;

  declare export function createNull(): NullLiteral & Token<SyntaxKind.NullKeyword>;

  declare export function createTrue(): BooleanLiteral & Token<SyntaxKind.TrueKeyword>;

  declare export function createFalse(): BooleanLiteral &
    Token<SyntaxKind.FalseKeyword>;

  declare export function createModifier<T: $ElementType<Modifier, "kind">>(
    kind: T
  ): Token<T>;

  declare export function createModifiersFromModifierFlags(
    flags: ModifierFlags
  ): Modifier[];

  declare export function createQualifiedName(
    left: EntityName,
    right: string | Identifier
  ): QualifiedName;

  declare export function updateQualifiedName(
    node: QualifiedName,
    left: EntityName,
    right: Identifier
  ): QualifiedName;

  declare export function createComputedPropertyName(
    expression: Expression
  ): ComputedPropertyName;

  declare export function updateComputedPropertyName(
    node: ComputedPropertyName,
    expression: Expression
  ): ComputedPropertyName;

  declare export function createTypeParameterDeclaration(
    name: string | Identifier,
    constraint?: TypeNode,
    defaultType?: TypeNode
  ): TypeParameterDeclaration;

  declare export function updateTypeParameterDeclaration(
    node: TypeParameterDeclaration,
    name: Identifier,
    constraint: TypeNode | void,
    defaultType: TypeNode | void
  ): TypeParameterDeclaration;

  declare export function createParameter(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    dotDotDotToken: DotDotDotToken | void,
    name: string | BindingName,
    questionToken?: QuestionToken,
    type?: TypeNode,
    initializer?: Expression
  ): ParameterDeclaration;

  declare export function updateParameter(
    node: ParameterDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    dotDotDotToken: DotDotDotToken | void,
    name: string | BindingName,
    questionToken: QuestionToken | void,
    type: TypeNode | void,
    initializer: Expression | void
  ): ParameterDeclaration;

  declare export function createDecorator(expression: Expression): Decorator;

  declare export function updateDecorator(
    node: Decorator,
    expression: Expression
  ): Decorator;

  declare export function createPropertySignature(
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: PropertyName | string,
    questionToken: QuestionToken | void,
    type: TypeNode | void,
    initializer: Expression | void
  ): PropertySignature;

  declare export function updatePropertySignature(
    node: PropertySignature,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: PropertyName,
    questionToken: QuestionToken | void,
    type: TypeNode | void,
    initializer: Expression | void
  ): PropertySignature;

  declare export function createProperty(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | PropertyName,
    questionOrExclamationToken: QuestionToken | ExclamationToken | void,
    type: TypeNode | void,
    initializer: Expression | void
  ): PropertyDeclaration;

  declare export function updateProperty(
    node: PropertyDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | PropertyName,
    questionOrExclamationToken: QuestionToken | ExclamationToken | void,
    type: TypeNode | void,
    initializer: Expression | void
  ): PropertyDeclaration;

  declare export function createMethodSignature(
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    name: string | PropertyName,
    questionToken: QuestionToken | void
  ): MethodSignature;

  declare export function updateMethodSignature(
    node: MethodSignature,
    typeParameters: NodeArray<TypeParameterDeclaration> | void,
    parameters: NodeArray<ParameterDeclaration>,
    type: TypeNode | void,
    name: PropertyName,
    questionToken: QuestionToken | void
  ): MethodSignature;

  declare export function createMethod(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    asteriskToken: AsteriskToken | void,
    name: string | PropertyName,
    questionToken: QuestionToken | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    body: Block | void
  ): MethodDeclaration;

  declare export function updateMethod(
    node: MethodDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    asteriskToken: AsteriskToken | void,
    name: PropertyName,
    questionToken: QuestionToken | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    body: Block | void
  ): MethodDeclaration;

  declare export function createConstructor(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    body: Block | void
  ): ConstructorDeclaration;

  declare export function updateConstructor(
    node: ConstructorDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    body: Block | void
  ): ConstructorDeclaration;

  declare export function createGetAccessor(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | PropertyName,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    body: Block | void
  ): GetAccessorDeclaration;

  declare export function updateGetAccessor(
    node: GetAccessorDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: PropertyName,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    body: Block | void
  ): GetAccessorDeclaration;

  declare export function createSetAccessor(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | PropertyName,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    body: Block | void
  ): SetAccessorDeclaration;

  declare export function updateSetAccessor(
    node: SetAccessorDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: PropertyName,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    body: Block | void
  ): SetAccessorDeclaration;

  declare export function createCallSignature(
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void
  ): CallSignatureDeclaration;

  declare export function updateCallSignature(
    node: CallSignatureDeclaration,
    typeParameters: NodeArray<TypeParameterDeclaration> | void,
    parameters: NodeArray<ParameterDeclaration>,
    type: TypeNode | void
  ): CallSignatureDeclaration;

  declare export function createConstructSignature(
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void
  ): ConstructSignatureDeclaration;

  declare export function updateConstructSignature(
    node: ConstructSignatureDeclaration,
    typeParameters: NodeArray<TypeParameterDeclaration> | void,
    parameters: NodeArray<ParameterDeclaration>,
    type: TypeNode | void
  ): ConstructSignatureDeclaration;

  declare export function createIndexSignature(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode
  ): IndexSignatureDeclaration;

  declare export function updateIndexSignature(
    node: IndexSignatureDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode
  ): IndexSignatureDeclaration;

  declare export function createKeywordTypeNode(
    kind: $ElementType<KeywordTypeNode, "kind">
  ): KeywordTypeNode;

  declare export function createTypePredicateNode(
    parameterName: Identifier | ThisTypeNode | string,
    type: TypeNode
  ): TypePredicateNode;

  declare export function updateTypePredicateNode(
    node: TypePredicateNode,
    parameterName: Identifier | ThisTypeNode,
    type: TypeNode
  ): TypePredicateNode;

  declare export function createTypeReferenceNode(
    typeName: string | EntityName,
    typeArguments: $ReadOnlyArray<TypeNode> | void
  ): TypeReferenceNode;

  declare export function updateTypeReferenceNode(
    node: TypeReferenceNode,
    typeName: EntityName,
    typeArguments: NodeArray<TypeNode> | void
  ): TypeReferenceNode;

  declare export function createFunctionTypeNode(
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void
  ): FunctionTypeNode;

  declare export function updateFunctionTypeNode(
    node: FunctionTypeNode,
    typeParameters: NodeArray<TypeParameterDeclaration> | void,
    parameters: NodeArray<ParameterDeclaration>,
    type: TypeNode | void
  ): FunctionTypeNode;

  declare export function createConstructorTypeNode(
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void
  ): ConstructorTypeNode;

  declare export function updateConstructorTypeNode(
    node: ConstructorTypeNode,
    typeParameters: NodeArray<TypeParameterDeclaration> | void,
    parameters: NodeArray<ParameterDeclaration>,
    type: TypeNode | void
  ): ConstructorTypeNode;

  declare export function createTypeQueryNode(exprName: EntityName): TypeQueryNode;

  declare export function updateTypeQueryNode(
    node: TypeQueryNode,
    exprName: EntityName
  ): TypeQueryNode;

  declare export function createTypeLiteralNode(
    members: $ReadOnlyArray<TypeElement> | void
  ): TypeLiteralNode;

  declare export function updateTypeLiteralNode(
    node: TypeLiteralNode,
    members: NodeArray<TypeElement>
  ): TypeLiteralNode;

  declare export function createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;

  declare export function updateArrayTypeNode(
    node: ArrayTypeNode,
    elementType: TypeNode
  ): ArrayTypeNode;

  declare export function createTupleTypeNode(
    elementTypes: $ReadOnlyArray<TypeNode>
  ): TupleTypeNode;

  declare export function updateTupleTypeNode(
    node: TupleTypeNode,
    elementTypes: $ReadOnlyArray<TypeNode>
  ): TupleTypeNode;

  declare export function createOptionalTypeNode(type: TypeNode): OptionalTypeNode;

  declare export function updateOptionalTypeNode(
    node: OptionalTypeNode,
    type: TypeNode
  ): OptionalTypeNode;

  declare export function createRestTypeNode(type: TypeNode): RestTypeNode;

  declare export function updateRestTypeNode(
    node: RestTypeNode,
    type: TypeNode
  ): RestTypeNode;

  declare export function createUnionTypeNode(
    types: $ReadOnlyArray<TypeNode>
  ): UnionTypeNode;

  declare export function updateUnionTypeNode(
    node: UnionTypeNode,
    types: NodeArray<TypeNode>
  ): UnionTypeNode;

  declare export function createIntersectionTypeNode(
    types: $ReadOnlyArray<TypeNode>
  ): IntersectionTypeNode;

  declare export function updateIntersectionTypeNode(
    node: IntersectionTypeNode,
    types: NodeArray<TypeNode>
  ): IntersectionTypeNode;

  declare export function createUnionOrIntersectionTypeNode(
    kind: SyntaxKind.UnionType | SyntaxKind.IntersectionType,
    types: $ReadOnlyArray<TypeNode>
  ): UnionOrIntersectionTypeNode;

  declare export function createConditionalTypeNode(
    checkType: TypeNode,
    extendsType: TypeNode,
    trueType: TypeNode,
    falseType: TypeNode
  ): ConditionalTypeNode;

  declare export function updateConditionalTypeNode(
    node: ConditionalTypeNode,
    checkType: TypeNode,
    extendsType: TypeNode,
    trueType: TypeNode,
    falseType: TypeNode
  ): ConditionalTypeNode;

  declare export function createInferTypeNode(
    typeParameter: TypeParameterDeclaration
  ): InferTypeNode;

  declare export function updateInferTypeNode(
    node: InferTypeNode,
    typeParameter: TypeParameterDeclaration
  ): InferTypeNode;

  declare export function createImportTypeNode(
    argument: TypeNode,
    qualifier?: EntityName,
    typeArguments?: $ReadOnlyArray<TypeNode>,
    isTypeOf?: boolean
  ): ImportTypeNode;

  declare export function updateImportTypeNode(
    node: ImportTypeNode,
    argument: TypeNode,
    qualifier?: EntityName,
    typeArguments?: $ReadOnlyArray<TypeNode>,
    isTypeOf?: boolean
  ): ImportTypeNode;

  declare export function createParenthesizedType(
    type: TypeNode
  ): ParenthesizedTypeNode;

  declare export function updateParenthesizedType(
    node: ParenthesizedTypeNode,
    type: TypeNode
  ): ParenthesizedTypeNode;

  declare export function createThisTypeNode(): ThisTypeNode;

  declare export function createTypeOperatorNode(type: TypeNode): TypeOperatorNode;

  declare export function createTypeOperatorNode(
    operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword,
    type: TypeNode
  ): TypeOperatorNode;

  declare export function updateTypeOperatorNode(
    node: TypeOperatorNode,
    type: TypeNode
  ): TypeOperatorNode;

  declare export function createIndexedAccessTypeNode(
    objectType: TypeNode,
    indexType: TypeNode
  ): IndexedAccessTypeNode;

  declare export function updateIndexedAccessTypeNode(
    node: IndexedAccessTypeNode,
    objectType: TypeNode,
    indexType: TypeNode
  ): IndexedAccessTypeNode;

  declare export function createMappedTypeNode(
    readonlyToken: ReadonlyToken | PlusToken | MinusToken | void,
    typeParameter: TypeParameterDeclaration,
    questionToken: QuestionToken | PlusToken | MinusToken | void,
    type: TypeNode | void
  ): MappedTypeNode;

  declare export function updateMappedTypeNode(
    node: MappedTypeNode,
    readonlyToken: ReadonlyToken | PlusToken | MinusToken | void,
    typeParameter: TypeParameterDeclaration,
    questionToken: QuestionToken | PlusToken | MinusToken | void,
    type: TypeNode | void
  ): MappedTypeNode;

  declare export function createLiteralTypeNode(
    literal: $ElementType<LiteralTypeNode, "literal">
  ): LiteralTypeNode;

  declare export function updateLiteralTypeNode(
    node: LiteralTypeNode,
    literal: $ElementType<LiteralTypeNode, "literal">
  ): LiteralTypeNode;

  declare export function createObjectBindingPattern(
    elements: $ReadOnlyArray<BindingElement>
  ): ObjectBindingPattern;

  declare export function updateObjectBindingPattern(
    node: ObjectBindingPattern,
    elements: $ReadOnlyArray<BindingElement>
  ): ObjectBindingPattern;

  declare export function createArrayBindingPattern(
    elements: $ReadOnlyArray<ArrayBindingElement>
  ): ArrayBindingPattern;

  declare export function updateArrayBindingPattern(
    node: ArrayBindingPattern,
    elements: $ReadOnlyArray<ArrayBindingElement>
  ): ArrayBindingPattern;

  declare export function createBindingElement(
    dotDotDotToken: DotDotDotToken | void,
    propertyName: string | PropertyName | void,
    name: string | BindingName,
    initializer?: Expression
  ): BindingElement;

  declare export function updateBindingElement(
    node: BindingElement,
    dotDotDotToken: DotDotDotToken | void,
    propertyName: PropertyName | void,
    name: BindingName,
    initializer: Expression | void
  ): BindingElement;

  declare export function createArrayLiteral(
    elements?: $ReadOnlyArray<Expression>,
    multiLine?: boolean
  ): ArrayLiteralExpression;

  declare export function updateArrayLiteral(
    node: ArrayLiteralExpression,
    elements: $ReadOnlyArray<Expression>
  ): ArrayLiteralExpression;

  declare export function createObjectLiteral(
    properties?: $ReadOnlyArray<ObjectLiteralElementLike>,
    multiLine?: boolean
  ): ObjectLiteralExpression;

  declare export function updateObjectLiteral(
    node: ObjectLiteralExpression,
    properties: $ReadOnlyArray<ObjectLiteralElementLike>
  ): ObjectLiteralExpression;

  declare export function createPropertyAccess(
    expression: Expression,
    name: string | Identifier | void
  ): PropertyAccessExpression;

  declare export function updatePropertyAccess(
    node: PropertyAccessExpression,
    expression: Expression,
    name: Identifier
  ): PropertyAccessExpression;

  declare export function createElementAccess(
    expression: Expression,
    index: number | Expression
  ): ElementAccessExpression;

  declare export function updateElementAccess(
    node: ElementAccessExpression,
    expression: Expression,
    argumentExpression: Expression
  ): ElementAccessExpression;

  declare export function createCall(
    expression: Expression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    argumentsArray: $ReadOnlyArray<Expression> | void
  ): CallExpression;

  declare export function updateCall(
    node: CallExpression,
    expression: Expression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    argumentsArray: $ReadOnlyArray<Expression>
  ): CallExpression;

  declare export function createNew(
    expression: Expression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    argumentsArray: $ReadOnlyArray<Expression> | void
  ): NewExpression;

  declare export function updateNew(
    node: NewExpression,
    expression: Expression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    argumentsArray: $ReadOnlyArray<Expression> | void
  ): NewExpression;

  /**
   *
   * @deprecated
   */
  declare export function createTaggedTemplate(
    tag: Expression,
    template: TemplateLiteral
  ): TaggedTemplateExpression;

  declare export function createTaggedTemplate(
    tag: Expression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    template: TemplateLiteral
  ): TaggedTemplateExpression;

  /**
   *
   * @deprecated
   */
  declare export function updateTaggedTemplate(
    node: TaggedTemplateExpression,
    tag: Expression,
    template: TemplateLiteral
  ): TaggedTemplateExpression;

  declare export function updateTaggedTemplate(
    node: TaggedTemplateExpression,
    tag: Expression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    template: TemplateLiteral
  ): TaggedTemplateExpression;

  declare export function createTypeAssertion(
    type: TypeNode,
    expression: Expression
  ): TypeAssertion;

  declare export function updateTypeAssertion(
    node: TypeAssertion,
    type: TypeNode,
    expression: Expression
  ): TypeAssertion;

  declare export function createParen(expression: Expression): ParenthesizedExpression;

  declare export function updateParen(
    node: ParenthesizedExpression,
    expression: Expression
  ): ParenthesizedExpression;

  declare export function createFunctionExpression(
    modifiers: $ReadOnlyArray<Modifier> | void,
    asteriskToken: AsteriskToken | void,
    name: string | Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration> | void,
    type: TypeNode | void,
    body: Block
  ): FunctionExpression;

  declare export function updateFunctionExpression(
    node: FunctionExpression,
    modifiers: $ReadOnlyArray<Modifier> | void,
    asteriskToken: AsteriskToken | void,
    name: Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    body: Block
  ): FunctionExpression;

  declare export function createArrowFunction(
    modifiers: $ReadOnlyArray<Modifier> | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    equalsGreaterThanToken: EqualsGreaterThanToken | void,
    body: ConciseBody
  ): ArrowFunction;

  declare export function updateArrowFunction(
    node: ArrowFunction,
    modifiers: $ReadOnlyArray<Modifier> | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    equalsGreaterThanToken: Token<SyntaxKind.EqualsGreaterThanToken>,
    body: ConciseBody
  ): ArrowFunction;

  declare export function createDelete(expression: Expression): DeleteExpression;

  declare export function updateDelete(
    node: DeleteExpression,
    expression: Expression
  ): DeleteExpression;

  declare export function createTypeOf(expression: Expression): TypeOfExpression;

  declare export function updateTypeOf(
    node: TypeOfExpression,
    expression: Expression
  ): TypeOfExpression;

  declare export function createVoid(expression: Expression): VoidExpression;

  declare export function updateVoid(
    node: VoidExpression,
    expression: Expression
  ): VoidExpression;

  declare export function createAwait(expression: Expression): AwaitExpression;

  declare export function updateAwait(
    node: AwaitExpression,
    expression: Expression
  ): AwaitExpression;

  declare export function createPrefix(
    operator: PrefixUnaryOperator,
    operand: Expression
  ): PrefixUnaryExpression;

  declare export function updatePrefix(
    node: PrefixUnaryExpression,
    operand: Expression
  ): PrefixUnaryExpression;

  declare export function createPostfix(
    operand: Expression,
    operator: PostfixUnaryOperator
  ): PostfixUnaryExpression;

  declare export function updatePostfix(
    node: PostfixUnaryExpression,
    operand: Expression
  ): PostfixUnaryExpression;

  declare export function createBinary(
    left: Expression,
    operator: BinaryOperator | BinaryOperatorToken,
    right: Expression
  ): BinaryExpression;

  declare export function updateBinary(
    node: BinaryExpression,
    left: Expression,
    right: Expression,
    operator?: BinaryOperator | BinaryOperatorToken
  ): BinaryExpression;

  /**
   *
   * @deprecated
   */
  declare export function createConditional(
    condition: Expression,
    whenTrue: Expression,
    whenFalse: Expression
  ): ConditionalExpression;

  declare export function createConditional(
    condition: Expression,
    questionToken: QuestionToken,
    whenTrue: Expression,
    colonToken: ColonToken,
    whenFalse: Expression
  ): ConditionalExpression;

  declare export function updateConditional(
    node: ConditionalExpression,
    condition: Expression,
    questionToken: Token<SyntaxKind.QuestionToken>,
    whenTrue: Expression,
    colonToken: Token<SyntaxKind.ColonToken>,
    whenFalse: Expression
  ): ConditionalExpression;

  declare export function createTemplateExpression(
    head: TemplateHead,
    templateSpans: $ReadOnlyArray<TemplateSpan>
  ): TemplateExpression;

  declare export function updateTemplateExpression(
    node: TemplateExpression,
    head: TemplateHead,
    templateSpans: $ReadOnlyArray<TemplateSpan>
  ): TemplateExpression;

  declare export function createTemplateHead(text: string): TemplateHead;

  declare export function createTemplateMiddle(text: string): TemplateMiddle;

  declare export function createTemplateTail(text: string): TemplateTail;

  declare export function createNoSubstitutionTemplateLiteral(
    text: string
  ): NoSubstitutionTemplateLiteral;

  declare export function createYield(expression?: Expression): YieldExpression;

  declare export function createYield(
    asteriskToken: AsteriskToken | void,
    expression: Expression
  ): YieldExpression;

  declare export function updateYield(
    node: YieldExpression,
    asteriskToken: AsteriskToken | void,
    expression: Expression
  ): YieldExpression;

  declare export function createSpread(expression: Expression): SpreadElement;

  declare export function updateSpread(
    node: SpreadElement,
    expression: Expression
  ): SpreadElement;

  declare export function createClassExpression(
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    heritageClauses: $ReadOnlyArray<HeritageClause> | void,
    members: $ReadOnlyArray<ClassElement>
  ): ClassExpression;

  declare export function updateClassExpression(
    node: ClassExpression,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    heritageClauses: $ReadOnlyArray<HeritageClause> | void,
    members: $ReadOnlyArray<ClassElement>
  ): ClassExpression;

  declare export function createOmittedExpression(): OmittedExpression;

  declare export function createExpressionWithTypeArguments(
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    expression: Expression
  ): ExpressionWithTypeArguments;

  declare export function updateExpressionWithTypeArguments(
    node: ExpressionWithTypeArguments,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    expression: Expression
  ): ExpressionWithTypeArguments;

  declare export function createAsExpression(
    expression: Expression,
    type: TypeNode
  ): AsExpression;

  declare export function updateAsExpression(
    node: AsExpression,
    expression: Expression,
    type: TypeNode
  ): AsExpression;

  declare export function createNonNullExpression(
    expression: Expression
  ): NonNullExpression;

  declare export function updateNonNullExpression(
    node: NonNullExpression,
    expression: Expression
  ): NonNullExpression;

  declare export function createMetaProperty(
    keywordToken: $ElementType<MetaProperty, "keywordToken">,
    name: Identifier
  ): MetaProperty;

  declare export function updateMetaProperty(
    node: MetaProperty,
    name: Identifier
  ): MetaProperty;

  declare export function createTemplateSpan(
    expression: Expression,
    literal: TemplateMiddle | TemplateTail
  ): TemplateSpan;

  declare export function updateTemplateSpan(
    node: TemplateSpan,
    expression: Expression,
    literal: TemplateMiddle | TemplateTail
  ): TemplateSpan;

  declare export function createSemicolonClassElement(): SemicolonClassElement;

  declare export function createBlock(
    statements: $ReadOnlyArray<Statement>,
    multiLine?: boolean
  ): Block;

  declare export function updateBlock(
    node: Block,
    statements: $ReadOnlyArray<Statement>
  ): Block;

  declare export function createVariableStatement(
    modifiers: $ReadOnlyArray<Modifier> | void,
    declarationList:
      | VariableDeclarationList
      | $ReadOnlyArray<VariableDeclaration>
  ): VariableStatement;

  declare export function updateVariableStatement(
    node: VariableStatement,
    modifiers: $ReadOnlyArray<Modifier> | void,
    declarationList: VariableDeclarationList
  ): VariableStatement;

  declare export function createEmptyStatement(): EmptyStatement;

  declare export function createExpressionStatement(
    expression: Expression
  ): ExpressionStatement;

  declare export function updateExpressionStatement(
    node: ExpressionStatement,
    expression: Expression
  ): ExpressionStatement;

  declare export var createStatement: typeof createExpressionStatement;
  declare export var updateStatement: typeof updateExpressionStatement;
  declare export function createIf(
    expression: Expression,
    thenStatement: Statement,
    elseStatement?: Statement
  ): IfStatement;

  declare export function updateIf(
    node: IfStatement,
    expression: Expression,
    thenStatement: Statement,
    elseStatement: Statement | void
  ): IfStatement;

  declare export function createDo(
    statement: Statement,
    expression: Expression
  ): DoStatement;

  declare export function updateDo(
    node: DoStatement,
    statement: Statement,
    expression: Expression
  ): DoStatement;

  declare export function createWhile(
    expression: Expression,
    statement: Statement
  ): WhileStatement;

  declare export function updateWhile(
    node: WhileStatement,
    expression: Expression,
    statement: Statement
  ): WhileStatement;

  declare export function createFor(
    initializer: ForInitializer | void,
    condition: Expression | void,
    incrementor: Expression | void,
    statement: Statement
  ): ForStatement;

  declare export function updateFor(
    node: ForStatement,
    initializer: ForInitializer | void,
    condition: Expression | void,
    incrementor: Expression | void,
    statement: Statement
  ): ForStatement;

  declare export function createForIn(
    initializer: ForInitializer,
    expression: Expression,
    statement: Statement
  ): ForInStatement;

  declare export function updateForIn(
    node: ForInStatement,
    initializer: ForInitializer,
    expression: Expression,
    statement: Statement
  ): ForInStatement;

  declare export function createForOf(
    awaitModifier: AwaitKeywordToken | void,
    initializer: ForInitializer,
    expression: Expression,
    statement: Statement
  ): ForOfStatement;

  declare export function updateForOf(
    node: ForOfStatement,
    awaitModifier: AwaitKeywordToken | void,
    initializer: ForInitializer,
    expression: Expression,
    statement: Statement
  ): ForOfStatement;

  declare export function createContinue(
    label?: string | Identifier
  ): ContinueStatement;

  declare export function updateContinue(
    node: ContinueStatement,
    label: Identifier | void
  ): ContinueStatement;

  declare export function createBreak(label?: string | Identifier): BreakStatement;

  declare export function updateBreak(
    node: BreakStatement,
    label: Identifier | void
  ): BreakStatement;

  declare export function createReturn(expression?: Expression): ReturnStatement;

  declare export function updateReturn(
    node: ReturnStatement,
    expression: Expression | void
  ): ReturnStatement;

  declare export function createWith(
    expression: Expression,
    statement: Statement
  ): WithStatement;

  declare export function updateWith(
    node: WithStatement,
    expression: Expression,
    statement: Statement
  ): WithStatement;

  declare export function createSwitch(
    expression: Expression,
    caseBlock: CaseBlock
  ): SwitchStatement;

  declare export function updateSwitch(
    node: SwitchStatement,
    expression: Expression,
    caseBlock: CaseBlock
  ): SwitchStatement;

  declare export function createLabel(
    label: string | Identifier,
    statement: Statement
  ): LabeledStatement;

  declare export function updateLabel(
    node: LabeledStatement,
    label: Identifier,
    statement: Statement
  ): LabeledStatement;

  declare export function createThrow(expression: Expression): ThrowStatement;

  declare export function updateThrow(
    node: ThrowStatement,
    expression: Expression
  ): ThrowStatement;

  declare export function createTry(
    tryBlock: Block,
    catchClause: CatchClause | void,
    finallyBlock: Block | void
  ): TryStatement;

  declare export function updateTry(
    node: TryStatement,
    tryBlock: Block,
    catchClause: CatchClause | void,
    finallyBlock: Block | void
  ): TryStatement;

  declare export function createDebuggerStatement(): DebuggerStatement;

  declare export function createVariableDeclaration(
    name: string | BindingName,
    type?: TypeNode,
    initializer?: Expression
  ): VariableDeclaration;

  declare export function updateVariableDeclaration(
    node: VariableDeclaration,
    name: BindingName,
    type: TypeNode | void,
    initializer: Expression | void
  ): VariableDeclaration;

  declare export function createVariableDeclarationList(
    declarations: $ReadOnlyArray<VariableDeclaration>,
    flags?: NodeFlags
  ): VariableDeclarationList;

  declare export function updateVariableDeclarationList(
    node: VariableDeclarationList,
    declarations: $ReadOnlyArray<VariableDeclaration>
  ): VariableDeclarationList;

  declare export function createFunctionDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    asteriskToken: AsteriskToken | void,
    name: string | Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    body: Block | void
  ): FunctionDeclaration;

  declare export function updateFunctionDeclaration(
    node: FunctionDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    asteriskToken: AsteriskToken | void,
    name: Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    parameters: $ReadOnlyArray<ParameterDeclaration>,
    type: TypeNode | void,
    body: Block | void
  ): FunctionDeclaration;

  declare export function createClassDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    heritageClauses: $ReadOnlyArray<HeritageClause> | void,
    members: $ReadOnlyArray<ClassElement>
  ): ClassDeclaration;

  declare export function updateClassDeclaration(
    node: ClassDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: Identifier | void,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    heritageClauses: $ReadOnlyArray<HeritageClause> | void,
    members: $ReadOnlyArray<ClassElement>
  ): ClassDeclaration;

  declare export function createInterfaceDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | Identifier,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    heritageClauses: $ReadOnlyArray<HeritageClause> | void,
    members: $ReadOnlyArray<TypeElement>
  ): InterfaceDeclaration;

  declare export function updateInterfaceDeclaration(
    node: InterfaceDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: Identifier,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    heritageClauses: $ReadOnlyArray<HeritageClause> | void,
    members: $ReadOnlyArray<TypeElement>
  ): InterfaceDeclaration;

  declare export function createTypeAliasDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | Identifier,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    type: TypeNode
  ): TypeAliasDeclaration;

  declare export function updateTypeAliasDeclaration(
    node: TypeAliasDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: Identifier,
    typeParameters: $ReadOnlyArray<TypeParameterDeclaration> | void,
    type: TypeNode
  ): TypeAliasDeclaration;

  declare export function createEnumDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | Identifier,
    members: $ReadOnlyArray<EnumMember>
  ): EnumDeclaration;

  declare export function updateEnumDeclaration(
    node: EnumDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: Identifier,
    members: $ReadOnlyArray<EnumMember>
  ): EnumDeclaration;

  declare export function createModuleDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: ModuleName,
    body: ModuleBody | void,
    flags?: NodeFlags
  ): ModuleDeclaration;

  declare export function updateModuleDeclaration(
    node: ModuleDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: ModuleName,
    body: ModuleBody | void
  ): ModuleDeclaration;

  declare export function createModuleBlock(
    statements: $ReadOnlyArray<Statement>
  ): ModuleBlock;

  declare export function updateModuleBlock(
    node: ModuleBlock,
    statements: $ReadOnlyArray<Statement>
  ): ModuleBlock;

  declare export function createCaseBlock(
    clauses: $ReadOnlyArray<CaseOrDefaultClause>
  ): CaseBlock;

  declare export function updateCaseBlock(
    node: CaseBlock,
    clauses: $ReadOnlyArray<CaseOrDefaultClause>
  ): CaseBlock;

  declare export function createNamespaceExportDeclaration(
    name: string | Identifier
  ): NamespaceExportDeclaration;

  declare export function updateNamespaceExportDeclaration(
    node: NamespaceExportDeclaration,
    name: Identifier
  ): NamespaceExportDeclaration;

  declare export function createImportEqualsDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: string | Identifier,
    moduleReference: ModuleReference
  ): ImportEqualsDeclaration;

  declare export function updateImportEqualsDeclaration(
    node: ImportEqualsDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    name: Identifier,
    moduleReference: ModuleReference
  ): ImportEqualsDeclaration;

  declare export function createImportDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    importClause: ImportClause | void,
    moduleSpecifier: Expression
  ): ImportDeclaration;

  declare export function updateImportDeclaration(
    node: ImportDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    importClause: ImportClause | void,
    moduleSpecifier: Expression
  ): ImportDeclaration;

  declare export function createImportClause(
    name: Identifier | void,
    namedBindings: NamedImportBindings | void
  ): ImportClause;

  declare export function updateImportClause(
    node: ImportClause,
    name: Identifier | void,
    namedBindings: NamedImportBindings | void
  ): ImportClause;

  declare export function createNamespaceImport(name: Identifier): NamespaceImport;

  declare export function updateNamespaceImport(
    node: NamespaceImport,
    name: Identifier
  ): NamespaceImport;

  declare export function createNamedImports(
    elements: $ReadOnlyArray<ImportSpecifier>
  ): NamedImports;

  declare export function updateNamedImports(
    node: NamedImports,
    elements: $ReadOnlyArray<ImportSpecifier>
  ): NamedImports;

  declare export function createImportSpecifier(
    propertyName: Identifier | void,
    name: Identifier
  ): ImportSpecifier;

  declare export function updateImportSpecifier(
    node: ImportSpecifier,
    propertyName: Identifier | void,
    name: Identifier
  ): ImportSpecifier;

  declare export function createExportAssignment(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    isExportEquals: boolean | void,
    expression: Expression
  ): ExportAssignment;

  declare export function updateExportAssignment(
    node: ExportAssignment,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    expression: Expression
  ): ExportAssignment;

  declare export function createExportDeclaration(
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    exportClause: NamedExports | void,
    moduleSpecifier?: Expression
  ): ExportDeclaration;

  declare export function updateExportDeclaration(
    node: ExportDeclaration,
    decorators: $ReadOnlyArray<Decorator> | void,
    modifiers: $ReadOnlyArray<Modifier> | void,
    exportClause: NamedExports | void,
    moduleSpecifier: Expression | void
  ): ExportDeclaration;

  declare export function createNamedExports(
    elements: $ReadOnlyArray<ExportSpecifier>
  ): NamedExports;

  declare export function updateNamedExports(
    node: NamedExports,
    elements: $ReadOnlyArray<ExportSpecifier>
  ): NamedExports;

  declare export function createExportSpecifier(
    propertyName: string | Identifier | void,
    name: string | Identifier
  ): ExportSpecifier;

  declare export function updateExportSpecifier(
    node: ExportSpecifier,
    propertyName: Identifier | void,
    name: Identifier
  ): ExportSpecifier;

  declare export function createExternalModuleReference(
    expression: Expression
  ): ExternalModuleReference;

  declare export function updateExternalModuleReference(
    node: ExternalModuleReference,
    expression: Expression
  ): ExternalModuleReference;

  declare export function createJsxElement(
    openingElement: JsxOpeningElement,
    children: $ReadOnlyArray<JsxChild>,
    closingElement: JsxClosingElement
  ): JsxElement;

  declare export function updateJsxElement(
    node: JsxElement,
    openingElement: JsxOpeningElement,
    children: $ReadOnlyArray<JsxChild>,
    closingElement: JsxClosingElement
  ): JsxElement;

  declare export function createJsxSelfClosingElement(
    tagName: JsxTagNameExpression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    attributes: JsxAttributes
  ): JsxSelfClosingElement;

  declare export function updateJsxSelfClosingElement(
    node: JsxSelfClosingElement,
    tagName: JsxTagNameExpression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    attributes: JsxAttributes
  ): JsxSelfClosingElement;

  declare export function createJsxOpeningElement(
    tagName: JsxTagNameExpression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    attributes: JsxAttributes
  ): JsxOpeningElement;

  declare export function updateJsxOpeningElement(
    node: JsxOpeningElement,
    tagName: JsxTagNameExpression,
    typeArguments: $ReadOnlyArray<TypeNode> | void,
    attributes: JsxAttributes
  ): JsxOpeningElement;

  declare export function createJsxClosingElement(
    tagName: JsxTagNameExpression
  ): JsxClosingElement;

  declare export function updateJsxClosingElement(
    node: JsxClosingElement,
    tagName: JsxTagNameExpression
  ): JsxClosingElement;

  declare export function createJsxFragment(
    openingFragment: JsxOpeningFragment,
    children: $ReadOnlyArray<JsxChild>,
    closingFragment: JsxClosingFragment
  ): JsxFragment;

  declare export function updateJsxFragment(
    node: JsxFragment,
    openingFragment: JsxOpeningFragment,
    children: $ReadOnlyArray<JsxChild>,
    closingFragment: JsxClosingFragment
  ): JsxFragment;

  declare export function createJsxAttribute(
    name: Identifier,
    initializer: StringLiteral | JsxExpression
  ): JsxAttribute;

  declare export function updateJsxAttribute(
    node: JsxAttribute,
    name: Identifier,
    initializer: StringLiteral | JsxExpression
  ): JsxAttribute;

  declare export function createJsxAttributes(
    properties: $ReadOnlyArray<JsxAttributeLike>
  ): JsxAttributes;

  declare export function updateJsxAttributes(
    node: JsxAttributes,
    properties: $ReadOnlyArray<JsxAttributeLike>
  ): JsxAttributes;

  declare export function createJsxSpreadAttribute(
    expression: Expression
  ): JsxSpreadAttribute;

  declare export function updateJsxSpreadAttribute(
    node: JsxSpreadAttribute,
    expression: Expression
  ): JsxSpreadAttribute;

  declare export function createJsxExpression(
    dotDotDotToken: DotDotDotToken | void,
    expression: Expression | void
  ): JsxExpression;

  declare export function updateJsxExpression(
    node: JsxExpression,
    expression: Expression | void
  ): JsxExpression;

  declare export function createCaseClause(
    expression: Expression,
    statements: $ReadOnlyArray<Statement>
  ): CaseClause;

  declare export function updateCaseClause(
    node: CaseClause,
    expression: Expression,
    statements: $ReadOnlyArray<Statement>
  ): CaseClause;

  declare export function createDefaultClause(
    statements: $ReadOnlyArray<Statement>
  ): DefaultClause;

  declare export function updateDefaultClause(
    node: DefaultClause,
    statements: $ReadOnlyArray<Statement>
  ): DefaultClause;

  declare export function createHeritageClause(
    token: $ElementType<HeritageClause, "token">,
    types: $ReadOnlyArray<ExpressionWithTypeArguments>
  ): HeritageClause;

  declare export function updateHeritageClause(
    node: HeritageClause,
    types: $ReadOnlyArray<ExpressionWithTypeArguments>
  ): HeritageClause;

  declare export function createCatchClause(
    variableDeclaration: string | VariableDeclaration | void,
    block: Block
  ): CatchClause;

  declare export function updateCatchClause(
    node: CatchClause,
    variableDeclaration: VariableDeclaration | void,
    block: Block
  ): CatchClause;

  declare export function createPropertyAssignment(
    name: string | PropertyName,
    initializer: Expression
  ): PropertyAssignment;

  declare export function updatePropertyAssignment(
    node: PropertyAssignment,
    name: PropertyName,
    initializer: Expression
  ): PropertyAssignment;

  declare export function createShorthandPropertyAssignment(
    name: string | Identifier,
    objectAssignmentInitializer?: Expression
  ): ShorthandPropertyAssignment;

  declare export function updateShorthandPropertyAssignment(
    node: ShorthandPropertyAssignment,
    name: Identifier,
    objectAssignmentInitializer: Expression | void
  ): ShorthandPropertyAssignment;

  declare export function createSpreadAssignment(
    expression: Expression
  ): SpreadAssignment;

  declare export function updateSpreadAssignment(
    node: SpreadAssignment,
    expression: Expression
  ): SpreadAssignment;

  declare export function createEnumMember(
    name: string | PropertyName,
    initializer?: Expression
  ): EnumMember;

  declare export function updateEnumMember(
    node: EnumMember,
    name: PropertyName,
    initializer: Expression | void
  ): EnumMember;

  declare export function updateSourceFileNode(
    node: SourceFile,
    statements: $ReadOnlyArray<Statement>,
    isDeclarationFile?: boolean,
    referencedFiles?: $ElementType<SourceFile, "referencedFiles">,
    typeReferences?: $ElementType<SourceFile, "typeReferenceDirectives">,
    hasNoDefaultLib?: boolean,
    libReferences?: $ElementType<SourceFile, "libReferenceDirectives">
  ): SourceFile;

  /**
   * Creates a shallow, memberwise clone of a node for mutation.
   */
  declare export function getMutableClone<T: Node>(node: T): T;

  /**
   * Creates a synthetic statement to act as a placeholder for a not-emitted statement in
   * order to preserve comments.
   * @param original The original statement.
   */
  declare export function createNotEmittedStatement(
    original: Node
  ): NotEmittedStatement;

  /**
   * Creates a synthetic expression to act as a placeholder for a not-emitted expression in
   * order to preserve comments or sourcemap positions.
   * @param expression The inner expression to emit.
   * @param original The original outer expression.
   * @param location The location for the expression. Defaults to the positions from "original" if provided.
   */
  declare export function createPartiallyEmittedExpression(
    expression: Expression,
    original?: Node
  ): PartiallyEmittedExpression;

  declare export function updatePartiallyEmittedExpression(
    node: PartiallyEmittedExpression,
    expression: Expression
  ): PartiallyEmittedExpression;

  declare export function createCommaList(
    elements: $ReadOnlyArray<Expression>
  ): CommaListExpression;

  declare export function updateCommaList(
    node: CommaListExpression,
    elements: $ReadOnlyArray<Expression>
  ): CommaListExpression;

  declare export function createBundle(
    sourceFiles: $ReadOnlyArray<SourceFile>,
    prepends?: $ReadOnlyArray<UnparsedSource | InputFiles>
  ): Bundle;

  declare export function createUnparsedSourceFile(text: string): UnparsedSource;

  declare export function createUnparsedSourceFile(
    inputFile: InputFiles,
    type: "js" | "dts"
  ): UnparsedSource;

  declare export function createUnparsedSourceFile(
    text: string,
    mapPath: string | void,
    map: string | void
  ): UnparsedSource;

  declare export function createInputFiles(
    javascriptText: string,
    declarationText: string
  ): InputFiles;

  declare export function createInputFiles(
    readFileText: (path: string) => string | void,
    javascriptPath: string,
    javascriptMapPath: string | void,
    declarationPath: string,
    declarationMapPath: string | void
  ): InputFiles;

  declare export function createInputFiles(
    javascriptText: string,
    declarationText: string,
    javascriptMapPath: string | void,
    javascriptMapText: string | void,
    declarationMapPath: string | void,
    declarationMapText: string | void
  ): InputFiles;

  declare export function updateBundle(
    node: Bundle,
    sourceFiles: $ReadOnlyArray<SourceFile>,
    prepends?: $ReadOnlyArray<UnparsedSource>
  ): Bundle;

  declare export function createImmediatelyInvokedFunctionExpression(
    statements: $ReadOnlyArray<Statement>
  ): CallExpression;

  declare export function createImmediatelyInvokedFunctionExpression(
    statements: $ReadOnlyArray<Statement>,
    param: ParameterDeclaration,
    paramValue: Expression
  ): CallExpression;

  declare export function createImmediatelyInvokedArrowFunction(
    statements: $ReadOnlyArray<Statement>
  ): CallExpression;

  declare export function createImmediatelyInvokedArrowFunction(
    statements: $ReadOnlyArray<Statement>,
    param: ParameterDeclaration,
    paramValue: Expression
  ): CallExpression;

  declare export function createComma(left: Expression, right: Expression): Expression;

  declare export function createLessThan(
    left: Expression,
    right: Expression
  ): Expression;

  declare export function createAssignment(
    left: ObjectLiteralExpression | ArrayLiteralExpression,
    right: Expression
  ): DestructuringAssignment;

  declare export function createAssignment(
    left: Expression,
    right: Expression
  ): BinaryExpression;

  declare export function createStrictEquality(
    left: Expression,
    right: Expression
  ): BinaryExpression;

  declare export function createStrictInequality(
    left: Expression,
    right: Expression
  ): BinaryExpression;

  declare export function createAdd(
    left: Expression,
    right: Expression
  ): BinaryExpression;

  declare export function createSubtract(
    left: Expression,
    right: Expression
  ): BinaryExpression;

  declare export function createPostfixIncrement(
    operand: Expression
  ): PostfixUnaryExpression;

  declare export function createLogicalAnd(
    left: Expression,
    right: Expression
  ): BinaryExpression;

  declare export function createLogicalOr(
    left: Expression,
    right: Expression
  ): BinaryExpression;

  declare export function createLogicalNot(operand: Expression): PrefixUnaryExpression;

  declare export function createVoidZero(): VoidExpression;

  declare export function createExportDefault(
    expression: Expression
  ): ExportAssignment;

  declare export function createExternalModuleExport(
    exportName: Identifier
  ): ExportDeclaration;

  /**
   * Clears any EmitNode entries from parse-tree nodes.
   * @param sourceFile A source file.
   */
  declare export function disposeEmitNodes(sourceFile: SourceFile): void;

  declare export function setTextRange<T: TextRange>(
    range: T,
    location: TextRange | void
  ): T;

  /**
   * Sets flags that control emit behavior of a node.
   */
  declare export function setEmitFlags<T: Node>(node: T, emitFlags: EmitFlags): T;

  /**
   * Gets a custom text range to use when emitting source maps.
   */
  declare export function getSourceMapRange(node: Node): SourceMapRange;

  /**
   * Sets a custom text range to use when emitting source maps.
   */
  declare export function setSourceMapRange<T: Node>(
    node: T,
    range: SourceMapRange | void
  ): T;

  /**
   * Create an external source map source file reference
   */
  declare export function createSourceMapSource(
    fileName: string,
    text: string,
    skipTrivia?: (pos: number) => number
  ): SourceMapSource;

  /**
   * Gets the TextRange to use for source maps for a token of a node.
   */
  declare export function getTokenSourceMapRange(
    node: Node,
    token: SyntaxKind
  ): SourceMapRange | void;

  /**
   * Sets the TextRange to use for source maps for a token of a node.
   */
  declare export function setTokenSourceMapRange<T: Node>(
    node: T,
    token: SyntaxKind,
    range: SourceMapRange | void
  ): T;

  /**
   * Gets a custom text range to use when emitting comments.
   */
  declare export function getCommentRange(node: Node): TextRange;

  /**
   * Sets a custom text range to use when emitting comments.
   */
  declare export function setCommentRange<T: Node>(node: T, range: TextRange): T;

  declare export function getSyntheticLeadingComments(
    node: Node
  ): SynthesizedComment[] | void;

  declare export function setSyntheticLeadingComments<T: Node>(
    node: T,
    comments: SynthesizedComment[] | void
  ): T;

  declare export function addSyntheticLeadingComment<T: Node>(
    node: T,
    kind:
      | SyntaxKind.SingleLineCommentTrivia
      | SyntaxKind.MultiLineCommentTrivia,
    text: string,
    hasTrailingNewLine?: boolean
  ): T;

  declare export function getSyntheticTrailingComments(
    node: Node
  ): SynthesizedComment[] | void;

  declare export function setSyntheticTrailingComments<T: Node>(
    node: T,
    comments: SynthesizedComment[] | void
  ): T;

  declare export function addSyntheticTrailingComment<T: Node>(
    node: T,
    kind:
      | SyntaxKind.SingleLineCommentTrivia
      | SyntaxKind.MultiLineCommentTrivia,
    text: string,
    hasTrailingNewLine?: boolean
  ): T;

  declare export function moveSyntheticComments<T: Node>(node: T, original: Node): T;

  /**
   * Gets the constant value to emit for an expression.
   */
  declare export function getConstantValue(
    node: PropertyAccessExpression | ElementAccessExpression
  ): string | number | void;

  /**
   * Sets the constant value to emit for an expression.
   */
  declare export function setConstantValue(
    node: PropertyAccessExpression | ElementAccessExpression,
    value: string | number
  ): PropertyAccessExpression | ElementAccessExpression;

  /**
   * Adds an EmitHelper to a node.
   */
  declare export function addEmitHelper<T: Node>(node: T, helper: EmitHelper): T;

  /**
   * Add EmitHelpers to a node.
   */
  declare export function addEmitHelpers<T: Node>(
    node: T,
    helpers: EmitHelper[] | void
  ): T;

  /**
   * Removes an EmitHelper from a node.
   */
  declare export function removeEmitHelper(node: Node, helper: EmitHelper): boolean;

  /**
   * Gets the EmitHelpers of a node.
   */
  declare export function getEmitHelpers(node: Node): EmitHelper[] | void;

  /**
   * Moves matching emit helpers from a source node to a target node.
   */
  declare export function moveEmitHelpers(
    source: Node,
    target: Node,
    predicate: (helper: EmitHelper) => boolean
  ): void;

  declare export function setOriginalNode<T: Node>(node: T, original: Node | void): T;

  /**
   * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
   * @param node The Node to visit.
   * @param visitor The callback used to visit the Node.
   * @param test A callback to execute to verify the Node is valid.
   * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
   */
  declare export function visitNode<T: Node>(
    node: T | void,
    visitor: Visitor | void,
    test?: (node: Node) => boolean,
    lift?: (node: NodeArray<Node>) => T
  ): T;

  /**
   * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
   * @param node The Node to visit.
   * @param visitor The callback used to visit the Node.
   * @param test A callback to execute to verify the Node is valid.
   * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
   */
  declare export function visitNode<T: Node>(
    node: T | void,
    visitor: Visitor | void,
    test?: (node: Node) => boolean,
    lift?: (node: NodeArray<Node>) => T
  ): T | void;

  /**
   * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
   * @param nodes The NodeArray to visit.
   * @param visitor The callback used to visit a Node.
   * @param test A node test to execute for each node.
   * @param start An optional value indicating the starting offset at which to start visiting.
   * @param count An optional value indicating the maximum number of nodes to visit.
   */
  declare export function visitNodes<T: Node>(
    nodes: NodeArray<T> | void,
    visitor: Visitor,
    test?: (node: Node) => boolean,
    start?: number,
    count?: number
  ): NodeArray<T>;

  /**
   * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
   * @param nodes The NodeArray to visit.
   * @param visitor The callback used to visit a Node.
   * @param test A node test to execute for each node.
   * @param start An optional value indicating the starting offset at which to start visiting.
   * @param count An optional value indicating the maximum number of nodes to visit.
   */
  declare export function visitNodes<T: Node>(
    nodes: NodeArray<T> | void,
    visitor: Visitor,
    test?: (node: Node) => boolean,
    start?: number,
    count?: number
  ): NodeArray<T> | void;

  /**
   * Starts a new lexical environment and visits a statement list, ending the lexical environment
   * and merging hoisted declarations upon completion.
   */
  declare export function visitLexicalEnvironment(
    statements: NodeArray<Statement>,
    visitor: Visitor,
    context: TransformationContext,
    start?: number,
    ensureUseStrict?: boolean
  ): NodeArray<Statement>;

  /**
   * Starts a new lexical environment and visits a parameter list, suspending the lexical
   * environment upon completion.
   */
  declare export function visitParameterList(
    nodes: NodeArray<ParameterDeclaration> | void,
    visitor: Visitor,
    context: TransformationContext,
    nodesVisitor?: typeof visitNodes
  ): NodeArray<ParameterDeclaration>;

  /**
   * Resumes a suspended lexical environment and visits a function body, ending the lexical
   * environment and merging hoisted declarations upon completion.
   */
  declare export function visitFunctionBody(
    node: FunctionBody,
    visitor: Visitor,
    context: TransformationContext
  ): FunctionBody;

  /**
   * Resumes a suspended lexical environment and visits a function body, ending the lexical
   * environment and merging hoisted declarations upon completion.
   */
  declare export function visitFunctionBody(
    node: FunctionBody | void,
    visitor: Visitor,
    context: TransformationContext
  ): FunctionBody | void;

  /**
   * Resumes a suspended lexical environment and visits a concise body, ending the lexical
   * environment and merging hoisted declarations upon completion.
   */
  declare export function visitFunctionBody(
    node: ConciseBody,
    visitor: Visitor,
    context: TransformationContext
  ): ConciseBody;

  /**
   * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
   * @param node The Node whose children will be visited.
   * @param visitor The callback used to visit each child.
   * @param context A lexical environment context for the visitor.
   */
  declare export function visitEachChild<T: Node>(
    node: T,
    visitor: Visitor,
    context: TransformationContext
  ): T;

  /**
   * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
   * @param node The Node whose children will be visited.
   * @param visitor The callback used to visit each child.
   * @param context A lexical environment context for the visitor.
   */
  declare export function visitEachChild<T: Node>(
    node: T | void,
    visitor: Visitor,
    context: TransformationContext,
    nodesVisitor?: typeof visitNodes,
    tokenVisitor?: Visitor
  ): T | void;

  declare export function createPrinter(
    printerOptions?: PrinterOptions,
    handlers?: PrintHandlers
  ): Printer;

  declare export function findConfigFile(
    searchPath: string,
    fileExists: (fileName: string) => boolean,
    configName?: string
  ): string | void;

  declare export function resolveTripleslashReference(
    moduleName: string,
    containingFile: string
  ): string;

  declare export function createCompilerHost(
    options: CompilerOptions,
    setParentNodes?: boolean
  ): CompilerHost;

  declare export function getPreEmitDiagnostics(
    program: Program,
    sourceFile?: SourceFile,
    cancellationToken?: CancellationToken
  ): $ReadOnlyArray<Diagnostic>;

  declare export interface FormatDiagnosticsHost {
    getCurrentDirectory(): string;
    getCanonicalFileName(fileName: string): string;
    getNewLine(): string;
  }
  declare export function formatDiagnostics(
    diagnostics: $ReadOnlyArray<Diagnostic>,
    host: FormatDiagnosticsHost
  ): string;

  declare export function formatDiagnostic(
    diagnostic: Diagnostic,
    host: FormatDiagnosticsHost
  ): string;

  declare export function formatDiagnosticsWithColorAndContext(
    diagnostics: $ReadOnlyArray<Diagnostic>,
    host: FormatDiagnosticsHost
  ): string;

  declare export function flattenDiagnosticMessageText(
    messageText: string | DiagnosticMessageChain | void,
    newLine: string
  ): string;

  declare export function getConfigFileParsingDiagnostics(
    configFileParseResult: ParsedCommandLine
  ): $ReadOnlyArray<Diagnostic>;

  /**
 * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
 * that represent a compilation unit.

Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
 * @param createProgramOptions - The options for creating a program.
 * @returns A 'Program' object.
*/
  declare export function createProgram(
    createProgramOptions: CreateProgramOptions
  ): Program;

  /**
 * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
 * that represent a compilation unit.

Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
 * @param rootNames - A set of root files.
 * @param options - The compiler options which should be used.
 * @param host - The host interacts with the underlying file system.
 * @param oldProgram - Reuses an old program structure.
 * @param configFileParsingDiagnostics - error during config file parsing
 * @returns A 'Program' object.
*/
  declare export function createProgram(
    rootNames: $ReadOnlyArray<string>,
    options: CompilerOptions,
    host?: CompilerHost,
    oldProgram?: Program,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>
  ): Program;

  /**
   *
   * @deprecated
   */
  declare export interface ResolveProjectReferencePathHost {
    fileExists(fileName: string): boolean;
  }

  /**
   * Returns the target config filename of a project reference.
   * Note: The file might not exist.
   */
  declare export function resolveProjectReferencePath(
    ref: ProjectReference
  ): ResolvedConfigFileName;

  /**
   *
   * @deprecated
   */
  declare export function resolveProjectReferencePath(
    host: ResolveProjectReferencePathHost,
    ref: ProjectReference
  ): ResolvedConfigFileName;

  declare export interface EmitOutput {
    outputFiles: OutputFile[];
    emitSkipped: boolean;
  }
  declare export interface OutputFile {
    name: string;
    writeByteOrderMark: boolean;
    text: string;
  }
  declare export type AffectedFileResult<T> = {
    result: T,
    affected: SourceFile | Program
  } | void;
  declare export interface BuilderProgramHost {
    /**
     * return true if file names are treated with case sensitivity
     */
    useCaseSensitiveFileNames(): boolean;

    /**
     * If provided this would be used this hash instead of actual file shape text for detecting changes
     */
    createHash?: (data: string) => string;

    /**
     * When emit or emitNextAffectedFile are called without writeFile,
     * this callback if present would be used to write files
     */
    writeFile?: WriteFileCallback;
  }

  /**
   * Builder to manage the program state changes
   */
  declare export interface BuilderProgram {
    /**
     * Returns current program
     */
    getProgram(): Program;

    /**
     * Get compiler options of the program
     */
    getCompilerOptions(): CompilerOptions;

    /**
     * Get the source file in the program with file name
     */
    getSourceFile(fileName: string): SourceFile | void;

    /**
     * Get a list of files in the program
     */
    getSourceFiles(): $ReadOnlyArray<SourceFile>;

    /**
     * Get the diagnostics for compiler options
     */
    getOptionsDiagnostics(
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<Diagnostic>;

    /**
     * Get the diagnostics that dont belong to any file
     */
    getGlobalDiagnostics(
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<Diagnostic>;

    /**
     * Get the diagnostics from config file parsing
     */
    getConfigFileParsingDiagnostics(): $ReadOnlyArray<Diagnostic>;

    /**
     * Get the syntax diagnostics, for all source files if source file is not supplied
     */
    getSyntacticDiagnostics(
      sourceFile?: SourceFile,
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<Diagnostic>;

    /**
     * Get the declaration diagnostics, for all source files if source file is not supplied
     */
    getDeclarationDiagnostics(
      sourceFile?: SourceFile,
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<DiagnosticWithLocation>;

    /**
     * Get all the dependencies of the file
     */
    getAllDependencies(sourceFile: SourceFile): $ReadOnlyArray<string>;

    /**
 * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program
 * The semantic diagnostics are cached and managed here
Note that it is assumed that when asked about semantic diagnostics through this API,
the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics
In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,
it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics
*/
    getSemanticDiagnostics(
      sourceFile?: SourceFile,
      cancellationToken?: CancellationToken
    ): $ReadOnlyArray<Diagnostic>;

    /**
 * Emits the JavaScript and declaration files.
 * When targetSource file is specified, emits the files corresponding to that source file,
otherwise for the whole program.
In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,
it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,
it will only emit all the affected files instead of whole program

The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
in that order would be used to write the files
*/
    emit(
      targetSourceFile?: SourceFile,
      writeFile?: WriteFileCallback,
      cancellationToken?: CancellationToken,
      emitOnlyDtsFiles?: boolean,
      customTransformers?: CustomTransformers
    ): EmitResult;

    /**
     * Get the current directory of the program
     */
    getCurrentDirectory(): string;
  }

  /**
   * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files
   */
  declare export type SemanticDiagnosticsBuilderProgram = {
    /**
     * Gets the semantic diagnostics from the program for the next affected file and caches it
     * Returns undefined if the iteration is complete
     */
    getSemanticDiagnosticsOfNextAffectedFile(
      cancellationToken?: CancellationToken,
      ignoreSourceFile?: (sourceFile: SourceFile) => boolean
    ): AffectedFileResult<$ReadOnlyArray<Diagnostic>>
  } & BuilderProgram;

  /**
   * The builder that can handle the changes in program and iterate through changed file to emit the files
   * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files
   */
  declare export type EmitAndSemanticDiagnosticsBuilderProgram = {
    /**
 * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
 * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
in that order would be used to write the files
*/
    emitNextAffectedFile(
      writeFile?: WriteFileCallback,
      cancellationToken?: CancellationToken,
      emitOnlyDtsFiles?: boolean,
      customTransformers?: CustomTransformers
    ): AffectedFileResult<EmitResult>
  } & BuilderProgram;

  /**
   * Create the builder to manage semantic diagnostics and cache them
   */
  declare export function createSemanticDiagnosticsBuilderProgram(
    newProgram: Program,
    host: BuilderProgramHost,
    oldProgram?: SemanticDiagnosticsBuilderProgram,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>
  ): SemanticDiagnosticsBuilderProgram;

  declare export function createSemanticDiagnosticsBuilderProgram(
    rootNames: $ReadOnlyArray<string> | void,
    options: CompilerOptions | void,
    host?: CompilerHost,
    oldProgram?: SemanticDiagnosticsBuilderProgram,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>,
    projectReferences?: $ReadOnlyArray<ProjectReference>
  ): SemanticDiagnosticsBuilderProgram;

  /**
   * Create the builder that can handle the changes in program and iterate through changed files
   * to emit the those files and manage semantic diagnostics cache as well
   */
  declare export function createEmitAndSemanticDiagnosticsBuilderProgram(
    newProgram: Program,
    host: BuilderProgramHost,
    oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>
  ): EmitAndSemanticDiagnosticsBuilderProgram;

  declare export function createEmitAndSemanticDiagnosticsBuilderProgram(
    rootNames: $ReadOnlyArray<string> | void,
    options: CompilerOptions | void,
    host?: CompilerHost,
    oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>,
    projectReferences?: $ReadOnlyArray<ProjectReference>
  ): EmitAndSemanticDiagnosticsBuilderProgram;

  /**
   * Creates a builder thats just abstraction over program and can be used with watch
   */
  declare export function createAbstractBuilder(
    newProgram: Program,
    host: BuilderProgramHost,
    oldProgram?: BuilderProgram,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>
  ): BuilderProgram;

  declare export function createAbstractBuilder(
    rootNames: $ReadOnlyArray<string> | void,
    options: CompilerOptions | void,
    host?: CompilerHost,
    oldProgram?: BuilderProgram,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>,
    projectReferences?: $ReadOnlyArray<ProjectReference>
  ): BuilderProgram;

  declare export type WatchStatusReporter = (
    diagnostic: Diagnostic,
    newLine: string,
    options: CompilerOptions
  ) => void;

  /**
   * Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program
   */
  declare export type CreateProgram<T: BuilderProgram> = (
    rootNames: $ReadOnlyArray<string> | void,
    options: CompilerOptions | void,
    host?: CompilerHost,
    oldProgram?: T,
    configFileParsingDiagnostics?: $ReadOnlyArray<Diagnostic>,
    projectReferences?: $ReadOnlyArray<ProjectReference> | void
  ) => T;

  /**
   * Host that has watch functionality used in --watch mode
   */
  declare export interface WatchHost {
    /**
     * If provided, called with Diagnostic message that informs about change in watch status
     */
    onWatchStatusChange(
      diagnostic: Diagnostic,
      newLine: string,
      options: CompilerOptions
    ): void;

    /**
     * Used to watch changes in source files, missing files needed to update the program or config file
     */
    watchFile(
      path: string,
      callback: FileWatcherCallback,
      pollingInterval?: number
    ): FileWatcher;

    /**
     * Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added
     */
    watchDirectory(
      path: string,
      callback: DirectoryWatcherCallback,
      recursive?: boolean
    ): FileWatcher;

    /**
     * If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together
     */
    setTimeout(
      callback: (...args: any[]) => void,
      ms: number,
      ...args: any[]
    ): any;

    /**
     * If provided, will be used to reset existing delayed compilation
     */
    clearTimeout(timeoutId: any): void;
  }
  declare export interface ProgramHost<T: BuilderProgram> {
    /**
     * Used to create the program when need for program creation or recreation detected
     */
    createProgram: CreateProgram<T>;
    useCaseSensitiveFileNames(): boolean;
    getNewLine(): string;
    getCurrentDirectory(): string;
    getDefaultLibFileName(options: CompilerOptions): string;
    getDefaultLibLocation(): string;
    createHash(data: string): string;

    /**
     * Use to check file presence for source files and
     * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
     */
    fileExists(path: string): boolean;

    /**
     * Use to read file text for source files and
     * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
     */
    readFile(path: string, encoding?: string): string | void;

    /**
     * If provided, used for module resolution as well as to handle directory structure
     */
    directoryExists(path: string): boolean;

    /**
     * If provided, used in resolutions as well as handling directory structure
     */
    getDirectories(path: string): string[];

    /**
     * If provided, used to cache and handle directory structure modifications
     */
    readDirectory(
      path: string,
      extensions?: $ReadOnlyArray<string>,
      exclude?: $ReadOnlyArray<string>,
      include?: $ReadOnlyArray<string>,
      depth?: number
    ): string[];

    /**
     * Symbol links resolution
     */
    realpath(path: string): string;

    /**
     * If provided would be used to write log about compilation
     */
    trace(s: string): void;

    /**
     * If provided is used to get the environment variable
     */
    getEnvironmentVariable(name: string): string | void;

    /**
     * If provided, used to resolve the module names, otherwise typescript's default module resolution
     */
    resolveModuleNames(
      moduleNames: string[],
      containingFile: string,
      reusedNames?: string[],
      redirectedReference?: ResolvedProjectReference
    ): (ResolvedModule | void)[];

    /**
     * If provided, used to resolve type reference directives, otherwise typescript's default resolution
     */
    resolveTypeReferenceDirectives(
      typeReferenceDirectiveNames: string[],
      containingFile: string,
      redirectedReference?: ResolvedProjectReference
    ): (ResolvedTypeReferenceDirective | void)[];
  }
  declare export type WatchCompilerHost<T: BuilderProgram> = {
    /**
     * If provided, callback to invoke after every new program creation
     */
    afterProgramCreate(program: T): void
  } & ProgramHost<T> &
    WatchHost;

  /**
   * Host to create watch with root files and options
   */
  declare export type WatchCompilerHostOfFilesAndCompilerOptions<T: BuilderProgram> = {
    /**
     * root files to use to generate program
     */
    rootFiles: string[],

    /**
     * Compiler options
     */
    options: CompilerOptions,

    /**
     * Project References
     */
    projectReferences?: $ReadOnlyArray<ProjectReference>
  } & WatchCompilerHost<T>;

  /**
   * Host to create watch with config file
   */
  declare export type WatchCompilerHostOfConfigFile<T: BuilderProgram> = {
    /**
     * Name of the config file to compile
     */
    configFileName: string,

    /**
     * Options to extend
     */
    optionsToExtend?: CompilerOptions,

    /**
     * Used to generate source file names from the config file and its include, exclude, files rules
     * and also to cache the directory stucture
     */
    readDirectory(
      path: string,
      extensions?: $ReadOnlyArray<string>,
      exclude?: $ReadOnlyArray<string>,
      include?: $ReadOnlyArray<string>,
      depth?: number
    ): string[]
  } & WatchCompilerHost<T> &
    ConfigFileDiagnosticsReporter;

  declare export interface Watch<T> {
    /**
     * Synchronize with host and get updated program
     */
    getProgram(): T;
  }

  /**
   * Creates the watch what generates program using the config file
   */
  declare export type WatchOfConfigFile<T> = {} & Watch<T>;

  /**
   * Creates the watch that generates program using the root files and compiler options
   */
  declare export type WatchOfFilesAndCompilerOptions<T> = {
    /**
     * Updates the root files in the program, only if this is not config file compilation
     */
    updateRootFileNames(fileNames: string[]): void
  } & Watch<T>;

  /**
   * Create the watch compiler host for either configFile or fileNames and its options
   */
  declare export function createWatchCompilerHost<T: BuilderProgram>(
    configFileName: string,
    optionsToExtend: CompilerOptions | void,
    system: System,
    createProgram?: CreateProgram<T>,
    reportDiagnostic?: DiagnosticReporter,
    reportWatchStatus?: WatchStatusReporter
  ): WatchCompilerHostOfConfigFile<T>;

  declare export function createWatchCompilerHost<T: BuilderProgram>(
    rootFiles: string[],
    options: CompilerOptions,
    system: System,
    createProgram?: CreateProgram<T>,
    reportDiagnostic?: DiagnosticReporter,
    reportWatchStatus?: WatchStatusReporter,
    projectReferences?: $ReadOnlyArray<ProjectReference>
  ): WatchCompilerHostOfFilesAndCompilerOptions<T>;

  /**
   * Creates the watch from the host for root files and compiler options
   */
  declare export function createWatchProgram<T: BuilderProgram>(
    host: WatchCompilerHostOfFilesAndCompilerOptions<T>
  ): WatchOfFilesAndCompilerOptions<T>;

  /**
   * Creates the watch from the host for config file
   */
  declare export function createWatchProgram<T: BuilderProgram>(
    host: WatchCompilerHostOfConfigFile<T>
  ): WatchOfConfigFile<T>;

  declare export interface SourceFileLike {
    getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
  }

  /**
 * Represents an immutable snapshot of a script at a specified time.Once acquired, the
 * snapshot is observably immutable. i.e. the same calls with the same parameters will return
the same values.
*/
  declare export interface IScriptSnapshot {
    /**
     * Gets a portion of the script snapshot specified by [start, end).
     */
    getText(start: number, end: number): string;

    /**
     * Gets the length of this script snapshot.
     */
    getLength(): number;

    /**
 * Gets the TextChangeRange that describe how the text changed between this text and
 * an older version.  This information is used by the incremental parser to determine
what sections of the script need to be re-parsed.  'undefined' can be returned if the
change range cannot be determined.  However, in that case, incremental parsing will
not happen and the entire document will be re - parsed.
*/
    getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | void;

    /**
     * Releases all resources held by this script snapshot
     */
    dispose(): void;
  }

  declare export var npm$namespace$ScriptSnapshot: {
    fromString: typeof ScriptSnapshot$fromString
  };
  declare export function ScriptSnapshot$fromString(text: string): IScriptSnapshot;

  declare export interface PreProcessedFileInfo {
    referencedFiles: FileReference[];
    typeReferenceDirectives: FileReference[];
    libReferenceDirectives: FileReference[];
    importedFiles: FileReference[];
    ambientExternalModules?: string[];
    isLibFile: boolean;
  }
  declare export interface HostCancellationToken {
    isCancellationRequested(): boolean;
  }
  declare export interface InstallPackageOptions {
    fileName: Path;
    packageName: string;
  }
  declare export type LanguageServiceHost = {
    getCompilationSettings(): CompilerOptions,
    getNewLine(): string,
    getProjectVersion(): string,
    getScriptFileNames(): string[],
    getScriptKind(fileName: string): ScriptKind,
    getScriptVersion(fileName: string): string,
    getScriptSnapshot(fileName: string): IScriptSnapshot | void,
    getProjectReferences(): $ReadOnlyArray<ProjectReference> | void,
    getLocalizedDiagnosticMessages(): any,
    getCancellationToken(): HostCancellationToken,
    getCurrentDirectory(): string,
    getDefaultLibFileName(options: CompilerOptions): string,
    log(s: string): void,
    trace(s: string): void,
    error(s: string): void,
    useCaseSensitiveFileNames(): boolean,
    readDirectory(
      path: string,
      extensions?: $ReadOnlyArray<string>,
      exclude?: $ReadOnlyArray<string>,
      include?: $ReadOnlyArray<string>,
      depth?: number
    ): string[],
    readFile(path: string, encoding?: string): string | void,
    realpath(path: string): string,
    fileExists(path: string): boolean,
    getTypeRootsVersion(): number,
    resolveModuleNames(
      moduleNames: string[],
      containingFile: string,
      reusedNames?: string[],
      redirectedReference?: ResolvedProjectReference
    ): (ResolvedModule | void)[],
    getResolvedModuleWithFailedLookupLocationsFromCache(
      modulename: string,
      containingFile: string
    ): ResolvedModuleWithFailedLookupLocations | void,
    resolveTypeReferenceDirectives(
      typeDirectiveNames: string[],
      containingFile: string,
      redirectedReference?: ResolvedProjectReference
    ): (ResolvedTypeReferenceDirective | void)[],
    getDirectories(directoryName: string): string[],

    /**
     * Gets a set of custom transformers to use during emit.
     */
    getCustomTransformers(): CustomTransformers | void,
    isKnownTypesPackageName(name: string): boolean,
    installPackage(
      options: InstallPackageOptions
    ): Promise<ApplyCodeActionCommandResult>,
    writeFile(fileName: string, content: string): void
  } & GetEffectiveTypeRootsHost;

  declare export type WithMetadata<T> = T & {
    metadata?: mixed
  };
  declare export interface LanguageService {
    cleanupSemanticCache(): void;
    getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];

    /**
     * The first time this is called, it will return global diagnostics (no location).
     */
    getSemanticDiagnostics(fileName: string): Diagnostic[];
    getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];
    getCompilerOptionsDiagnostics(): Diagnostic[];

    /**
     *
     * @deprecated Use getEncodedSyntacticClassifications instead.
     */
    getSyntacticClassifications(
      fileName: string,
      span: TextSpan
    ): ClassifiedSpan[];

    /**
     *
     * @deprecated Use getEncodedSemanticClassifications instead.
     */
    getSemanticClassifications(
      fileName: string,
      span: TextSpan
    ): ClassifiedSpan[];
    getEncodedSyntacticClassifications(
      fileName: string,
      span: TextSpan
    ): Classifications;
    getEncodedSemanticClassifications(
      fileName: string,
      span: TextSpan
    ): Classifications;
    getCompletionsAtPosition(
      fileName: string,
      position: number,
      options: GetCompletionsAtPositionOptions | void
    ): WithMetadata<CompletionInfo> | void;
    getCompletionEntryDetails(
      fileName: string,
      position: number,
      name: string,
      formatOptions: FormatCodeOptions | FormatCodeSettings | void,
      source: string | void,
      preferences: UserPreferences | void
    ): CompletionEntryDetails | void;
    getCompletionEntrySymbol(
      fileName: string,
      position: number,
      name: string,
      source: string | void
    ): Symbol | void;
    getQuickInfoAtPosition(
      fileName: string,
      position: number
    ): QuickInfo | void;
    getNameOrDottedNameSpan(
      fileName: string,
      startPos: number,
      endPos: number
    ): TextSpan | void;
    getBreakpointStatementAtPosition(
      fileName: string,
      position: number
    ): TextSpan | void;
    getSignatureHelpItems(
      fileName: string,
      position: number,
      options: SignatureHelpItemsOptions | void
    ): SignatureHelpItems | void;
    getRenameInfo(
      fileName: string,
      position: number,
      options?: RenameInfoOptions
    ): RenameInfo;
    findRenameLocations(
      fileName: string,
      position: number,
      findInStrings: boolean,
      findInComments: boolean,
      providePrefixAndSuffixTextForRename?: boolean
    ): $ReadOnlyArray<RenameLocation> | void;
    getDefinitionAtPosition(
      fileName: string,
      position: number
    ): $ReadOnlyArray<DefinitionInfo> | void;
    getDefinitionAndBoundSpan(
      fileName: string,
      position: number
    ): DefinitionInfoAndBoundSpan | void;
    getTypeDefinitionAtPosition(
      fileName: string,
      position: number
    ): $ReadOnlyArray<DefinitionInfo> | void;
    getImplementationAtPosition(
      fileName: string,
      position: number
    ): $ReadOnlyArray<ImplementationLocation> | void;
    getReferencesAtPosition(
      fileName: string,
      position: number
    ): ReferenceEntry[] | void;
    findReferences(
      fileName: string,
      position: number
    ): ReferencedSymbol[] | void;
    getDocumentHighlights(
      fileName: string,
      position: number,
      filesToSearch: string[]
    ): DocumentHighlights[] | void;

    /**
     *
     * @deprecated
     */
    getOccurrencesAtPosition(
      fileName: string,
      position: number
    ): $ReadOnlyArray<ReferenceEntry> | void;
    getNavigateToItems(
      searchValue: string,
      maxResultCount?: number,
      fileName?: string,
      excludeDtsFiles?: boolean
    ): NavigateToItem[];
    getNavigationBarItems(fileName: string): NavigationBarItem[];
    getNavigationTree(fileName: string): NavigationTree;
    getOutliningSpans(fileName: string): OutliningSpan[];
    getTodoComments(
      fileName: string,
      descriptors: TodoCommentDescriptor[]
    ): TodoComment[];
    getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];
    getIndentationAtPosition(
      fileName: string,
      position: number,
      options: EditorOptions | EditorSettings
    ): number;
    getFormattingEditsForRange(
      fileName: string,
      start: number,
      end: number,
      options: FormatCodeOptions | FormatCodeSettings
    ): TextChange[];
    getFormattingEditsForDocument(
      fileName: string,
      options: FormatCodeOptions | FormatCodeSettings
    ): TextChange[];
    getFormattingEditsAfterKeystroke(
      fileName: string,
      position: number,
      key: string,
      options: FormatCodeOptions | FormatCodeSettings
    ): TextChange[];
    getDocCommentTemplateAtPosition(
      fileName: string,
      position: number
    ): TextInsertion | void;
    isValidBraceCompletionAtPosition(
      fileName: string,
      position: number,
      openingBrace: number
    ): boolean;

    /**
     * This will return a defined result if the position is after the `>` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.
     * Editors should call this after `>` is typed.
     */
    getJsxClosingTagAtPosition(
      fileName: string,
      position: number
    ): JsxClosingTagInfo | void;
    getSpanOfEnclosingComment(
      fileName: string,
      position: number,
      onlyMultiLine: boolean
    ): TextSpan | void;
    toLineColumnOffset(fileName: string, position: number): LineAndCharacter;
    getCodeFixesAtPosition(
      fileName: string,
      start: number,
      end: number,
      errorCodes: $ReadOnlyArray<number>,
      formatOptions: FormatCodeSettings,
      preferences: UserPreferences
    ): $ReadOnlyArray<CodeFixAction>;
    getCombinedCodeFix(
      scope: CombinedCodeFixScope,
      fixId: {},
      formatOptions: FormatCodeSettings,
      preferences: UserPreferences
    ): CombinedCodeActions;
    applyCodeActionCommand(
      action: CodeActionCommand,
      formatSettings?: FormatCodeSettings
    ): Promise<ApplyCodeActionCommandResult>;
    applyCodeActionCommand(
      action: CodeActionCommand[],
      formatSettings?: FormatCodeSettings
    ): Promise<ApplyCodeActionCommandResult[]>;
    applyCodeActionCommand(
      action: CodeActionCommand | CodeActionCommand[],
      formatSettings?: FormatCodeSettings
    ): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;

    /**
     *
     * @deprecated `fileName` will be ignored
     */
    applyCodeActionCommand(
      fileName: string,
      action: CodeActionCommand
    ): Promise<ApplyCodeActionCommandResult>;

    /**
     *
     * @deprecated `fileName` will be ignored
     */
    applyCodeActionCommand(
      fileName: string,
      action: CodeActionCommand[]
    ): Promise<ApplyCodeActionCommandResult[]>;

    /**
     *
     * @deprecated `fileName` will be ignored
     */
    applyCodeActionCommand(
      fileName: string,
      action: CodeActionCommand | CodeActionCommand[]
    ): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
    getApplicableRefactors(
      fileName: string,
      positionOrRange: number | TextRange,
      preferences: UserPreferences | void
    ): ApplicableRefactorInfo[];
    getEditsForRefactor(
      fileName: string,
      formatOptions: FormatCodeSettings,
      positionOrRange: number | TextRange,
      refactorName: string,
      actionName: string,
      preferences: UserPreferences | void
    ): RefactorEditInfo | void;
    organizeImports(
      scope: OrganizeImportsScope,
      formatOptions: FormatCodeSettings,
      preferences: UserPreferences | void
    ): $ReadOnlyArray<FileTextChanges>;
    getEditsForFileRename(
      oldFilePath: string,
      newFilePath: string,
      formatOptions: FormatCodeSettings,
      preferences: UserPreferences | void
    ): $ReadOnlyArray<FileTextChanges>;
    getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean): EmitOutput;
    getProgram(): Program | void;
    dispose(): void;
  }
  declare export interface JsxClosingTagInfo {
    newText: string;
  }
  declare export interface CombinedCodeFixScope {
    type: "file";
    fileName: string;
  }
  declare export type OrganizeImportsScope = CombinedCodeFixScope;
  declare export type CompletionsTriggerCharacter =
    | "."
    | '"'
    | "'"
    | "`"
    | "/"
    | "@"
    | "<";
  declare export type GetCompletionsAtPositionOptions = {
    /**
     * If the editor is asking for completions because a certain character was typed
     * (as opposed to when the user explicitly requested them) this should be set.
     */
    triggerCharacter?: CompletionsTriggerCharacter,

    /**
     *
     * @deprecated Use includeCompletionsForModuleExports
     */
    includeExternalModuleExports?: boolean,

    /**
     *
     * @deprecated Use includeCompletionsWithInsertText
     */
    includeInsertTextCompletions?: boolean
  } & UserPreferences;

  declare export type SignatureHelpTriggerCharacter = "," | "(" | "<";
  declare export type SignatureHelpRetriggerCharacter =
    | SignatureHelpTriggerCharacter
    | ")";
  declare export interface SignatureHelpItemsOptions {
    triggerReason?: SignatureHelpTriggerReason;
  }
  declare export type SignatureHelpTriggerReason =
    | SignatureHelpInvokedReason
    | SignatureHelpCharacterTypedReason
    | SignatureHelpRetriggeredReason;

  /**
   * Signals that the user manually requested signature help.
   * The language service will unconditionally attempt to provide a result.
   */
  declare export interface SignatureHelpInvokedReason {
    kind: "invoked";
    triggerCharacter?: void;
  }

  /**
   * Signals that the signature help request came from a user typing a character.
   * Depending on the character and the syntactic context, the request may or may not be served a result.
   */
  declare export interface SignatureHelpCharacterTypedReason {
    kind: "characterTyped";

    /**
     * Character that was responsible for triggering signature help.
     */
    triggerCharacter: SignatureHelpTriggerCharacter;
  }

  /**
 * Signals that this signature help request came from typing a character or moving the cursor.
 * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.
The language service will unconditionally attempt to provide a result.
`triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
*/
  declare export interface SignatureHelpRetriggeredReason {
    kind: "retrigger";

    /**
     * Character that was responsible for triggering signature help.
     */
    triggerCharacter?: SignatureHelpRetriggerCharacter;
  }
  declare export interface ApplyCodeActionCommandResult {
    successMessage: string;
  }
  declare export interface Classifications {
    spans: number[];
    endOfLineState: EndOfLineState;
  }
  declare export interface ClassifiedSpan {
    textSpan: TextSpan;
    classificationType: ClassificationTypeNames;
  }

  /**
 * Navigation bar interface designed for visual studio's dual-column layout.
 * This does not form a proper tree.
The navbar is returned as a list of top-level items, each of which has a list of child items.
Child items always have an empty array for their `childItems`.
*/
  declare export interface NavigationBarItem {
    text: string;
    kind: ScriptElementKind;
    kindModifiers: string;
    spans: TextSpan[];
    childItems: NavigationBarItem[];
    indent: number;
    bolded: boolean;
    grayed: boolean;
  }

  /**
   * Node in a tree of nested declarations in a file.
   * The top node is always a script or module node.
   */
  declare export interface NavigationTree {
    /**
     * Name of the declaration, or a short description, e.g. "<class>".
     */
    text: string;
    kind: ScriptElementKind;

    /**
     * ScriptElementKindModifier separated by commas, e.g. "public,abstract"
     */
    kindModifiers: string;

    /**
     * Spans of the nodes that generated this declaration.
     * There will be more than one if this is the result of merging.
     */
    spans: TextSpan[];
    nameSpan: TextSpan | void;

    /**
     * Present if non-empty
     */
    childItems?: NavigationTree[];
  }
  declare export interface TodoCommentDescriptor {
    text: string;
    priority: number;
  }
  declare export interface TodoComment {
    descriptor: TodoCommentDescriptor;
    message: string;
    position: number;
  }
  declare export interface TextChange {
    span: TextSpan;
    newText: string;
  }
  declare export interface FileTextChanges {
    fileName: string;
    textChanges: TextChange[];
    isNewFile?: boolean;
  }
  declare export interface CodeAction {
    /**
     * Description of the code action to display in the UI of the editor
     */
    description: string;

    /**
     * Text changes to apply to each file as part of the code action
     */
    changes: FileTextChanges[];

    /**
     * If the user accepts the code fix, the editor should send the action back in a `applyAction` request.
     * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.
     */
    commands?: CodeActionCommand[];
  }
  declare export type CodeFixAction = {
    /**
     * Short name to identify the fix, for use by telemetry.
     */
    fixName: string,

    /**
     * If present, one may call 'getCombinedCodeFix' with this fixId.
     * This may be omitted to indicate that the code fix can't be applied in a group.
     */
    fixId?: {},
    fixAllDescription?: string
  } & CodeAction;

  declare export interface CombinedCodeActions {
    changes: $ReadOnlyArray<FileTextChanges>;
    commands?: $ReadOnlyArray<CodeActionCommand>;
  }
  declare export type CodeActionCommand = InstallPackageAction | GenerateTypesAction;
  declare export interface InstallPackageAction {}
  declare export type GenerateTypesAction = {} & GenerateTypesOptions;

  declare export interface GenerateTypesOptions {
    file: string;
    fileToGenerateTypesFor: string;
    outputFileName: string;
  }

  /**
   * A set of one or more available refactoring actions, grouped under a parent refactoring.
   */
  declare export interface ApplicableRefactorInfo {
    /**
     * The programmatic name of the refactoring
     */
    name: string;

    /**
     * A description of this refactoring category to show to the user.
     * If the refactoring gets inlined (see below), this text will not be visible.
     */
    description: string;

    /**
 * Inlineable refactorings can have their actions hoisted out to the top level
 * of a context menu. Non-inlineanable refactorings should always be shown inside
their parent grouping.

If not specified, this value is assumed to be 'true'
*/
    inlineable?: boolean;
    actions: RefactorActionInfo[];
  }

  /**
   * Represents a single refactoring action - for example, the "Extract Method..." refactor might
   * offer several actions, each corresponding to a surround class or closure to extract into.
   */
  declare export interface RefactorActionInfo {
    /**
     * The programmatic name of the refactoring action
     */
    name: string;

    /**
 * A description of this refactoring action to show to the user.
 * If the parent refactoring is inlined away, this will be the only text shown,
so this description should make sense by itself if the parent is inlineable=true
*/
    description: string;
  }

  /**
   * A set of edits to make in response to a refactor action, plus an optional
   * location where renaming should be invoked from
   */
  declare export interface RefactorEditInfo {
    edits: FileTextChanges[];
    renameFilename?: string;
    renameLocation?: number;
    commands?: CodeActionCommand[];
  }
  declare export interface TextInsertion {
    newText: string;

    /**
     * The position in newText the caret should point to after the insertion.
     */
    caretOffset: number;
  }
  declare export interface DocumentSpan {
    textSpan: TextSpan;
    fileName: string;

    /**
     * If the span represents a location that was remapped (e.g. via a .d.ts.map file),
     * then the original filename and span will be specified here
     */
    originalTextSpan?: TextSpan;
    originalFileName?: string;
  }
  declare export type RenameLocation = {
    prefixText?: string,
    suffixText?: string
  } & DocumentSpan;

  declare export type ReferenceEntry = {
    isWriteAccess: boolean,
    isDefinition: boolean,
    isInString?: true
  } & DocumentSpan;

  declare export type ImplementationLocation = {
    kind: ScriptElementKind,
    displayParts: SymbolDisplayPart[]
  } & DocumentSpan;

  declare export interface DocumentHighlights {
    fileName: string;
    highlightSpans: HighlightSpan[];
  }
  declare class HighlightSpanKind__none mixins HighlightSpanKind {}
  declare class HighlightSpanKind__definition mixins HighlightSpanKind {}
  declare class HighlightSpanKind__reference mixins HighlightSpanKind {}
  declare class HighlightSpanKind__writtenReference mixins HighlightSpanKind {}

  declare export class HighlightSpanKind {
    constructor(...args: empty): mixed;
    static none: Class<HighlightSpanKind__none> &
      HighlightSpanKind__none &
      "none"; // "none"
    static definition: Class<HighlightSpanKind__definition> &
      HighlightSpanKind__definition &
      "definition"; // "definition"
    static reference: Class<HighlightSpanKind__reference> &
      HighlightSpanKind__reference &
      "reference"; // "reference"
    static writtenReference: Class<HighlightSpanKind__writtenReference> &
      HighlightSpanKind__writtenReference &
      "writtenReference"; // "writtenReference"
  }

  declare export interface HighlightSpan {
    fileName?: string;
    isInString?: true;
    textSpan: TextSpan;
    kind: HighlightSpanKind;
  }
  declare export interface NavigateToItem {
    name: string;
    kind: ScriptElementKind;
    kindModifiers: string;
    matchKind: "exact" | "prefix" | "substring" | "camelCase";
    isCaseSensitive: boolean;
    fileName: string;
    textSpan: TextSpan;
    containerName: string;
    containerKind: ScriptElementKind;
  }
  declare class IndentStyle__None mixins IndentStyle {}
  declare class IndentStyle__Block mixins IndentStyle {}
  declare class IndentStyle__Smart mixins IndentStyle {}

  declare export class IndentStyle {
    constructor(...args: empty): mixed;
    static None: Class<IndentStyle__None> & IndentStyle__None & 0; // 0
    static Block: Class<IndentStyle__Block> & IndentStyle__Block & 1; // 1
    static Smart: Class<IndentStyle__Smart> & IndentStyle__Smart & 2; // 2
  }

  declare export interface EditorOptions {
    BaseIndentSize?: number;
    IndentSize: number;
    TabSize: number;
    NewLineCharacter: string;
    ConvertTabsToSpaces: boolean;
    IndentStyle: IndentStyle;
  }
  declare export interface EditorSettings {
    baseIndentSize?: number;
    indentSize?: number;
    tabSize?: number;
    newLineCharacter?: string;
    convertTabsToSpaces?: boolean;
    indentStyle?: IndentStyle;
  }
  declare export type FormatCodeOptions = {
    InsertSpaceAfterCommaDelimiter: boolean,
    InsertSpaceAfterSemicolonInForStatements: boolean,
    InsertSpaceBeforeAndAfterBinaryOperators: boolean,
    InsertSpaceAfterConstructor?: boolean,
    InsertSpaceAfterKeywordsInControlFlowStatements: boolean,
    InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean,
    InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean,
    InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean,
    InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean,
    InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean,
    InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean,
    InsertSpaceAfterTypeAssertion?: boolean,
    InsertSpaceBeforeFunctionParenthesis?: boolean,
    PlaceOpenBraceOnNewLineForFunctions: boolean,
    PlaceOpenBraceOnNewLineForControlBlocks: boolean,
    insertSpaceBeforeTypeAnnotation?: boolean
  } & EditorOptions;

  declare export type FormatCodeSettings = {
    insertSpaceAfterCommaDelimiter?: boolean,
    insertSpaceAfterSemicolonInForStatements?: boolean,
    insertSpaceBeforeAndAfterBinaryOperators?: boolean,
    insertSpaceAfterConstructor?: boolean,
    insertSpaceAfterKeywordsInControlFlowStatements?: boolean,
    insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean,
    insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean,
    insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean,
    insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean,
    insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean,
    insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean,
    insertSpaceAfterTypeAssertion?: boolean,
    insertSpaceBeforeFunctionParenthesis?: boolean,
    placeOpenBraceOnNewLineForFunctions?: boolean,
    placeOpenBraceOnNewLineForControlBlocks?: boolean,
    insertSpaceBeforeTypeAnnotation?: boolean,
    indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean
  } & EditorSettings;

  declare export function getDefaultFormatCodeSettings(
    newLineCharacter?: string
  ): FormatCodeSettings;

  declare export type DefinitionInfo = {
    kind: ScriptElementKind,
    name: string,
    containerKind: ScriptElementKind,
    containerName: string
  } & DocumentSpan;

  declare export interface DefinitionInfoAndBoundSpan {
    definitions?: $ReadOnlyArray<DefinitionInfo>;
    textSpan: TextSpan;
  }
  declare export type ReferencedSymbolDefinitionInfo = {
    displayParts: SymbolDisplayPart[]
  } & DefinitionInfo;

  declare export interface ReferencedSymbol {
    definition: ReferencedSymbolDefinitionInfo;
    references: ReferenceEntry[];
  }
  declare class SymbolDisplayPartKind__aliasName mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__className mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__enumName mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__fieldName mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__interfaceName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__keyword mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__lineBreak mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__numericLiteral
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__stringLiteral
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__localName mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__methodName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__moduleName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__operator mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__parameterName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__propertyName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__punctuation
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__space mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__text mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__typeParameterName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__enumMemberName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__functionName
    mixins SymbolDisplayPartKind {}
  declare class SymbolDisplayPartKind__regularExpressionLiteral
    mixins SymbolDisplayPartKind {}

  declare export class SymbolDisplayPartKind {
    constructor(...args: empty): mixed;
    static aliasName: Class<SymbolDisplayPartKind__aliasName> &
      SymbolDisplayPartKind__aliasName &
      0; // 0
    static className: Class<SymbolDisplayPartKind__className> &
      SymbolDisplayPartKind__className &
      1; // 1
    static enumName: Class<SymbolDisplayPartKind__enumName> &
      SymbolDisplayPartKind__enumName &
      2; // 2
    static fieldName: Class<SymbolDisplayPartKind__fieldName> &
      SymbolDisplayPartKind__fieldName &
      3; // 3
    static interfaceName: Class<SymbolDisplayPartKind__interfaceName> &
      SymbolDisplayPartKind__interfaceName &
      4; // 4
    static keyword: Class<SymbolDisplayPartKind__keyword> &
      SymbolDisplayPartKind__keyword &
      5; // 5
    static lineBreak: Class<SymbolDisplayPartKind__lineBreak> &
      SymbolDisplayPartKind__lineBreak &
      6; // 6
    static numericLiteral: Class<SymbolDisplayPartKind__numericLiteral> &
      SymbolDisplayPartKind__numericLiteral &
      7; // 7
    static stringLiteral: Class<SymbolDisplayPartKind__stringLiteral> &
      SymbolDisplayPartKind__stringLiteral &
      8; // 8
    static localName: Class<SymbolDisplayPartKind__localName> &
      SymbolDisplayPartKind__localName &
      9; // 9
    static methodName: Class<SymbolDisplayPartKind__methodName> &
      SymbolDisplayPartKind__methodName &
      10; // 10
    static moduleName: Class<SymbolDisplayPartKind__moduleName> &
      SymbolDisplayPartKind__moduleName &
      11; // 11
    static operator: Class<SymbolDisplayPartKind__operator> &
      SymbolDisplayPartKind__operator &
      12; // 12
    static parameterName: Class<SymbolDisplayPartKind__parameterName> &
      SymbolDisplayPartKind__parameterName &
      13; // 13
    static propertyName: Class<SymbolDisplayPartKind__propertyName> &
      SymbolDisplayPartKind__propertyName &
      14; // 14
    static punctuation: Class<SymbolDisplayPartKind__punctuation> &
      SymbolDisplayPartKind__punctuation &
      15; // 15
    static space: Class<SymbolDisplayPartKind__space> &
      SymbolDisplayPartKind__space &
      16; // 16
    static text: Class<SymbolDisplayPartKind__text> &
      SymbolDisplayPartKind__text &
      17; // 17
    static typeParameterName: Class<SymbolDisplayPartKind__typeParameterName> &
      SymbolDisplayPartKind__typeParameterName &
      18; // 18
    static enumMemberName: Class<SymbolDisplayPartKind__enumMemberName> &
      SymbolDisplayPartKind__enumMemberName &
      19; // 19
    static functionName: Class<SymbolDisplayPartKind__functionName> &
      SymbolDisplayPartKind__functionName &
      20; // 20
    static regularExpressionLiteral: Class<SymbolDisplayPartKind__regularExpressionLiteral> &
      SymbolDisplayPartKind__regularExpressionLiteral &
      21; // 21
  }

  declare export interface SymbolDisplayPart {
    text: string;
    kind: string;
  }
  declare export interface JSDocTagInfo {
    name: string;
    text?: string;
  }
  declare export interface QuickInfo {
    kind: ScriptElementKind;
    kindModifiers: string;
    textSpan: TextSpan;
    displayParts?: SymbolDisplayPart[];
    documentation?: SymbolDisplayPart[];
    tags?: JSDocTagInfo[];
  }
  declare export type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
  declare export interface RenameInfoSuccess {
    canRename: true;

    /**
     * File or directory to rename.
     * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.
     */
    fileToRename?: string;
    displayName: string;
    fullDisplayName: string;
    kind: ScriptElementKind;
    kindModifiers: string;
    triggerSpan: TextSpan;
  }
  declare export interface RenameInfoFailure {
    canRename: false;
    localizedErrorMessage: string;
  }
  declare export interface RenameInfoOptions {
    allowRenameOfImportPath?: boolean;
  }
  declare export interface SignatureHelpParameter {
    name: string;
    documentation: SymbolDisplayPart[];
    displayParts: SymbolDisplayPart[];
    isOptional: boolean;
  }

  /**
 * Represents a single signature to show in signature help.
 * The id is used for subsequent calls into the language service to ask questions about the
signature help item in the context of any documents that have been updated.  i.e. after
an edit has happened, while signature help is still active, the host can ask important
questions like 'what parameter is the user currently contained within?'.
*/
  declare export interface SignatureHelpItem {
    isVariadic: boolean;
    prefixDisplayParts: SymbolDisplayPart[];
    suffixDisplayParts: SymbolDisplayPart[];
    separatorDisplayParts: SymbolDisplayPart[];
    parameters: SignatureHelpParameter[];
    documentation: SymbolDisplayPart[];
    tags: JSDocTagInfo[];
  }

  /**
   * Represents a set of signature help items, and the preferred item that should be selected.
   */
  declare export interface SignatureHelpItems {
    items: SignatureHelpItem[];
    applicableSpan: TextSpan;
    selectedItemIndex: number;
    argumentIndex: number;
    argumentCount: number;
  }
  declare export interface CompletionInfo {
    /**
     * Not true for all glboal completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`.
     */
    isGlobalCompletion: boolean;
    isMemberCompletion: boolean;

    /**
     * true when the current location also allows for a new identifier
     */
    isNewIdentifierLocation: boolean;
    entries: CompletionEntry[];
  }
  declare export interface CompletionEntry {
    name: string;
    kind: ScriptElementKind;
    kindModifiers?: string;
    sortText: string;
    insertText?: string;

    /**
 * An optional span that indicates the text to be replaced by this completion item.
 * If present, this span should be used instead of the default one.
It will be set if the required span differs from the one generated by the default replacement behavior.
*/
    replacementSpan?: TextSpan;
    hasAction?: true;
    source?: string;
    isRecommended?: true;
  }
  declare export interface CompletionEntryDetails {
    name: string;
    kind: ScriptElementKind;
    kindModifiers: string;
    displayParts: SymbolDisplayPart[];
    documentation?: SymbolDisplayPart[];
    tags?: JSDocTagInfo[];
    codeActions?: CodeAction[];
    source?: SymbolDisplayPart[];
  }
  declare export interface OutliningSpan {
    /**
     * The span of the document to actually collapse.
     */
    textSpan: TextSpan;

    /**
     * The span of the document to display when the user hovers over the collapsed span.
     */
    hintSpan: TextSpan;

    /**
     * The text to display in the editor for the collapsed region.
     */
    bannerText: string;

    /**
     * Whether or not this region should be automatically collapsed when
     * the 'Collapse to Definitions' command is invoked.
     */
    autoCollapse: boolean;

    /**
     * Classification of the contents of the span
     */
    kind: OutliningSpanKind;
  }
  declare class OutliningSpanKind__Comment mixins OutliningSpanKind {}
  declare class OutliningSpanKind__Region mixins OutliningSpanKind {}
  declare class OutliningSpanKind__Code mixins OutliningSpanKind {}
  declare class OutliningSpanKind__Imports mixins OutliningSpanKind {}

  declare export class OutliningSpanKind {
    constructor(...args: empty): mixed;
    static Comment: Class<OutliningSpanKind__Comment> &
      OutliningSpanKind__Comment &
      "comment"; // "comment"
    static Region: Class<OutliningSpanKind__Region> &
      OutliningSpanKind__Region &
      "region"; // "region"
    static Code: Class<OutliningSpanKind__Code> &
      OutliningSpanKind__Code &
      "code"; // "code"
    static Imports: Class<OutliningSpanKind__Imports> &
      OutliningSpanKind__Imports &
      "imports"; // "imports"
  }

  declare class OutputFileType__JavaScript mixins OutputFileType {}
  declare class OutputFileType__SourceMap mixins OutputFileType {}
  declare class OutputFileType__Declaration mixins OutputFileType {}

  declare export class OutputFileType {
    constructor(...args: empty): mixed;
    static JavaScript: Class<OutputFileType__JavaScript> &
      OutputFileType__JavaScript &
      0; // 0
    static SourceMap: Class<OutputFileType__SourceMap> &
      OutputFileType__SourceMap &
      1; // 1
    static Declaration: Class<OutputFileType__Declaration> &
      OutputFileType__Declaration &
      2; // 2
  }

  declare class EndOfLineState__None mixins EndOfLineState {}
  declare class EndOfLineState__InMultiLineCommentTrivia
    mixins EndOfLineState {}
  declare class EndOfLineState__InSingleQuoteStringLiteral
    mixins EndOfLineState {}
  declare class EndOfLineState__InDoubleQuoteStringLiteral
    mixins EndOfLineState {}
  declare class EndOfLineState__InTemplateHeadOrNoSubstitutionTemplate
    mixins EndOfLineState {}
  declare class EndOfLineState__InTemplateMiddleOrTail mixins EndOfLineState {}
  declare class EndOfLineState__InTemplateSubstitutionPosition
    mixins EndOfLineState {}

  declare export class EndOfLineState {
    constructor(...args: empty): mixed;
    static None: Class<EndOfLineState__None> & EndOfLineState__None & 0; // 0
    static InMultiLineCommentTrivia: Class<EndOfLineState__InMultiLineCommentTrivia> &
      EndOfLineState__InMultiLineCommentTrivia &
      1; // 1
    static InSingleQuoteStringLiteral: Class<EndOfLineState__InSingleQuoteStringLiteral> &
      EndOfLineState__InSingleQuoteStringLiteral &
      2; // 2
    static InDoubleQuoteStringLiteral: Class<EndOfLineState__InDoubleQuoteStringLiteral> &
      EndOfLineState__InDoubleQuoteStringLiteral &
      3; // 3
    static InTemplateHeadOrNoSubstitutionTemplate: Class<EndOfLineState__InTemplateHeadOrNoSubstitutionTemplate> &
      EndOfLineState__InTemplateHeadOrNoSubstitutionTemplate &
      4; // 4
    static InTemplateMiddleOrTail: Class<EndOfLineState__InTemplateMiddleOrTail> &
      EndOfLineState__InTemplateMiddleOrTail &
      5; // 5
    static InTemplateSubstitutionPosition: Class<EndOfLineState__InTemplateSubstitutionPosition> &
      EndOfLineState__InTemplateSubstitutionPosition &
      6; // 6
  }

  declare class TokenClass__Punctuation mixins TokenClass {}
  declare class TokenClass__Keyword mixins TokenClass {}
  declare class TokenClass__Operator mixins TokenClass {}
  declare class TokenClass__Comment mixins TokenClass {}
  declare class TokenClass__Whitespace mixins TokenClass {}
  declare class TokenClass__Identifier mixins TokenClass {}
  declare class TokenClass__NumberLiteral mixins TokenClass {}
  declare class TokenClass__BigIntLiteral mixins TokenClass {}
  declare class TokenClass__StringLiteral mixins TokenClass {}
  declare class TokenClass__RegExpLiteral mixins TokenClass {}

  declare export class TokenClass {
    constructor(...args: empty): mixed;
    static Punctuation: Class<TokenClass__Punctuation> &
      TokenClass__Punctuation &
      0; // 0
    static Keyword: Class<TokenClass__Keyword> & TokenClass__Keyword & 1; // 1
    static Operator: Class<TokenClass__Operator> & TokenClass__Operator & 2; // 2
    static Comment: Class<TokenClass__Comment> & TokenClass__Comment & 3; // 3
    static Whitespace: Class<TokenClass__Whitespace> &
      TokenClass__Whitespace &
      4; // 4
    static Identifier: Class<TokenClass__Identifier> &
      TokenClass__Identifier &
      5; // 5
    static NumberLiteral: Class<TokenClass__NumberLiteral> &
      TokenClass__NumberLiteral &
      6; // 6
    static BigIntLiteral: Class<TokenClass__BigIntLiteral> &
      TokenClass__BigIntLiteral &
      7; // 7
    static StringLiteral: Class<TokenClass__StringLiteral> &
      TokenClass__StringLiteral &
      8; // 8
    static RegExpLiteral: Class<TokenClass__RegExpLiteral> &
      TokenClass__RegExpLiteral &
      9; // 9
  }

  declare export interface ClassificationResult {
    finalLexState: EndOfLineState;
    entries: ClassificationInfo[];
  }
  declare export interface ClassificationInfo {
    length: number;
    classification: TokenClass;
  }
  declare export interface Classifier {
    /**
 * Gives lexical classifications of tokens on a line without any syntactic context.
 * For instance, a token consisting of the text 'string' can be either an identifier
named 'string' or the keyword 'string', however, because this classifier is not aware,
it relies on certain heuristics to give acceptable results. For classifications where
speed trumps accuracy, this function is preferable; however, for true accuracy, the
syntactic classifier is ideal. In fact, in certain editing scenarios, combining the
lexical, syntactic, and semantic classifiers may issue the best user experience.
 * @param text The text of a line to classify.
 * @param lexState The state of the lexical classifier at the end of the previous line.
 * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.
If there is no syntactic classifier (syntacticClassifierAbsent=true),
certain heuristics may be used in its place; however, if there is a
syntactic classifier (syntacticClassifierAbsent=false), certain
classifications which may be incorrectly categorized will be given
back as Identifiers in order to allow the syntactic classifier to
subsume the classification.
 * @deprecated Use getLexicalClassifications instead.
*/
    getClassificationsForLine(
      text: string,
      lexState: EndOfLineState,
      syntacticClassifierAbsent: boolean
    ): ClassificationResult;
    getEncodedLexicalClassifications(
      text: string,
      endOfLineState: EndOfLineState,
      syntacticClassifierAbsent: boolean
    ): Classifications;
  }
  declare class ScriptElementKind__unknown mixins ScriptElementKind {}
  declare class ScriptElementKind__warning mixins ScriptElementKind {}
  declare class ScriptElementKind__keyword mixins ScriptElementKind {}
  declare class ScriptElementKind__scriptElement mixins ScriptElementKind {}
  declare class ScriptElementKind__moduleElement mixins ScriptElementKind {}
  declare class ScriptElementKind__classElement mixins ScriptElementKind {}
  declare class ScriptElementKind__localClassElement mixins ScriptElementKind {}
  declare class ScriptElementKind__interfaceElement mixins ScriptElementKind {}
  declare class ScriptElementKind__typeElement mixins ScriptElementKind {}
  declare class ScriptElementKind__enumElement mixins ScriptElementKind {}
  declare class ScriptElementKind__enumMemberElement mixins ScriptElementKind {}
  declare class ScriptElementKind__variableElement mixins ScriptElementKind {}
  declare class ScriptElementKind__localVariableElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__functionElement mixins ScriptElementKind {}
  declare class ScriptElementKind__localFunctionElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__memberFunctionElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__memberGetAccessorElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__memberSetAccessorElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__memberVariableElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__constructorImplementationElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__callSignatureElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__indexSignatureElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__constructSignatureElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__parameterElement mixins ScriptElementKind {}
  declare class ScriptElementKind__typeParameterElement
    mixins ScriptElementKind {}
  declare class ScriptElementKind__primitiveType mixins ScriptElementKind {}
  declare class ScriptElementKind__label mixins ScriptElementKind {}
  declare class ScriptElementKind__alias mixins ScriptElementKind {}
  declare class ScriptElementKind__constElement mixins ScriptElementKind {}
  declare class ScriptElementKind__letElement mixins ScriptElementKind {}
  declare class ScriptElementKind__directory mixins ScriptElementKind {}
  declare class ScriptElementKind__externalModuleName
    mixins ScriptElementKind {}
  declare class ScriptElementKind__jsxAttribute mixins ScriptElementKind {}
  declare class ScriptElementKind__string mixins ScriptElementKind {}

  declare export class ScriptElementKind {
    constructor(...args: empty): mixed;
    static unknown: Class<ScriptElementKind__unknown> &
      ScriptElementKind__unknown &
      ""; // ""
    static warning: Class<ScriptElementKind__warning> &
      ScriptElementKind__warning &
      "warning"; // "warning"
    static keyword: Class<ScriptElementKind__keyword> &
      ScriptElementKind__keyword &
      "keyword"; // "keyword"
    static scriptElement: Class<ScriptElementKind__scriptElement> &
      ScriptElementKind__scriptElement &
      "script"; // "script"
    static moduleElement: Class<ScriptElementKind__moduleElement> &
      ScriptElementKind__moduleElement &
      "module"; // "module"
    static classElement: Class<ScriptElementKind__classElement> &
      ScriptElementKind__classElement &
      "class"; // "class"
    static localClassElement: Class<ScriptElementKind__localClassElement> &
      ScriptElementKind__localClassElement &
      "local class"; // "local class"
    static interfaceElement: Class<ScriptElementKind__interfaceElement> &
      ScriptElementKind__interfaceElement &
      "interface"; // "interface"
    static typeElement: Class<ScriptElementKind__typeElement> &
      ScriptElementKind__typeElement &
      "type"; // "type"
    static enumElement: Class<ScriptElementKind__enumElement> &
      ScriptElementKind__enumElement &
      "enum"; // "enum"
    static enumMemberElement: Class<ScriptElementKind__enumMemberElement> &
      ScriptElementKind__enumMemberElement &
      "enum member"; // "enum member"
    static variableElement: Class<ScriptElementKind__variableElement> &
      ScriptElementKind__variableElement &
      "var"; // "var"
    static localVariableElement: Class<ScriptElementKind__localVariableElement> &
      ScriptElementKind__localVariableElement &
      "local var"; // "local var"
    static functionElement: Class<ScriptElementKind__functionElement> &
      ScriptElementKind__functionElement &
      "function"; // "function"
    static localFunctionElement: Class<ScriptElementKind__localFunctionElement> &
      ScriptElementKind__localFunctionElement &
      "local function"; // "local function"
    static memberFunctionElement: Class<ScriptElementKind__memberFunctionElement> &
      ScriptElementKind__memberFunctionElement &
      "method"; // "method"
    static memberGetAccessorElement: Class<ScriptElementKind__memberGetAccessorElement> &
      ScriptElementKind__memberGetAccessorElement &
      "getter"; // "getter"
    static memberSetAccessorElement: Class<ScriptElementKind__memberSetAccessorElement> &
      ScriptElementKind__memberSetAccessorElement &
      "setter"; // "setter"
    static memberVariableElement: Class<ScriptElementKind__memberVariableElement> &
      ScriptElementKind__memberVariableElement &
      "property"; // "property"
    static constructorImplementationElement: Class<ScriptElementKind__constructorImplementationElement> &
      ScriptElementKind__constructorImplementationElement &
      "constructor"; // "constructor"
    static callSignatureElement: Class<ScriptElementKind__callSignatureElement> &
      ScriptElementKind__callSignatureElement &
      "call"; // "call"
    static indexSignatureElement: Class<ScriptElementKind__indexSignatureElement> &
      ScriptElementKind__indexSignatureElement &
      "index"; // "index"
    static constructSignatureElement: Class<ScriptElementKind__constructSignatureElement> &
      ScriptElementKind__constructSignatureElement &
      "construct"; // "construct"
    static parameterElement: Class<ScriptElementKind__parameterElement> &
      ScriptElementKind__parameterElement &
      "parameter"; // "parameter"
    static typeParameterElement: Class<ScriptElementKind__typeParameterElement> &
      ScriptElementKind__typeParameterElement &
      "type parameter"; // "type parameter"
    static primitiveType: Class<ScriptElementKind__primitiveType> &
      ScriptElementKind__primitiveType &
      "primitive type"; // "primitive type"
    static label: Class<ScriptElementKind__label> &
      ScriptElementKind__label &
      "label"; // "label"
    static alias: Class<ScriptElementKind__alias> &
      ScriptElementKind__alias &
      "alias"; // "alias"
    static constElement: Class<ScriptElementKind__constElement> &
      ScriptElementKind__constElement &
      "const"; // "const"
    static letElement: Class<ScriptElementKind__letElement> &
      ScriptElementKind__letElement &
      "let"; // "let"
    static directory: Class<ScriptElementKind__directory> &
      ScriptElementKind__directory &
      "directory"; // "directory"
    static externalModuleName: Class<ScriptElementKind__externalModuleName> &
      ScriptElementKind__externalModuleName &
      "external module name"; // "external module name"
    static jsxAttribute: Class<ScriptElementKind__jsxAttribute> &
      ScriptElementKind__jsxAttribute &
      "JSX attribute"; // "JSX attribute"
    static string: Class<ScriptElementKind__string> &
      ScriptElementKind__string &
      "string"; // "string"
  }

  declare class ScriptElementKindModifier__none
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__publicMemberModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__privateMemberModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__protectedMemberModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__exportedModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__ambientModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__staticModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__abstractModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__optionalModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__dtsModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__tsModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__tsxModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__jsModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__jsxModifier
    mixins ScriptElementKindModifier {}
  declare class ScriptElementKindModifier__jsonModifier
    mixins ScriptElementKindModifier {}

  declare export class ScriptElementKindModifier {
    constructor(...args: empty): mixed;
    static none: Class<ScriptElementKindModifier__none> &
      ScriptElementKindModifier__none &
      ""; // ""
    static publicMemberModifier: Class<ScriptElementKindModifier__publicMemberModifier> &
      ScriptElementKindModifier__publicMemberModifier &
      "public"; // "public"
    static privateMemberModifier: Class<ScriptElementKindModifier__privateMemberModifier> &
      ScriptElementKindModifier__privateMemberModifier &
      "private"; // "private"
    static protectedMemberModifier: Class<ScriptElementKindModifier__protectedMemberModifier> &
      ScriptElementKindModifier__protectedMemberModifier &
      "protected"; // "protected"
    static exportedModifier: Class<ScriptElementKindModifier__exportedModifier> &
      ScriptElementKindModifier__exportedModifier &
      "export"; // "export"
    static ambientModifier: Class<ScriptElementKindModifier__ambientModifier> &
      ScriptElementKindModifier__ambientModifier &
      "declare"; // "declare"
    static staticModifier: Class<ScriptElementKindModifier__staticModifier> &
      ScriptElementKindModifier__staticModifier &
      "static"; // "static"
    static abstractModifier: Class<ScriptElementKindModifier__abstractModifier> &
      ScriptElementKindModifier__abstractModifier &
      "abstract"; // "abstract"
    static optionalModifier: Class<ScriptElementKindModifier__optionalModifier> &
      ScriptElementKindModifier__optionalModifier &
      "optional"; // "optional"
    static dtsModifier: Class<ScriptElementKindModifier__dtsModifier> &
      ScriptElementKindModifier__dtsModifier &
      ".d.ts"; // ".d.ts"
    static tsModifier: Class<ScriptElementKindModifier__tsModifier> &
      ScriptElementKindModifier__tsModifier &
      ".ts"; // ".ts"
    static tsxModifier: Class<ScriptElementKindModifier__tsxModifier> &
      ScriptElementKindModifier__tsxModifier &
      ".tsx"; // ".tsx"
    static jsModifier: Class<ScriptElementKindModifier__jsModifier> &
      ScriptElementKindModifier__jsModifier &
      ".js"; // ".js"
    static jsxModifier: Class<ScriptElementKindModifier__jsxModifier> &
      ScriptElementKindModifier__jsxModifier &
      ".jsx"; // ".jsx"
    static jsonModifier: Class<ScriptElementKindModifier__jsonModifier> &
      ScriptElementKindModifier__jsonModifier &
      ".json"; // ".json"
  }

  declare class ClassificationTypeNames__comment
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__identifier
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__keyword
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__numericLiteral
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__bigintLiteral
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__operator
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__stringLiteral
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__whiteSpace
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__text mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__punctuation
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__className
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__enumName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__interfaceName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__moduleName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__typeParameterName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__typeAliasName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__parameterName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__docCommentTagName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__jsxOpenTagName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__jsxCloseTagName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__jsxSelfClosingTagName
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__jsxAttribute
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__jsxText
    mixins ClassificationTypeNames {}
  declare class ClassificationTypeNames__jsxAttributeStringLiteralValue
    mixins ClassificationTypeNames {}

  declare export class ClassificationTypeNames {
    constructor(...args: empty): mixed;
    static comment: Class<ClassificationTypeNames__comment> &
      ClassificationTypeNames__comment &
      "comment"; // "comment"
    static identifier: Class<ClassificationTypeNames__identifier> &
      ClassificationTypeNames__identifier &
      "identifier"; // "identifier"
    static keyword: Class<ClassificationTypeNames__keyword> &
      ClassificationTypeNames__keyword &
      "keyword"; // "keyword"
    static numericLiteral: Class<ClassificationTypeNames__numericLiteral> &
      ClassificationTypeNames__numericLiteral &
      "number"; // "number"
    static bigintLiteral: Class<ClassificationTypeNames__bigintLiteral> &
      ClassificationTypeNames__bigintLiteral &
      "bigint"; // "bigint"
    static operator: Class<ClassificationTypeNames__operator> &
      ClassificationTypeNames__operator &
      "operator"; // "operator"
    static stringLiteral: Class<ClassificationTypeNames__stringLiteral> &
      ClassificationTypeNames__stringLiteral &
      "string"; // "string"
    static whiteSpace: Class<ClassificationTypeNames__whiteSpace> &
      ClassificationTypeNames__whiteSpace &
      "whitespace"; // "whitespace"
    static text: Class<ClassificationTypeNames__text> &
      ClassificationTypeNames__text &
      "text"; // "text"
    static punctuation: Class<ClassificationTypeNames__punctuation> &
      ClassificationTypeNames__punctuation &
      "punctuation"; // "punctuation"
    static className: Class<ClassificationTypeNames__className> &
      ClassificationTypeNames__className &
      "class name"; // "class name"
    static enumName: Class<ClassificationTypeNames__enumName> &
      ClassificationTypeNames__enumName &
      "enum name"; // "enum name"
    static interfaceName: Class<ClassificationTypeNames__interfaceName> &
      ClassificationTypeNames__interfaceName &
      "interface name"; // "interface name"
    static moduleName: Class<ClassificationTypeNames__moduleName> &
      ClassificationTypeNames__moduleName &
      "module name"; // "module name"
    static typeParameterName: Class<ClassificationTypeNames__typeParameterName> &
      ClassificationTypeNames__typeParameterName &
      "type parameter name"; // "type parameter name"
    static typeAliasName: Class<ClassificationTypeNames__typeAliasName> &
      ClassificationTypeNames__typeAliasName &
      "type alias name"; // "type alias name"
    static parameterName: Class<ClassificationTypeNames__parameterName> &
      ClassificationTypeNames__parameterName &
      "parameter name"; // "parameter name"
    static docCommentTagName: Class<ClassificationTypeNames__docCommentTagName> &
      ClassificationTypeNames__docCommentTagName &
      "doc comment tag name"; // "doc comment tag name"
    static jsxOpenTagName: Class<ClassificationTypeNames__jsxOpenTagName> &
      ClassificationTypeNames__jsxOpenTagName &
      "jsx open tag name"; // "jsx open tag name"
    static jsxCloseTagName: Class<ClassificationTypeNames__jsxCloseTagName> &
      ClassificationTypeNames__jsxCloseTagName &
      "jsx close tag name"; // "jsx close tag name"
    static jsxSelfClosingTagName: Class<ClassificationTypeNames__jsxSelfClosingTagName> &
      ClassificationTypeNames__jsxSelfClosingTagName &
      "jsx self closing tag name"; // "jsx self closing tag name"
    static jsxAttribute: Class<ClassificationTypeNames__jsxAttribute> &
      ClassificationTypeNames__jsxAttribute &
      "jsx attribute"; // "jsx attribute"
    static jsxText: Class<ClassificationTypeNames__jsxText> &
      ClassificationTypeNames__jsxText &
      "jsx text"; // "jsx text"
    static jsxAttributeStringLiteralValue: Class<ClassificationTypeNames__jsxAttributeStringLiteralValue> &
      ClassificationTypeNames__jsxAttributeStringLiteralValue &
      "jsx attribute string literal value"; // "jsx attribute string literal value"
  }

  declare class ClassificationType__comment mixins ClassificationType {}
  declare class ClassificationType__identifier mixins ClassificationType {}
  declare class ClassificationType__keyword mixins ClassificationType {}
  declare class ClassificationType__numericLiteral mixins ClassificationType {}
  declare class ClassificationType__operator mixins ClassificationType {}
  declare class ClassificationType__stringLiteral mixins ClassificationType {}
  declare class ClassificationType__regularExpressionLiteral
    mixins ClassificationType {}
  declare class ClassificationType__whiteSpace mixins ClassificationType {}
  declare class ClassificationType__text mixins ClassificationType {}
  declare class ClassificationType__punctuation mixins ClassificationType {}
  declare class ClassificationType__className mixins ClassificationType {}
  declare class ClassificationType__enumName mixins ClassificationType {}
  declare class ClassificationType__interfaceName mixins ClassificationType {}
  declare class ClassificationType__moduleName mixins ClassificationType {}
  declare class ClassificationType__typeParameterName
    mixins ClassificationType {}
  declare class ClassificationType__typeAliasName mixins ClassificationType {}
  declare class ClassificationType__parameterName mixins ClassificationType {}
  declare class ClassificationType__docCommentTagName
    mixins ClassificationType {}
  declare class ClassificationType__jsxOpenTagName mixins ClassificationType {}
  declare class ClassificationType__jsxCloseTagName mixins ClassificationType {}
  declare class ClassificationType__jsxSelfClosingTagName
    mixins ClassificationType {}
  declare class ClassificationType__jsxAttribute mixins ClassificationType {}
  declare class ClassificationType__jsxText mixins ClassificationType {}
  declare class ClassificationType__jsxAttributeStringLiteralValue
    mixins ClassificationType {}
  declare class ClassificationType__bigintLiteral mixins ClassificationType {}

  declare export class ClassificationType {
    constructor(...args: empty): mixed;
    static comment: Class<ClassificationType__comment> &
      ClassificationType__comment &
      1; // 1
    static identifier: Class<ClassificationType__identifier> &
      ClassificationType__identifier &
      2; // 2
    static keyword: Class<ClassificationType__keyword> &
      ClassificationType__keyword &
      3; // 3
    static numericLiteral: Class<ClassificationType__numericLiteral> &
      ClassificationType__numericLiteral &
      4; // 4
    static operator: Class<ClassificationType__operator> &
      ClassificationType__operator &
      5; // 5
    static stringLiteral: Class<ClassificationType__stringLiteral> &
      ClassificationType__stringLiteral &
      6; // 6
    static regularExpressionLiteral: Class<ClassificationType__regularExpressionLiteral> &
      ClassificationType__regularExpressionLiteral &
      7; // 7
    static whiteSpace: Class<ClassificationType__whiteSpace> &
      ClassificationType__whiteSpace &
      8; // 8
    static text: Class<ClassificationType__text> & ClassificationType__text & 9; // 9
    static punctuation: Class<ClassificationType__punctuation> &
      ClassificationType__punctuation &
      10; // 10
    static className: Class<ClassificationType__className> &
      ClassificationType__className &
      11; // 11
    static enumName: Class<ClassificationType__enumName> &
      ClassificationType__enumName &
      12; // 12
    static interfaceName: Class<ClassificationType__interfaceName> &
      ClassificationType__interfaceName &
      13; // 13
    static moduleName: Class<ClassificationType__moduleName> &
      ClassificationType__moduleName &
      14; // 14
    static typeParameterName: Class<ClassificationType__typeParameterName> &
      ClassificationType__typeParameterName &
      15; // 15
    static typeAliasName: Class<ClassificationType__typeAliasName> &
      ClassificationType__typeAliasName &
      16; // 16
    static parameterName: Class<ClassificationType__parameterName> &
      ClassificationType__parameterName &
      17; // 17
    static docCommentTagName: Class<ClassificationType__docCommentTagName> &
      ClassificationType__docCommentTagName &
      18; // 18
    static jsxOpenTagName: Class<ClassificationType__jsxOpenTagName> &
      ClassificationType__jsxOpenTagName &
      19; // 19
    static jsxCloseTagName: Class<ClassificationType__jsxCloseTagName> &
      ClassificationType__jsxCloseTagName &
      20; // 20
    static jsxSelfClosingTagName: Class<ClassificationType__jsxSelfClosingTagName> &
      ClassificationType__jsxSelfClosingTagName &
      21; // 21
    static jsxAttribute: Class<ClassificationType__jsxAttribute> &
      ClassificationType__jsxAttribute &
      22; // 22
    static jsxText: Class<ClassificationType__jsxText> &
      ClassificationType__jsxText &
      23; // 23
    static jsxAttributeStringLiteralValue: Class<ClassificationType__jsxAttributeStringLiteralValue> &
      ClassificationType__jsxAttributeStringLiteralValue &
      24; // 24
    static bigintLiteral: Class<ClassificationType__bigintLiteral> &
      ClassificationType__bigintLiteral &
      25; // 25
  }

  declare export function createClassifier(): Classifier;

  /**
 * The document registry represents a store of SourceFile objects that can be shared between
 * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
of files in the context.
SourceFile objects account for most of the memory usage by the language service. Sharing
the same DocumentRegistry instance between different instances of LanguageService allow
for more efficient memory utilization since all projects will share at least the library
file (lib.d.ts).

A more advanced use of the document registry is to serialize sourceFile objects to disk
and re-hydrate them when needed.

To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
to all subsequent createLanguageService calls.
*/
  declare export interface DocumentRegistry {
    /**
 * Request a stored SourceFile with a given fileName and compilationSettings.
 * The first call to acquire will call createLanguageServiceSourceFile to generate
the SourceFile if was not found in the registry.
 * @param fileName The name of the file requested
 * @param compilationSettings Some compilation settings like target affects the
shape of a the resulting SourceFile. This allows the DocumentRegistry to store
multiple copies of the same file for different compilation settings.
 * @param scriptSnapshot Text of the file. Only used if the file was not found
in the registry and a new one was created.
 * @param version Current version of the file. Only used if the file was not found
in the registry and a new one was created.
*/
    acquireDocument(
      fileName: string,
      compilationSettings: CompilerOptions,
      scriptSnapshot: IScriptSnapshot,
      version: string,
      scriptKind?: ScriptKind
    ): SourceFile;
    acquireDocumentWithKey(
      fileName: string,
      path: Path,
      compilationSettings: CompilerOptions,
      key: DocumentRegistryBucketKey,
      scriptSnapshot: IScriptSnapshot,
      version: string,
      scriptKind?: ScriptKind
    ): SourceFile;

    /**
 * Request an updated version of an already existing SourceFile with a given fileName
 * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile
to get an updated SourceFile.
 * @param fileName The name of the file requested
 * @param compilationSettings Some compilation settings like target affects the
shape of a the resulting SourceFile. This allows the DocumentRegistry to store
multiple copies of the same file for different compilation settings.
 * @param scriptSnapshot Text of the file.
 * @param version Current version of the file.
*/
    updateDocument(
      fileName: string,
      compilationSettings: CompilerOptions,
      scriptSnapshot: IScriptSnapshot,
      version: string,
      scriptKind?: ScriptKind
    ): SourceFile;
    updateDocumentWithKey(
      fileName: string,
      path: Path,
      compilationSettings: CompilerOptions,
      key: DocumentRegistryBucketKey,
      scriptSnapshot: IScriptSnapshot,
      version: string,
      scriptKind?: ScriptKind
    ): SourceFile;
    getKeyForCompilationSettings(
      settings: CompilerOptions
    ): DocumentRegistryBucketKey;

    /**
 * Informs the DocumentRegistry that a file is not needed any longer.
 * 
Note: It is not allowed to call release on a SourceFile that was not acquired from
this registry originally.
 * @param fileName The name of the file to be released
 * @param compilationSettings The compilation settings used to acquire the file
*/
    releaseDocument(
      fileName: string,
      compilationSettings: CompilerOptions
    ): void;
    releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey): void;
    reportStats(): string;
  }
  declare export type DocumentRegistryBucketKey = string & {
    __bucketKey: any
  };
  declare export function createDocumentRegistry(
    useCaseSensitiveFileNames?: boolean,
    currentDirectory?: string
  ): DocumentRegistry;

  declare export function preProcessFile(
    sourceText: string,
    readImportFiles?: boolean,
    detectJavaScriptImports?: boolean
  ): PreProcessedFileInfo;

  declare export interface TranspileOptions {
    compilerOptions?: CompilerOptions;
    fileName?: string;
    reportDiagnostics?: boolean;
    moduleName?: string;
    renamedDependencies?: MapLike<string>;
    transformers?: CustomTransformers;
  }
  declare export interface TranspileOutput {
    outputText: string;
    diagnostics?: Diagnostic[];
    sourceMapText?: string;
  }
  declare export function transpileModule(
    input: string,
    transpileOptions: TranspileOptions
  ): TranspileOutput;

  declare export function transpile(
    input: string,
    compilerOptions?: CompilerOptions,
    fileName?: string,
    diagnostics?: Diagnostic[],
    moduleName?: string
  ): string;

  declare export function generateTypesForModule(
    name: string,
    moduleValue: mixed,
    formatSettings: FormatCodeSettings
  ): string;

  declare export function generateTypesForGlobal(
    name: string,
    globalValue: mixed,
    formatSettings: FormatCodeSettings
  ): string;

  declare export var servicesVersion: "0.8";
  declare export function toEditorSettings(
    options: EditorOptions | EditorSettings
  ): EditorSettings;

  declare export function displayPartsToString(
    displayParts: SymbolDisplayPart[] | void
  ): string;

  declare export function getDefaultCompilerOptions(): CompilerOptions;

  declare export function getSupportedCodeFixes(): string[];

  declare export function createLanguageServiceSourceFile(
    fileName: string,
    scriptSnapshot: IScriptSnapshot,
    scriptTarget: ScriptTarget,
    version: string,
    setNodeParents: boolean,
    scriptKind?: ScriptKind
  ): SourceFile;

  declare export var disableIncrementalParsing: boolean;
  declare export function updateLanguageServiceSourceFile(
    sourceFile: SourceFile,
    scriptSnapshot: IScriptSnapshot,
    version: string,
    textChangeRange: TextChangeRange | void,
    aggressiveChecks?: boolean
  ): SourceFile;

  declare export function createLanguageService(
    host: LanguageServiceHost,
    documentRegistry?: DocumentRegistry,
    syntaxOnly?: boolean
  ): LanguageService;

  /**
 * Get the path of the default library files (lib.d.ts) as distributed with the typescript
 * node package.
The functionality is not supported if the ts module is consumed outside of a node module.
*/
  declare export function getDefaultLibFilePath(options: CompilerOptions): string;

  /**
   * Transform one or more nodes using the supplied transformers.
   * @param source A single `Node` or an array of `Node` objects.
   * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
   * @param compilerOptions Optional compiler options.
   */
  declare export function transform<T: Node>(
    source: T | T[],
    transformers: TransformerFactory<T>[],
    compilerOptions?: CompilerOptions
  ): TransformationResult<T>;

  declare export type ActionSet = "action::set";
  declare export type ActionInvalidate = "action::invalidate";
  declare export type ActionPackageInstalled = "action::packageInstalled";
  declare export type ActionValueInspected = "action::valueInspected";
  declare export type EventTypesRegistry = "event::typesRegistry";
  declare export type EventBeginInstallTypes = "event::beginInstallTypes";
  declare export type EventEndInstallTypes = "event::endInstallTypes";
  declare export type EventInitializationFailed = "event::initializationFailed";
  declare export interface TypingInstallerResponse {
    kind:
      | ActionSet
      | ActionInvalidate
      | EventTypesRegistry
      | ActionPackageInstalled
      | ActionValueInspected
      | EventBeginInstallTypes
      | EventEndInstallTypes
      | EventInitializationFailed;
  }
  declare export interface TypingInstallerRequestWithProjectName {
    projectName: string;
  }
  declare export type DiscoverTypings = {
    fileNames: string[],
    projectRootPath: Path,
    compilerOptions: CompilerOptions,
    typeAcquisition: TypeAcquisition,
    unresolvedImports: SortedReadonlyArray<string>,
    cachePath?: string,
    kind: "discover"
  } & TypingInstallerRequestWithProjectName;

  declare export type CloseProject = {
    kind: "closeProject"
  } & TypingInstallerRequestWithProjectName;

  declare export interface TypesRegistryRequest {
    kind: "typesRegistry";
  }
  declare export type InstallPackageRequest = {
    kind: "installPackage",
    fileName: Path,
    packageName: string,
    projectRootPath: Path
  } & TypingInstallerRequestWithProjectName;

  declare export type PackageInstalledResponse = {
    kind: ActionPackageInstalled,
    success: boolean,
    message: string
  } & ProjectResponse;

  declare export type InitializationFailedResponse = {
    kind: EventInitializationFailed,
    message: string
  } & TypingInstallerResponse;

  declare export type ProjectResponse = {
    projectName: string
  } & TypingInstallerResponse;

  declare export type InvalidateCachedTypings = {
    kind: ActionInvalidate
  } & ProjectResponse;

  declare export type InstallTypes = {
    kind: EventBeginInstallTypes | EventEndInstallTypes,
    eventId: number,
    typingsInstallerVersion: string,
    packagesToInstall: $ReadOnlyArray<string>
  } & ProjectResponse;

  declare export type BeginInstallTypes = {
    kind: EventBeginInstallTypes
  } & InstallTypes;

  declare export type EndInstallTypes = {
    kind: EventEndInstallTypes,
    installSuccess: boolean
  } & InstallTypes;

  declare export type SetTypings = {
    typeAcquisition: TypeAcquisition,
    compilerOptions: CompilerOptions,
    typings: string[],
    unresolvedImports: SortedReadonlyArray<string>,
    kind: ActionSet
  } & ProjectResponse;
}
declare export function setTimeout(
  handler: (...args: any[]) => void,
  timeout: number
): any;
declare export function clearTimeout(handle: any): void;